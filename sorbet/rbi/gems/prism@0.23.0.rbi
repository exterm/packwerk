# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `prism` gem.
# Please instead update this file by running `bin/tapioca gem prism`.

# The Prism Ruby parser.
#
# "Parsing Ruby is suddenly manageable!"
#   - You, hopefully
#
# source://prism-0.23.0/lib/prism.rb:8
module Prism
  class << self
    # Mirror the Prism.dump API by using the serialization API.
    def dump(*_arg0); end

    # Mirror the Prism.dump_file API by using the serialization API.
    def dump_file(*_arg0); end

    # Mirror the Prism.lex API by using the serialization API.
    def lex(*_arg0); end

    # :call-seq:
    #   Prism::lex_compat(source, **options) -> ParseResult
    #
    # Returns a parse result whose value is an array of tokens that closely
    # resembles the return value of Ripper::lex. The main difference is that the
    # `:on_sp` token is not emitted.
    #
    # For supported options, see Prism::parse.
    #
    # source://prism-0.23.0/lib/prism.rb:46
    def lex_compat(source, **options); end

    # Mirror the Prism.lex_file API by using the serialization API.
    def lex_file(*_arg0); end

    # :call-seq:
    #   Prism::lex_ripper(source) -> Array
    #
    # This lexes with the Ripper lex. It drops any space events but otherwise
    # returns the same tokens. Raises SyntaxError if the syntax in source is
    # invalid.
    #
    # source://prism-0.23.0/lib/prism.rb:56
    def lex_ripper(source); end

    # :call-seq:
    #   Prism::load(source, serialized) -> ParseResult
    #
    # Load the serialized AST using the source as a reference into a tree.
    #
    # source://prism-0.23.0/lib/prism.rb:64
    def load(source, serialized); end

    # Mirror the Prism.parse API by using the serialization API.
    def parse(*_arg0); end

    # Mirror the Prism.parse_comments API by using the serialization API.
    def parse_comments(*_arg0); end

    # :call-seq:
    #   Prism::parse_failure?(source, **options) -> bool
    #
    # Returns true if the source parses with errors.
    #
    # @return [Boolean]
    #
    # source://prism-0.23.0/lib/prism.rb:72
    def parse_failure?(source, **options); end

    # Mirror the Prism.parse_file API by using the serialization API. This uses
    # native strings instead of Ruby strings because it allows us to use mmap when
    # it is available.
    def parse_file(*_arg0); end

    # Mirror the Prism.parse_file_comments API by using the serialization
    # API. This uses native strings instead of Ruby strings because it allows us
    # to use mmap when it is available.
    def parse_file_comments(*_arg0); end

    # :call-seq:
    #   Prism::parse_file_failure?(filepath, **options) -> bool
    #
    # Returns true if the file at filepath parses with errors.
    #
    # @return [Boolean]
    #
    # source://prism-0.23.0/lib/prism.rb:80
    def parse_file_failure?(filepath, **options); end

    # Mirror the Prism.parse_file_success? API by using the serialization API.
    #
    # @return [Boolean]
    def parse_file_success?(*_arg0); end

    # Mirror the Prism.parse_lex API by using the serialization API.
    def parse_lex(*_arg0); end

    # Mirror the Prism.parse_lex_file API by using the serialization API.
    def parse_lex_file(*_arg0); end

    # Mirror the Prism.parse_success? API by using the serialization API.
    #
    # @return [Boolean]
    def parse_success?(*_arg0); end
  end
end

# Represents the use of the `alias` keyword to alias a global variable.
#
#     alias $foo $bar
#     ^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:90
class Prism::AliasGlobalVariableNode < ::Prism::Node
  # def initialize: (Node new_name, Node old_name, Location keyword_loc, Location location) -> void
  #
  # @return [AliasGlobalVariableNode] a new instance of AliasGlobalVariableNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:101
  def initialize(new_name, old_name, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:110
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:115
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:125
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:120
  def compact_child_nodes; end

  # def copy: (**params) -> AliasGlobalVariableNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:130
  sig { params(params: T.untyped).returns(Prism::AliasGlobalVariableNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:115
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { new_name: Node, old_name: Node, keyword_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:143
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:153
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:148
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:98
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader new_name: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:92
  sig { returns(Prism::Node) }
  def new_name; end

  # attr_reader old_name: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:95
  sig { returns(Prism::Node) }
  def old_name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:177
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:187
    def type; end
  end
end

# Represents the use of the `alias` keyword to alias a method.
#
#     alias foo bar
#     ^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:196
class Prism::AliasMethodNode < ::Prism::Node
  # def initialize: (Node new_name, Node old_name, Location keyword_loc, Location location) -> void
  #
  # @return [AliasMethodNode] a new instance of AliasMethodNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:207
  def initialize(new_name, old_name, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:216
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:221
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:231
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:226
  def compact_child_nodes; end

  # def copy: (**params) -> AliasMethodNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:236
  sig { params(params: T.untyped).returns(Prism::AliasMethodNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:221
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { new_name: Node, old_name: Node, keyword_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:249
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:259
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:254
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:204
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader new_name: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:198
  sig { returns(Prism::Node) }
  def new_name; end

  # attr_reader old_name: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:201
  sig { returns(Prism::Node) }
  def old_name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:283
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:293
    def type; end
  end
end

# Represents an alternation pattern in pattern matching.
#
#     foo => bar | baz
#            ^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:302
class Prism::AlternationPatternNode < ::Prism::Node
  # def initialize: (Node left, Node right, Location operator_loc, Location location) -> void
  #
  # @return [AlternationPatternNode] a new instance of AlternationPatternNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:313
  def initialize(left, right, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:322
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:327
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:337
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:332
  def compact_child_nodes; end

  # def copy: (**params) -> AlternationPatternNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:342
  sig { params(params: T.untyped).returns(Prism::AlternationPatternNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:327
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { left: Node, right: Node, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:355
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:365
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:304
  sig { returns(Prism::Node) }
  def left; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:360
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:310
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader right: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:307
  sig { returns(Prism::Node) }
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:389
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:399
    def type; end
  end
end

# Represents the use of the `&&` operator or the `and` keyword.
#
#     left and right
#     ^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:408
class Prism::AndNode < ::Prism::Node
  # def initialize: (Node left, Node right, Location operator_loc, Location location) -> void
  #
  # @return [AndNode] a new instance of AndNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:434
  def initialize(left, right, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:443
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:448
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:458
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:453
  def compact_child_nodes; end

  # def copy: (**params) -> AndNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:463
  sig { params(params: T.untyped).returns(Prism::AndNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:448
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { left: Node, right: Node, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:476
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:486
  def inspect(inspector = T.unsafe(nil)); end

  # Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     left and right
  #     ^^^^
  #
  #     1 && 2
  #     ^
  #
  # source://prism-0.23.0/lib/prism/node.rb:416
  sig { returns(Prism::Node) }
  def left; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:481
  sig { returns(String) }
  def operator; end

  # The location of the `and` keyword or the `&&` operator.
  #
  #     left and right
  #          ^^^
  #
  # source://prism-0.23.0/lib/prism/node.rb:431
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Represents the right side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     left && right
  #             ^^^^^
  #
  #     1 and 2
  #           ^
  #
  # source://prism-0.23.0/lib/prism/node.rb:425
  sig { returns(Prism::Node) }
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:510
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:520
    def type; end
  end
end

# Represents a set of arguments to a method or a keyword.
#
#     return foo, bar, baz
#            ^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:529
class Prism::ArgumentsNode < ::Prism::Node
  # def initialize: (Integer flags, Array[Node] arguments, Location location) -> void
  #
  # @return [ArgumentsNode] a new instance of ArgumentsNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:538
  def initialize(flags, arguments, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:546
  def accept(visitor); end

  # attr_reader arguments: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:535
  sig { returns(T::Array[Prism::Node]) }
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:551
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:561
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:556
  def compact_child_nodes; end

  # def contains_keyword_splat?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:583
  sig { returns(T::Boolean) }
  def contains_keyword_splat?; end

  # def copy: (**params) -> ArgumentsNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:566
  sig { params(params: T.untyped).returns(Prism::ArgumentsNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:551
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, arguments: Array[Node], location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:578
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:588
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:610
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:531
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:620
    def type; end
  end
end

# Flags for arguments nodes.
#
# source://prism-0.23.0/lib/prism/node.rb:17731
module Prism::ArgumentsNodeFlags; end

# if arguments contain keyword splat
#
# source://prism-0.23.0/lib/prism/node.rb:17733
Prism::ArgumentsNodeFlags::CONTAINS_KEYWORD_SPLAT = T.let(T.unsafe(nil), Integer)

# Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.
#
#     [1, 2, 3]
#     ^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:629
class Prism::ArrayNode < ::Prism::Node
  # def initialize: (Integer flags, Array[Node] elements, Location? opening_loc, Location? closing_loc, Location location) -> void
  #
  # @return [ArrayNode] a new instance of ArrayNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:644
  def initialize(flags, elements, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:654
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:659
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:703
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:641
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:669
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:664
  def compact_child_nodes; end

  # def contains_splat?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:693
  sig { returns(T::Boolean) }
  def contains_splat?; end

  # def copy: (**params) -> ArrayNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:674
  sig { params(params: T.untyped).returns(Prism::ArrayNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:659
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, elements: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:688
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:635
  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:708
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:698
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:638
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:732
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:631
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:742
    def type; end
  end
end

# Flags for array nodes.
#
# source://prism-0.23.0/lib/prism/node.rb:17737
module Prism::ArrayNodeFlags; end

# if array contains splat nodes
#
# source://prism-0.23.0/lib/prism/node.rb:17739
Prism::ArrayNodeFlags::CONTAINS_SPLAT = T.let(T.unsafe(nil), Integer)

# Represents an array pattern in pattern matching.
#
#     foo in 1, 2
#     ^^^^^^^^^^^
#
#     foo in [1, 2]
#     ^^^^^^^^^^^^^
#
#     foo in *1
#     ^^^^^^^^^
#
#     foo in Bar[]
#     ^^^^^^^^^^^^
#
#     foo in Bar[1, 2, 3]
#     ^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:763
class Prism::ArrayPatternNode < ::Prism::Node
  # def initialize: (Node? constant, Array[Node] requireds, Node? rest, Array[Node] posts, Location? opening_loc, Location? closing_loc, Location location) -> void
  #
  # @return [ArrayPatternNode] a new instance of ArrayPatternNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:783
  def initialize(constant, requireds, rest, posts, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:795
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:800
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:846
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:780
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:815
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:805
  def compact_child_nodes; end

  # attr_reader constant: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:765
  sig { returns(T.nilable(Prism::Node)) }
  def constant; end

  # def copy: (**params) -> ArrayPatternNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:820
  sig { params(params: T.untyped).returns(Prism::ArrayPatternNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:800
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { constant: Node?, requireds: Array[Node], rest: Node?, posts: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:836
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:851
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:841
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:777
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader posts: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:774
  sig { returns(T::Array[Prism::Node]) }
  def posts; end

  # attr_reader requireds: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:768
  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  # attr_reader rest: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:771
  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:886
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:896
    def type; end
  end
end

# Represents a hash key/value pair.
#
#     { a => b }
#       ^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:905
class Prism::AssocNode < ::Prism::Node
  # def initialize: (Node key, Node value, Location? operator_loc, Location location) -> void
  #
  # @return [AssocNode] a new instance of AssocNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:934
  def initialize(key, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:943
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:948
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:958
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:953
  def compact_child_nodes; end

  # def copy: (**params) -> AssocNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:963
  sig { params(params: T.untyped).returns(Prism::AssocNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:948
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { key: Node, value: Node, operator_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:976
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:986
  def inspect(inspector = T.unsafe(nil)); end

  # The key of the association. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     { a: b }
  #       ^
  #
  #     { foo => bar }
  #       ^^^
  #
  #     { def a; end => 1 }
  #       ^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/node.rb:916
  sig { returns(Prism::Node) }
  def key; end

  # def operator: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:981
  sig { returns(T.nilable(String)) }
  def operator; end

  # The location of the `=>` operator, if present.
  #
  #     { foo => bar }
  #           ^^
  #
  # source://prism-0.23.0/lib/prism/node.rb:931
  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:1010
  def type; end

  # The value of the association, if present. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     { foo => bar }
  #              ^^^
  #
  #     { x: 1 }
  #          ^
  #
  # source://prism-0.23.0/lib/prism/node.rb:925
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:1020
    def type; end
  end
end

# Represents a splat in a hash literal.
#
#     { **foo }
#       ^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:1029
class Prism::AssocSplatNode < ::Prism::Node
  # def initialize: (Node? value, Location operator_loc, Location location) -> void
  #
  # @return [AssocSplatNode] a new instance of AssocSplatNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1043
  def initialize(value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:1051
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1056
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1068
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1061
  def compact_child_nodes; end

  # def copy: (**params) -> AssocSplatNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1073
  sig { params(params: T.untyped).returns(Prism::AssocSplatNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1056
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { value: Node?, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:1085
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1095
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1090
  sig { returns(String) }
  def operator; end

  # The location of the `**` operator.
  #
  #     { **x }
  #       ^^
  #
  # source://prism-0.23.0/lib/prism/node.rb:1040
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:1121
  def type; end

  # The value to be splatted, if present. Will be missing when keyword rest argument forwarding is used.
  #
  #     { **foo }
  #         ^^^
  #
  # source://prism-0.23.0/lib/prism/node.rb:1034
  sig { returns(T.nilable(Prism::Node)) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:1131
    def type; end
  end
end

Prism::BACKEND = T.let(T.unsafe(nil), Symbol)

# Represents reading a reference to a field in the previous match.
#
#     $'
#     ^^
#
# source://prism-0.23.0/lib/prism/node.rb:1140
class Prism::BackReferenceReadNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [BackReferenceReadNode] a new instance of BackReferenceReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1149
  def initialize(name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:1156
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1161
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1171
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1166
  def compact_child_nodes; end

  # def copy: (**params) -> BackReferenceReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1176
  sig { params(params: T.untyped).returns(Prism::BackReferenceReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1161
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:1187
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1192
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the back-reference variable, including the leading `$`.
  #
  #     $& # name `:$&`
  #
  #     $+ # name `:$+`
  #
  # source://prism-0.23.0/lib/prism/node.rb:1146
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:1212
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:1222
    def type; end
  end
end

# A class that knows how to walk down the tree. None of the individual visit
# methods are implemented on this visitor, so it forces the consumer to
# implement each one that they need. For a default implementation that
# continues walking the tree, see the Visitor class.
#
# source://prism-0.23.0/lib/prism/visitor.rb:13
class Prism::BasicVisitor
  # Calls `accept` on the given node if it is not `nil`, which in turn should
  # call back into this visitor by calling the appropriate `visit_*` method.
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:16
  def visit(node); end

  # Visits each node in `nodes` by calling `accept` on each one.
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:21
  def visit_all(nodes); end

  # Visits the child nodes of `node` by calling `accept` on each one.
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_child_nodes(node); end
end

# Represents a begin statement.
#
#     begin
#       foo
#     end
#     ^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:1233
class Prism::BeginNode < ::Prism::Node
  # def initialize: (Location? begin_keyword_loc, StatementsNode? statements, RescueNode? rescue_clause, ElseNode? else_clause, EnsureNode? ensure_clause, Location? end_keyword_loc, Location location) -> void
  #
  # @return [BeginNode] a new instance of BeginNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1253
  def initialize(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:1265
  def accept(visitor); end

  # def begin_keyword: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1315
  sig { returns(T.nilable(String)) }
  def begin_keyword; end

  # attr_reader begin_keyword_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1235
  sig { returns(T.nilable(Prism::Location)) }
  def begin_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1274
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1289
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1279
  def compact_child_nodes; end

  # def copy: (**params) -> BeginNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1294
  sig { params(params: T.untyped).returns(Prism::BeginNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1274
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { begin_keyword_loc: Location?, statements: StatementsNode?, rescue_clause: RescueNode?, else_clause: ElseNode?, ensure_clause: EnsureNode?, end_keyword_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:1310
  def deconstruct_keys(keys); end

  # attr_reader else_clause: ElseNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1244
  sig { returns(T.nilable(Prism::ElseNode)) }
  def else_clause; end

  # def end_keyword: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1320
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1250
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  # attr_reader ensure_clause: EnsureNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1247
  sig { returns(T.nilable(Prism::EnsureNode)) }
  def ensure_clause; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1325
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader rescue_clause: RescueNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1241
  sig { returns(T.nilable(Prism::RescueNode)) }
  def rescue_clause; end

  # source://prism-0.23.0/lib/prism/node.rb:1269
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1238
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:1370
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:1380
    def type; end
  end
end

# Represents block method arguments.
#
#     bar(&args)
#     ^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:1389
class Prism::BlockArgumentNode < ::Prism::Node
  # def initialize: (Node? expression, Location operator_loc, Location location) -> void
  #
  # @return [BlockArgumentNode] a new instance of BlockArgumentNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1397
  def initialize(expression, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:1405
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1410
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1422
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1415
  def compact_child_nodes; end

  # def copy: (**params) -> BlockArgumentNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1427
  sig { params(params: T.untyped).returns(Prism::BlockArgumentNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1410
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { expression: Node?, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:1439
  def deconstruct_keys(keys); end

  # attr_reader expression: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1391
  sig { returns(T.nilable(Prism::Node)) }
  def expression; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1449
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1444
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:1394
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:1475
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:1485
    def type; end
  end
end

# Represents a block local variable.
#
#     a { |; b| }
#            ^
#
# source://prism-0.23.0/lib/prism/node.rb:1494
class Prism::BlockLocalVariableNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol name, Location location) -> void
  #
  # @return [BlockLocalVariableNode] a new instance of BlockLocalVariableNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1503
  def initialize(flags, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:1511
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1516
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1526
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1521
  def compact_child_nodes; end

  # def copy: (**params) -> BlockLocalVariableNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1531
  sig { params(params: T.untyped).returns(Prism::BlockLocalVariableNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1516
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:1543
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1553
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:1500
  sig { returns(Symbol) }
  def name; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1548
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:1575
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:1496
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:1585
    def type; end
  end
end

# Represents a block of ruby code.
#
#     [1, 2, 3].each { |i| puts x }
#                    ^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:1594
class Prism::BlockNode < ::Prism::Node
  # def initialize: (Array[Symbol] locals, Node? parameters, Node? body, Location opening_loc, Location closing_loc, Location location) -> void
  #
  # @return [BlockNode] a new instance of BlockNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1611
  def initialize(locals, parameters, body, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:1622
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1602
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1627
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1670
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:1608
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1640
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1632
  def compact_child_nodes; end

  # def copy: (**params) -> BlockNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1645
  sig { params(params: T.untyped).returns(Prism::BlockNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1627
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { locals: Array[Symbol], parameters: Node?, body: Node?, opening_loc: Location, closing_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:1660
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1675
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1596
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1665
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:1605
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader parameters: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1599
  sig { returns(T.nilable(Prism::Node)) }
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:1709
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:1719
    def type; end
  end
end

# Represents a block parameter to a method, block, or lambda definition.
#
#     def a(&b)
#           ^^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:1729
class Prism::BlockParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol? name, Location? name_loc, Location operator_loc, Location location) -> void
  #
  # @return [BlockParameterNode] a new instance of BlockParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1744
  def initialize(flags, name, name_loc, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:1754
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1759
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1769
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1764
  def compact_child_nodes; end

  # def copy: (**params) -> BlockParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1774
  sig { params(params: T.untyped).returns(Prism::BlockParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1759
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:1788
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1803
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1735
  sig { returns(T.nilable(Symbol)) }
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1738
  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1798
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:1741
  sig { returns(Prism::Location) }
  def operator_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1793
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:1831
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:1731
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:1841
    def type; end
  end
end

# Represents a block's parameters declaration.
#
#     -> (a, b = 1; local) { }
#        ^^^^^^^^^^^^^^^^^
#
#     foo do |a, b = 1; local|
#            ^^^^^^^^^^^^^^^^^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:1854
class Prism::BlockParametersNode < ::Prism::Node
  # def initialize: (ParametersNode? parameters, Array[Node] locals, Location? opening_loc, Location? closing_loc, Location location) -> void
  #
  # @return [BlockParametersNode] a new instance of BlockParametersNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1868
  def initialize(parameters, locals, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:1878
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1883
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1925
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1865
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1896
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1888
  def compact_child_nodes; end

  # def copy: (**params) -> BlockParametersNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1901
  sig { params(params: T.untyped).returns(Prism::BlockParametersNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1883
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { parameters: ParametersNode?, locals: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:1915
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:1930
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1859
  sig { returns(T::Array[Prism::Node]) }
  def locals; end

  # def opening: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1920
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1862
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader parameters: ParametersNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1856
  sig { returns(T.nilable(Prism::ParametersNode)) }
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:1958
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:1968
    def type; end
  end
end

# Represents the use of the `break` keyword.
#
#     break foo
#     ^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:1977
class Prism::BreakNode < ::Prism::Node
  # def initialize: (ArgumentsNode? arguments, Location keyword_loc, Location location) -> void
  #
  # @return [BreakNode] a new instance of BreakNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:1985
  def initialize(arguments, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:1993
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:1979
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1998
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2010
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2003
  def compact_child_nodes; end

  # def copy: (**params) -> BreakNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:2015
  sig { params(params: T.untyped).returns(Prism::BreakNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:1998
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { arguments: ArgumentsNode?, keyword_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:2027
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:2037
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:2032
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:1982
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2063
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:2073
    def type; end
  end
end

# Represents the use of the `&&=` operator on a call.
#
#     foo.bar &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:2082
class Prism::CallAndWriteNode < ::Prism::Node
  # def initialize: (Integer flags, Node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Location operator_loc, Node value, Location location) -> void
  #
  # @return [CallAndWriteNode] a new instance of CallAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:2109
  def initialize(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:2123
  def accept(visitor); end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2179
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # def call_operator: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2189
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2091
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2128
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2141
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2133
  def compact_child_nodes; end

  # def copy: (**params) -> CallAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:2146
  sig { params(params: T.untyped).returns(Prism::CallAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2128
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Node?, call_operator_loc: Location?, message_loc: Location?, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:2164
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2184
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:2204
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2194
  sig { returns(T.nilable(String)) }
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2094
  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:2199
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:2103
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader read_name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2097
  sig { returns(Symbol) }
  def read_name; end

  # attr_reader receiver: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2088
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2169
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2238
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:2106
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2174
  sig { returns(T::Boolean) }
  def variable_call?; end

  # attr_reader write_name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2100
  sig { returns(Symbol) }
  def write_name; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:2084
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:2248
    def type; end
  end
end

# Represents a method call, in all of the various forms that can take.
#
#     foo
#     ^^^
#
#     foo()
#     ^^^^^
#
#     +foo
#     ^^^^
#
#     foo + bar
#     ^^^^^^^^^
#
#     foo.bar
#     ^^^^^^^
#
#     foo&.bar
#     ^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:2272
class Prism::CallNode < ::Prism::Node
  # def initialize: (Integer flags, Node? receiver, Location? call_operator_loc, Symbol name, Location? message_loc, Location? opening_loc, ArgumentsNode? arguments, Location? closing_loc, Node? block, Location location) -> void
  #
  # @return [CallNode] a new instance of CallNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:2311
  def initialize(flags, receiver, call_operator_loc, name, message_loc, opening_loc, arguments, closing_loc, block, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:2326
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2302
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2384
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # attr_reader block: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2308
  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2394
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2290
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2331
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2409
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2305
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2345
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2336
  def compact_child_nodes; end

  # def copy: (**params) -> CallNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:2350
  sig { params(params: T.untyped).returns(Prism::CallNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2331
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Node?, call_operator_loc: Location?, name: Symbol, message_loc: Location?, opening_loc: Location?, arguments: ArgumentsNode?, closing_loc: Location?, block: Node?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:2369
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2389
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:2414
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2399
  sig { returns(T.nilable(String)) }
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2296
  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2293
  sig { returns(Symbol) }
  def name; end

  # def opening: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2404
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2299
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # The object that the method is being called on. This can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     foo.bar
  #     ^^^
  #
  #     +foo
  #      ^^^
  #
  #     foo + bar
  #     ^^^
  #
  # source://prism-0.23.0/lib/prism/node.rb:2287
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2374
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2458
  def type; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2379
  sig { returns(T::Boolean) }
  def variable_call?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:2274
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:2468
    def type; end
  end
end

# Flags for call nodes.
#
# source://prism-0.23.0/lib/prism/node.rb:17743
module Prism::CallNodeFlags; end

# a call that is an attribute write, so the value being written should be returned
#
# source://prism-0.23.0/lib/prism/node.rb:17751
Prism::CallNodeFlags::ATTRIBUTE_WRITE = T.let(T.unsafe(nil), Integer)

# a call that ignores method visibility
#
# source://prism-0.23.0/lib/prism/node.rb:17754
Prism::CallNodeFlags::IGNORE_VISIBILITY = T.let(T.unsafe(nil), Integer)

# &. operator
#
# source://prism-0.23.0/lib/prism/node.rb:17745
Prism::CallNodeFlags::SAFE_NAVIGATION = T.let(T.unsafe(nil), Integer)

# a call that could have been a local variable
#
# source://prism-0.23.0/lib/prism/node.rb:17748
Prism::CallNodeFlags::VARIABLE_CALL = T.let(T.unsafe(nil), Integer)

# Represents the use of an assignment operator on a call.
#
#     foo.bar += baz
#     ^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:2477
class Prism::CallOperatorWriteNode < ::Prism::Node
  # def initialize: (Integer flags, Node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Symbol operator, Location operator_loc, Node value, Location location) -> void
  #
  # @return [CallOperatorWriteNode] a new instance of CallOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:2507
  def initialize(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:2522
  def accept(visitor); end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2579
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # def call_operator: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2589
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2486
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2527
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2540
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2532
  def compact_child_nodes; end

  # def copy: (**params) -> CallOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:2545
  sig { params(params: T.untyped).returns(Prism::CallOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2527
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Node?, call_operator_loc: Location?, message_loc: Location?, read_name: Symbol, write_name: Symbol, operator: Symbol, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:2564
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2584
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:2599
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2594
  sig { returns(T.nilable(String)) }
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2489
  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2498
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:2501
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader read_name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2492
  sig { returns(Symbol) }
  def read_name; end

  # attr_reader receiver: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2483
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2569
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2634
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:2504
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2574
  sig { returns(T::Boolean) }
  def variable_call?; end

  # attr_reader write_name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2495
  sig { returns(Symbol) }
  def write_name; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:2479
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:2644
    def type; end
  end
end

# Represents the use of the `||=` operator on a call.
#
#     foo.bar ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:2653
class Prism::CallOrWriteNode < ::Prism::Node
  # def initialize: (Integer flags, Node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Location operator_loc, Node value, Location location) -> void
  #
  # @return [CallOrWriteNode] a new instance of CallOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:2680
  def initialize(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:2694
  def accept(visitor); end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2750
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # def call_operator: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2760
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2662
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2699
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2712
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2704
  def compact_child_nodes; end

  # def copy: (**params) -> CallOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:2717
  sig { params(params: T.untyped).returns(Prism::CallOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2699
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Node?, call_operator_loc: Location?, message_loc: Location?, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:2735
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2755
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:2775
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2765
  sig { returns(T.nilable(String)) }
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2665
  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:2770
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:2674
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader read_name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2668
  sig { returns(Symbol) }
  def read_name; end

  # attr_reader receiver: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:2659
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2740
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2809
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:2677
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2745
  sig { returns(T::Boolean) }
  def variable_call?; end

  # attr_reader write_name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2671
  sig { returns(Symbol) }
  def write_name; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:2655
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:2819
    def type; end
  end
end

# Represents assigning to a method call.
#
#     foo.bar, = 1
#     ^^^^^^^
#
#     begin
#     rescue => foo.bar
#               ^^^^^^^
#     end
#
#     for foo.bar in baz do end
#         ^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:2836
class Prism::CallTargetNode < ::Prism::Node
  # def initialize: (Integer flags, Node receiver, Location call_operator_loc, Symbol name, Location message_loc, Location location) -> void
  #
  # @return [CallTargetNode] a new instance of CallTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:2854
  def initialize(flags, receiver, call_operator_loc, name, message_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:2865
  def accept(visitor); end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2915
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # def call_operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:2925
  sig { returns(String) }
  def call_operator; end

  # attr_reader call_operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:2845
  sig { returns(Prism::Location) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2870
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2880
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2875
  def compact_child_nodes; end

  # def copy: (**params) -> CallTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:2885
  sig { params(params: T.untyped).returns(Prism::CallTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2870
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Node, call_operator_loc: Location, name: Symbol, message_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:2900
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2920
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:2935
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:2930
  sig { returns(String) }
  def message; end

  # attr_reader message_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:2851
  sig { returns(Prism::Location) }
  def message_loc; end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2848
  sig { returns(Symbol) }
  def name; end

  # attr_reader receiver: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:2842
  sig { returns(Prism::Node) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2905
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:2961
  def type; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:2910
  sig { returns(T::Boolean) }
  def variable_call?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:2838
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:2971
    def type; end
  end
end

# Represents assigning to a local variable in pattern matching.
#
#     foo => [bar => baz]
#            ^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:2980
class Prism::CapturePatternNode < ::Prism::Node
  # def initialize: (Node value, Node target, Location operator_loc, Location location) -> void
  #
  # @return [CapturePatternNode] a new instance of CapturePatternNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:2991
  def initialize(value, target, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:3000
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3005
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3015
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3010
  def compact_child_nodes; end

  # def copy: (**params) -> CapturePatternNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3020
  sig { params(params: T.untyped).returns(Prism::CapturePatternNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3005
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { value: Node, target: Node, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:3033
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3043
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3038
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:2988
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader target: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:2985
  sig { returns(Prism::Node) }
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3067
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:2982
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:3077
    def type; end
  end
end

# Represents the use of a case statement for pattern matching.
#
#     case true
#     in false
#     end
#     ^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:3088
class Prism::CaseMatchNode < ::Prism::Node
  # def initialize: (Node? predicate, Array[Node] conditions, ElseNode? consequent, Location case_keyword_loc, Location end_keyword_loc, Location location) -> void
  #
  # @return [CaseMatchNode] a new instance of CaseMatchNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3105
  def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:3116
  def accept(visitor); end

  # def case_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3160
  sig { returns(String) }
  def case_keyword; end

  # attr_reader case_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:3099
  sig { returns(Prism::Location) }
  def case_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3121
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3135
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3126
  def compact_child_nodes; end

  # attr_reader conditions: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3093
  sig { returns(T::Array[Prism::Node]) }
  def conditions; end

  # attr_reader consequent: ElseNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:3096
  sig { returns(T.nilable(Prism::ElseNode)) }
  def consequent; end

  # def copy: (**params) -> CaseMatchNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3140
  sig { params(params: T.untyped).returns(Prism::CaseMatchNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3121
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { predicate: Node?, conditions: Array[Node], consequent: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:3155
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3165
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:3102
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3170
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader predicate: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:3090
  sig { returns(T.nilable(Prism::Node)) }
  def predicate; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3204
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:3214
    def type; end
  end
end

# Represents the use of a case statement.
#
#     case true
#     when false
#     end
#     ^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:3225
class Prism::CaseNode < ::Prism::Node
  # def initialize: (Node? predicate, Array[Node] conditions, ElseNode? consequent, Location case_keyword_loc, Location end_keyword_loc, Location location) -> void
  #
  # @return [CaseNode] a new instance of CaseNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3242
  def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:3253
  def accept(visitor); end

  # def case_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3297
  sig { returns(String) }
  def case_keyword; end

  # attr_reader case_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:3236
  sig { returns(Prism::Location) }
  def case_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3258
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3272
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3263
  def compact_child_nodes; end

  # attr_reader conditions: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3230
  sig { returns(T::Array[Prism::Node]) }
  def conditions; end

  # attr_reader consequent: ElseNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:3233
  sig { returns(T.nilable(Prism::ElseNode)) }
  def consequent; end

  # def copy: (**params) -> CaseNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3277
  sig { params(params: T.untyped).returns(Prism::CaseNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3258
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { predicate: Node?, conditions: Array[Node], consequent: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:3292
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3302
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:3239
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3307
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader predicate: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:3227
  sig { returns(T.nilable(Prism::Node)) }
  def predicate; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3341
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:3351
    def type; end
  end
end

# Represents a class declaration involving the `class` keyword.
#
#     class Foo end
#     ^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:3360
class Prism::ClassNode < ::Prism::Node
  # def initialize: (Array[Symbol] locals, Location class_keyword_loc, Node constant_path, Location? inheritance_operator_loc, Node? superclass, Node? body, Location end_keyword_loc, Symbol name, Location location) -> void
  #
  # @return [ClassNode] a new instance of ClassNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3386
  def initialize(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:3400
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:3377
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3405
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def class_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3447
  sig { returns(String) }
  def class_keyword; end

  # attr_reader class_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:3365
  sig { returns(Prism::Location) }
  def class_keyword_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3419
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3410
  def compact_child_nodes; end

  # attr_reader constant_path: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:3368
  sig { returns(Prism::Node) }
  def constant_path; end

  # def copy: (**params) -> ClassNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3424
  sig { params(params: T.untyped).returns(Prism::ClassNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3405
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { locals: Array[Symbol], class_keyword_loc: Location, constant_path: Node, inheritance_operator_loc: Location?, superclass: Node?, body: Node?, end_keyword_loc: Location, name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:3442
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3457
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:3380
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def inheritance_operator: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:3452
  sig { returns(T.nilable(String)) }
  def inheritance_operator; end

  # attr_reader inheritance_operator_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:3371
  sig { returns(T.nilable(Prism::Location)) }
  def inheritance_operator_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3462
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3362
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3383
  sig { returns(Symbol) }
  def name; end

  # attr_reader superclass: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:3374
  sig { returns(T.nilable(Prism::Node)) }
  def superclass; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3500
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:3510
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a class variable.
#
#     @@target &&= value
#     ^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:3519
class Prism::ClassVariableAndWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Node value, Location location) -> void
  #
  # @return [ClassVariableAndWriteNode] a new instance of ClassVariableAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3533
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:3543
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3548
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3558
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3553
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3563
  sig { params(params: T.untyped).returns(Prism::ClassVariableAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3548
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:3577
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3587
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3521
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:3524
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3582
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:3527
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3611
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:3530
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:3621
    def type; end
  end
end

# Represents assigning to a class variable using an operator that isn't `=`.
#
#     @@target += value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:3630
class Prism::ClassVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Node value, Symbol operator, Location location) -> void
  #
  # @return [ClassVariableOperatorWriteNode] a new instance of ClassVariableOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3647
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:3658
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3663
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3673
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3668
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3678
  sig { params(params: T.untyped).returns(Prism::ClassVariableOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3663
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:3693
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3698
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3632
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:3635
  sig { returns(Prism::Location) }
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3644
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:3638
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3723
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:3641
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:3733
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a class variable.
#
#     @@target ||= value
#     ^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:3742
class Prism::ClassVariableOrWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Node value, Location location) -> void
  #
  # @return [ClassVariableOrWriteNode] a new instance of ClassVariableOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3756
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:3766
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3771
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3781
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3776
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3786
  sig { params(params: T.untyped).returns(Prism::ClassVariableOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3771
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:3800
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3810
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3744
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:3747
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3805
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:3750
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3834
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:3753
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:3844
    def type; end
  end
end

# Represents referencing a class variable.
#
#     @@foo
#     ^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:3853
class Prism::ClassVariableReadNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [ClassVariableReadNode] a new instance of ClassVariableReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3862
  def initialize(name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:3869
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3874
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3884
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3879
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3889
  sig { params(params: T.untyped).returns(Prism::ClassVariableReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3874
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:3900
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3905
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     @@abc   # name `:@@abc`
  #
  #     @@_test # name `:@@_test`
  #
  # source://prism-0.23.0/lib/prism/node.rb:3859
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3925
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:3935
    def type; end
  end
end

# Represents writing to a class variable in a context that doesn't have an explicit value.
#
#     @@foo, @@bar = baz
#     ^^^^^  ^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:3944
class Prism::ClassVariableTargetNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [ClassVariableTargetNode] a new instance of ClassVariableTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3949
  def initialize(name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:3956
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3961
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3971
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3966
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:3976
  sig { params(params: T.untyped).returns(Prism::ClassVariableTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:3961
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:3987
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:3992
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:3946
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4012
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:4022
    def type; end
  end
end

# Represents writing to a class variable.
#
#     @@foo = 1
#     ^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:4031
class Prism::ClassVariableWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Node value, Location? operator_loc, Location location) -> void
  #
  # @return [ClassVariableWriteNode] a new instance of ClassVariableWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4045
  def initialize(name, name_loc, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:4055
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4060
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4070
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4065
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4075
  sig { params(params: T.untyped).returns(Prism::ClassVariableWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4060
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, value: Node, operator_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:4089
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4099
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4033
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:4036
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:4094
  sig { returns(T.nilable(String)) }
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:4042
  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4123
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:4039
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:4133
    def type; end
  end
end

# This represents a comment that was encountered during parsing. It is the
# base class for all comment types.
#
# source://prism-0.23.0/lib/prism/parse_result.rb:258
class Prism::Comment
  # Create a new comment object with the given location.
  #
  # @return [Comment] a new instance of Comment
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:263
  def initialize(location); end

  # Implement the hash pattern matching interface for Comment.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:268
  def deconstruct_keys(keys); end

  # The location of this comment in the source.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:260
  sig { returns(Prism::Location) }
  def location; end

  sig { returns(T::Boolean) }
  def trailing?; end
end

# A compiler is a visitor that returns the value of each node as it visits.
# This is as opposed to a visitor which will only walk the tree. This can be
# useful when you are trying to compile a tree into a different format.
#
# For example, to build a representation of the tree as s-expressions, you
# could write:
#
#     class SExpressions < Prism::Compiler
#       def visit_arguments_node(node) = [:arguments, super]
#       def visit_call_node(node) = [:call, super]
#       def visit_integer_node(node) = [:integer]
#       def visit_program_node(node) = [:program, super]
#     end
#
#     Prism.parse("1 + 2").value.accept(SExpressions.new)
#     # => [:program, [[[:call, [[:integer], [:arguments, [[:integer]]]]]]]]
#
# source://prism-0.23.0/lib/prism/compiler.rb:26
class Prism::Compiler
  # Visit an individual node.
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:28
  def visit(node); end

  # Visit the child nodes of the given node.
  # Compile a AliasGlobalVariableNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_alias_global_variable_node(node); end

  # Visit the child nodes of the given node.
  # Compile a AliasMethodNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_alias_method_node(node); end

  # Visit a list of nodes.
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:33
  def visit_all(nodes); end

  # Visit the child nodes of the given node.
  # Compile a AlternationPatternNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_alternation_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a AndNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_and_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ArgumentsNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_arguments_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ArrayNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_array_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ArrayPatternNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_array_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a AssocNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_assoc_node(node); end

  # Visit the child nodes of the given node.
  # Compile a AssocSplatNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_assoc_splat_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BackReferenceReadNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_back_reference_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BeginNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_begin_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockArgumentNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_block_argument_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockLocalVariableNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_block_local_variable_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_block_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockParameterNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_block_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BlockParametersNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_block_parameters_node(node); end

  # Visit the child nodes of the given node.
  # Compile a BreakNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_break_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_call_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_call_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_call_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_call_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CallTargetNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_call_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CapturePatternNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_capture_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CaseMatchNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_case_match_node(node); end

  # Visit the child nodes of the given node.
  # Compile a CaseNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_case_node(node); end

  # Visit the child nodes of the given node.
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_child_nodes(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_class_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_class_variable_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_class_variable_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_class_variable_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_class_variable_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_class_variable_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ClassVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_class_variable_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_constant_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_constant_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_constant_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_constant_path_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_constant_path_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_constant_path_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_constant_path_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathTargetNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_constant_path_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantPathWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_constant_path_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantReadNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_constant_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantTargetNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_constant_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ConstantWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_constant_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a DefNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_def_node(node); end

  # Visit the child nodes of the given node.
  # Compile a DefinedNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_defined_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ElseNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_else_node(node); end

  # Visit the child nodes of the given node.
  # Compile a EmbeddedStatementsNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_embedded_statements_node(node); end

  # Visit the child nodes of the given node.
  # Compile a EmbeddedVariableNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_embedded_variable_node(node); end

  # Visit the child nodes of the given node.
  # Compile a EnsureNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_ensure_node(node); end

  # Visit the child nodes of the given node.
  # Compile a FalseNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_false_node(node); end

  # Visit the child nodes of the given node.
  # Compile a FindPatternNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_find_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a FlipFlopNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_flip_flop_node(node); end

  # Visit the child nodes of the given node.
  # Compile a FloatNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_float_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ForNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_for_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ForwardingArgumentsNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_forwarding_arguments_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ForwardingParameterNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_forwarding_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ForwardingSuperNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_forwarding_super_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_global_variable_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_global_variable_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_global_variable_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_global_variable_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_global_variable_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a GlobalVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_global_variable_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a HashNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_hash_node(node); end

  # Visit the child nodes of the given node.
  # Compile a HashPatternNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_hash_pattern_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IfNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_if_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ImaginaryNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_imaginary_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ImplicitNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_implicit_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ImplicitRestNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_implicit_rest_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_in_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IndexAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_index_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IndexOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_index_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IndexOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_index_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IndexTargetNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_index_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_instance_variable_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_instance_variable_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_instance_variable_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_instance_variable_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_instance_variable_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InstanceVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_instance_variable_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a IntegerNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_integer_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedMatchLastLineNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_interpolated_match_last_line_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedRegularExpressionNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_interpolated_regular_expression_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedStringNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_interpolated_string_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedSymbolNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_interpolated_symbol_node(node); end

  # Visit the child nodes of the given node.
  # Compile a InterpolatedXStringNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_interpolated_x_string_node(node); end

  # Visit the child nodes of the given node.
  # Compile a KeywordHashNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_keyword_hash_node(node); end

  # Visit the child nodes of the given node.
  # Compile a KeywordRestParameterNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_keyword_rest_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LambdaNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_lambda_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_local_variable_and_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_local_variable_operator_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_local_variable_or_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_local_variable_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_local_variable_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a LocalVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_local_variable_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MatchLastLineNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_match_last_line_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MatchPredicateNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_match_predicate_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MatchRequiredNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_match_required_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MatchWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_match_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MissingNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_missing_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ModuleNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_module_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MultiTargetNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_multi_target_node(node); end

  # Visit the child nodes of the given node.
  # Compile a MultiWriteNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_multi_write_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NextNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_next_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NilNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_nil_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NoKeywordsParameterNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_no_keywords_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NumberedParametersNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_numbered_parameters_node(node); end

  # Visit the child nodes of the given node.
  # Compile a NumberedReferenceReadNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_numbered_reference_read_node(node); end

  # Visit the child nodes of the given node.
  # Compile a OptionalKeywordParameterNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_optional_keyword_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a OptionalParameterNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_optional_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a OrNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_or_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ParametersNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_parameters_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ParenthesesNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_parentheses_node(node); end

  # Visit the child nodes of the given node.
  # Compile a PinnedExpressionNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_pinned_expression_node(node); end

  # Visit the child nodes of the given node.
  # Compile a PinnedVariableNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_pinned_variable_node(node); end

  # Visit the child nodes of the given node.
  # Compile a PostExecutionNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_post_execution_node(node); end

  # Visit the child nodes of the given node.
  # Compile a PreExecutionNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_pre_execution_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ProgramNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_program_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RangeNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_range_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RationalNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_rational_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RedoNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_redo_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RegularExpressionNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_regular_expression_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RequiredKeywordParameterNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_required_keyword_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RequiredParameterNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_required_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RescueModifierNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_rescue_modifier_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RescueNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_rescue_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RestParameterNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_rest_parameter_node(node); end

  # Visit the child nodes of the given node.
  # Compile a RetryNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_retry_node(node); end

  # Visit the child nodes of the given node.
  # Compile a ReturnNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_return_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SelfNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_self_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SingletonClassNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_singleton_class_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SourceEncodingNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_source_encoding_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SourceFileNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_source_file_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SourceLineNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_source_line_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SplatNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_splat_node(node); end

  # Visit the child nodes of the given node.
  # Compile a StatementsNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_statements_node(node); end

  # Visit the child nodes of the given node.
  # Compile a StringNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_string_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SuperNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_super_node(node); end

  # Visit the child nodes of the given node.
  # Compile a SymbolNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_symbol_node(node); end

  # Visit the child nodes of the given node.
  # Compile a TrueNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_true_node(node); end

  # Visit the child nodes of the given node.
  # Compile a UndefNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_undef_node(node); end

  # Visit the child nodes of the given node.
  # Compile a UnlessNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_unless_node(node); end

  # Visit the child nodes of the given node.
  # Compile a UntilNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_until_node(node); end

  # Visit the child nodes of the given node.
  # Compile a WhenNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_when_node(node); end

  # Visit the child nodes of the given node.
  # Compile a WhileNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_while_node(node); end

  # Visit the child nodes of the given node.
  # Compile a XStringNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_x_string_node(node); end

  # Visit the child nodes of the given node.
  # Compile a YieldNode node
  #
  # source://prism-0.23.0/lib/prism/compiler.rb:38
  def visit_yield_node(node); end
end

# Represents the use of the `&&=` operator for assignment to a constant.
#
#     Target &&= value
#     ^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:4142
class Prism::ConstantAndWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Node value, Location location) -> void
  #
  # @return [ConstantAndWriteNode] a new instance of ConstantAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4156
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:4166
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4171
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4181
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4176
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4186
  sig { params(params: T.untyped).returns(Prism::ConstantAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4171
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:4200
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4210
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4144
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:4147
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4205
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:4150
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4234
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:4153
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:4244
    def type; end
  end
end

# Represents assigning to a constant using an operator that isn't `=`.
#
#     Target += value
#     ^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:4253
class Prism::ConstantOperatorWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Node value, Symbol operator, Location location) -> void
  #
  # @return [ConstantOperatorWriteNode] a new instance of ConstantOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4270
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:4281
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4286
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4296
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4291
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4301
  sig { params(params: T.untyped).returns(Prism::ConstantOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4286
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:4316
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4321
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4255
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:4258
  sig { returns(Prism::Location) }
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4267
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:4261
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4346
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:4264
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:4356
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a constant.
#
#     Target ||= value
#     ^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:4365
class Prism::ConstantOrWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Node value, Location location) -> void
  #
  # @return [ConstantOrWriteNode] a new instance of ConstantOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4379
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:4389
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4394
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4404
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4399
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4409
  sig { params(params: T.untyped).returns(Prism::ConstantOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4394
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:4423
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4433
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4367
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:4370
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4428
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:4373
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4457
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:4376
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:4467
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a constant path.
#
#     Parent::Child &&= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:4476
class Prism::ConstantPathAndWriteNode < ::Prism::Node
  # def initialize: (ConstantPathNode target, Location operator_loc, Node value, Location location) -> void
  #
  # @return [ConstantPathAndWriteNode] a new instance of ConstantPathAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4487
  def initialize(target, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:4496
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4501
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4511
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4506
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4516
  sig { params(params: T.untyped).returns(Prism::ConstantPathAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4501
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { target: ConstantPathNode, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:4529
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4539
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4534
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:4481
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4478
  sig { returns(Prism::ConstantPathNode) }
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4563
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:4484
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:4573
    def type; end
  end
end

# Represents accessing a constant through a path of `::` operators.
#
#     Foo::Bar
#     ^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:4582
class Prism::ConstantPathNode < ::Prism::Node
  # def initialize: (Node? parent, Node child, Location delimiter_loc, Location location) -> void
  #
  # @return [ConstantPathNode] a new instance of ConstantPathNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4593
  def initialize(parent, child, delimiter_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:4602
  def accept(visitor); end

  # attr_reader child: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:4587
  sig { returns(Prism::Node) }
  def child; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4607
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4620
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4612
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4625
  sig { params(params: T.untyped).returns(Prism::ConstantPathNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4607
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { parent: Node?, child: Node, delimiter_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:4638
  def deconstruct_keys(keys); end

  # def delimiter: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4643
  sig { returns(String) }
  def delimiter; end

  # attr_reader delimiter_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:4590
  sig { returns(Prism::Location) }
  def delimiter_loc; end

  # Returns the full name of this constant path. For example: "Foo::Bar"
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:129
  def full_name; end

  # Returns the list of parts for the full name of this constant path.
  # For example: [:Foo, :Bar]
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:112
  def full_name_parts; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4648
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader parent: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:4584
  sig { returns(T.nilable(Prism::Node)) }
  def parent; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4676
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:4686
    def type; end
  end
end

# An error class raised when dynamic parts are found while computing a
# constant path's full name. For example:
# Foo::Bar::Baz -> does not raise because all parts of the constant path are
# simple constants
# var::Bar::Baz -> raises because the first part of the constant path is a
# local variable
#
# source://prism-0.23.0/lib/prism/node_ext.rb:108
class Prism::ConstantPathNode::DynamicPartsInConstantPathError < ::StandardError; end

# Represents assigning to a constant path using an operator that isn't `=`.
#
#     Parent::Child += value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:4695
class Prism::ConstantPathOperatorWriteNode < ::Prism::Node
  # def initialize: (ConstantPathNode target, Location operator_loc, Node value, Symbol operator, Location location) -> void
  #
  # @return [ConstantPathOperatorWriteNode] a new instance of ConstantPathOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4709
  def initialize(target, operator_loc, value, operator, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:4719
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4724
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4734
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4729
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4739
  sig { params(params: T.untyped).returns(Prism::ConstantPathOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4724
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { target: ConstantPathNode, operator_loc: Location, value: Node, operator: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:4753
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4758
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader operator: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4706
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:4700
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4697
  sig { returns(Prism::ConstantPathNode) }
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4783
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:4703
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:4793
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a constant path.
#
#     Parent::Child ||= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:4802
class Prism::ConstantPathOrWriteNode < ::Prism::Node
  # def initialize: (ConstantPathNode target, Location operator_loc, Node value, Location location) -> void
  #
  # @return [ConstantPathOrWriteNode] a new instance of ConstantPathOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4813
  def initialize(target, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:4822
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4827
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4837
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4832
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4842
  sig { params(params: T.untyped).returns(Prism::ConstantPathOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4827
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { target: ConstantPathNode, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:4855
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4865
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4860
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:4807
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4804
  sig { returns(Prism::ConstantPathNode) }
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:4889
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:4810
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:4899
    def type; end
  end
end

# Represents writing to a constant path in a context that doesn't have an explicit value.
#
#     Foo::Foo, Bar::Bar = baz
#     ^^^^^^^^  ^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:4908
class Prism::ConstantPathTargetNode < ::Prism::Node
  # def initialize: (Node? parent, Node child, Location delimiter_loc, Location location) -> void
  #
  # @return [ConstantPathTargetNode] a new instance of ConstantPathTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4919
  def initialize(parent, child, delimiter_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:4928
  def accept(visitor); end

  # attr_reader child: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:4913
  sig { returns(Prism::Node) }
  def child; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4933
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4946
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4938
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:4951
  sig { params(params: T.untyped).returns(Prism::ConstantPathTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:4933
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { parent: Node?, child: Node, delimiter_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:4964
  def deconstruct_keys(keys); end

  # def delimiter: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4969
  sig { returns(String) }
  def delimiter; end

  # attr_reader delimiter_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:4916
  sig { returns(Prism::Location) }
  def delimiter_loc; end

  # Returns the full name of this constant path. For example: "Foo::Bar"
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:152
  def full_name; end

  # Returns the list of parts for the full name of this constant path.
  # For example: [:Foo, :Bar]
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:137
  def full_name_parts; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:4974
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader parent: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:4910
  sig { returns(T.nilable(Prism::Node)) }
  def parent; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:5002
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:5012
    def type; end
  end
end

# Represents writing to a constant path.
#
#     ::Foo = 1
#     ^^^^^^^^^
#
#     Foo::Bar = 1
#     ^^^^^^^^^^^^
#
#     ::Foo::Bar = 1
#     ^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:5027
class Prism::ConstantPathWriteNode < ::Prism::Node
  # def initialize: (ConstantPathNode target, Location operator_loc, Node value, Location location) -> void
  #
  # @return [ConstantPathWriteNode] a new instance of ConstantPathWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5038
  def initialize(target, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:5047
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5052
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5062
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5057
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5067
  sig { params(params: T.untyped).returns(Prism::ConstantPathWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5052
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { target: ConstantPathNode, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:5080
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5090
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5085
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:5032
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5029
  sig { returns(Prism::ConstantPathNode) }
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:5114
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:5035
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:5124
    def type; end
  end
end

# Represents referencing a constant.
#
#     Foo
#     ^^^
#
# source://prism-0.23.0/lib/prism/node.rb:5133
class Prism::ConstantReadNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [ConstantReadNode] a new instance of ConstantReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5142
  def initialize(name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:5149
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5154
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5164
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5159
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5169
  sig { params(params: T.untyped).returns(Prism::ConstantReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5154
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:5180
  def deconstruct_keys(keys); end

  # Returns the full name of this constant. For example: "Foo"
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:96
  def full_name; end

  # Returns the list of parts for the full name of this constant.
  # For example: [:Foo]
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:91
  def full_name_parts; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5185
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the [constant](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#constants).
  #
  #     X              # name `:X`
  #
  #     SOME_CONSTANT  # name `:SOME_CONSTANT`
  #
  # source://prism-0.23.0/lib/prism/node.rb:5139
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:5205
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:5215
    def type; end
  end
end

# Represents writing to a constant in a context that doesn't have an explicit value.
#
#     Foo, Bar = baz
#     ^^^  ^^^
#
# source://prism-0.23.0/lib/prism/node.rb:5224
class Prism::ConstantTargetNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [ConstantTargetNode] a new instance of ConstantTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5229
  def initialize(name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:5236
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5241
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5251
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5246
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5256
  sig { params(params: T.untyped).returns(Prism::ConstantTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5241
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:5267
  def deconstruct_keys(keys); end

  # Returns the full name of this constant. For example: "Foo"
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:165
  def full_name; end

  # Returns the list of parts for the full name of this constant.
  # For example: [:Foo]
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:160
  def full_name_parts; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5272
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:5226
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:5292
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:5302
    def type; end
  end
end

# Represents writing to a constant.
#
#     Foo = 1
#     ^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:5311
class Prism::ConstantWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Node value, Location operator_loc, Location location) -> void
  #
  # @return [ConstantWriteNode] a new instance of ConstantWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5325
  def initialize(name, name_loc, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:5335
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5340
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5350
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5345
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5355
  sig { params(params: T.untyped).returns(Prism::ConstantWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5340
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:5369
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5379
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:5313
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:5316
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5374
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:5322
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:5403
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:5319
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:5413
    def type; end
  end
end

class Prism::DATAComment < Prism::Comment; end

# The DSL module provides a set of methods that can be used to create prism
# nodes in a more concise manner. For example, instead of writing:
#
#     source = Prism::Source.new("[1]")
#
#     Prism::ArrayNode.new(
#       [
#         Prism::IntegerNode.new(
#           Prism::IntegerBaseFlags::DECIMAL,
#           Prism::Location.new(source, 1, 1),
#         )
#       ],
#       Prism::Location.new(source, 0, 1),
#       Prism::Location.new(source, 2, 1)
#     )
#
# you could instead write:
#
#     source = Prism::Source.new("[1]")
#
#     ArrayNode(
#       IntegerNode(Prism::IntegerBaseFlags::DECIMAL, Location(source, 1, 1))),
#       Location(source, 0, 1),
#       Location(source, 2, 1)
#     )
#
# This is mostly helpful in the context of writing tests, but can also be used
# to generate trees programmatically.
#
# source://prism-0.23.0/lib/prism/dsl.rb:37
module Prism::DSL
  private

  # Create a new AliasGlobalVariableNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:46
  def AliasGlobalVariableNode(new_name, old_name, keyword_loc, location = T.unsafe(nil)); end

  # Create a new AliasMethodNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:51
  def AliasMethodNode(new_name, old_name, keyword_loc, location = T.unsafe(nil)); end

  # Create a new AlternationPatternNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:56
  def AlternationPatternNode(left, right, operator_loc, location = T.unsafe(nil)); end

  # Create a new AndNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:61
  def AndNode(left, right, operator_loc, location = T.unsafe(nil)); end

  # Create a new ArgumentsNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:66
  def ArgumentsNode(flags, arguments, location = T.unsafe(nil)); end

  # Create a new ArrayNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:71
  def ArrayNode(flags, elements, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new ArrayPatternNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:76
  def ArrayPatternNode(constant, requireds, rest, posts, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new AssocNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:81
  def AssocNode(key, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new AssocSplatNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:86
  def AssocSplatNode(value, operator_loc, location = T.unsafe(nil)); end

  # Create a new BackReferenceReadNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:91
  def BackReferenceReadNode(name, location = T.unsafe(nil)); end

  # Create a new BeginNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:96
  def BeginNode(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new BlockArgumentNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:101
  def BlockArgumentNode(expression, operator_loc, location = T.unsafe(nil)); end

  # Create a new BlockLocalVariableNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:106
  def BlockLocalVariableNode(flags, name, location = T.unsafe(nil)); end

  # Create a new BlockNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:111
  def BlockNode(locals, parameters, body, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new BlockParameterNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:116
  def BlockParameterNode(flags, name, name_loc, operator_loc, location = T.unsafe(nil)); end

  # Create a new BlockParametersNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:121
  def BlockParametersNode(parameters, locals, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new BreakNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:126
  def BreakNode(arguments, keyword_loc, location = T.unsafe(nil)); end

  # Create a new CallAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:131
  def CallAndWriteNode(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new CallNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:136
  def CallNode(flags, receiver, call_operator_loc, name, message_loc, opening_loc, arguments, closing_loc, block, location = T.unsafe(nil)); end

  # Create a new CallOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:141
  def CallOperatorWriteNode(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new CallOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:146
  def CallOrWriteNode(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new CallTargetNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:151
  def CallTargetNode(flags, receiver, call_operator_loc, name, message_loc, location = T.unsafe(nil)); end

  # Create a new CapturePatternNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:156
  def CapturePatternNode(value, target, operator_loc, location = T.unsafe(nil)); end

  # Create a new CaseMatchNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:161
  def CaseMatchNode(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new CaseNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:166
  def CaseNode(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new ClassNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:171
  def ClassNode(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name, location = T.unsafe(nil)); end

  # Create a new ClassVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:176
  def ClassVariableAndWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ClassVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:181
  def ClassVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new ClassVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:186
  def ClassVariableOrWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ClassVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:191
  def ClassVariableReadNode(name, location = T.unsafe(nil)); end

  # Create a new ClassVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:196
  def ClassVariableTargetNode(name, location = T.unsafe(nil)); end

  # Create a new ClassVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:201
  def ClassVariableWriteNode(name, name_loc, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new ConstantAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:206
  def ConstantAndWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:211
  def ConstantOperatorWriteNode(name, name_loc, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new ConstantOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:216
  def ConstantOrWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantPathAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:221
  def ConstantPathAndWriteNode(target, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantPathNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:226
  def ConstantPathNode(parent, child, delimiter_loc, location = T.unsafe(nil)); end

  # Create a new ConstantPathOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:231
  def ConstantPathOperatorWriteNode(target, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new ConstantPathOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:236
  def ConstantPathOrWriteNode(target, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantPathTargetNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:241
  def ConstantPathTargetNode(parent, child, delimiter_loc, location = T.unsafe(nil)); end

  # Create a new ConstantPathWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:246
  def ConstantPathWriteNode(target, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantReadNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:251
  def ConstantReadNode(name, location = T.unsafe(nil)); end

  # Create a new ConstantTargetNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:256
  def ConstantTargetNode(name, location = T.unsafe(nil)); end

  # Create a new ConstantWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:261
  def ConstantWriteNode(name, name_loc, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new DefNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:266
  def DefNode(name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new DefinedNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:271
  def DefinedNode(lparen_loc, value, rparen_loc, keyword_loc, location = T.unsafe(nil)); end

  # Create a new ElseNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:276
  def ElseNode(else_keyword_loc, statements, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new EmbeddedStatementsNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:281
  def EmbeddedStatementsNode(opening_loc, statements, closing_loc, location = T.unsafe(nil)); end

  # Create a new EmbeddedVariableNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:286
  def EmbeddedVariableNode(operator_loc, variable, location = T.unsafe(nil)); end

  # Create a new EnsureNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:291
  def EnsureNode(ensure_keyword_loc, statements, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new FalseNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:296
  def FalseNode(location = T.unsafe(nil)); end

  # Create a new FindPatternNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:301
  def FindPatternNode(constant, left, requireds, right, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new FlipFlopNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:306
  def FlipFlopNode(flags, left, right, operator_loc, location = T.unsafe(nil)); end

  # Create a new FloatNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:311
  def FloatNode(location = T.unsafe(nil)); end

  # Create a new ForNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:316
  def ForNode(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new ForwardingArgumentsNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:321
  def ForwardingArgumentsNode(location = T.unsafe(nil)); end

  # Create a new ForwardingParameterNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:326
  def ForwardingParameterNode(location = T.unsafe(nil)); end

  # Create a new ForwardingSuperNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:331
  def ForwardingSuperNode(block, location = T.unsafe(nil)); end

  # Create a new GlobalVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:336
  def GlobalVariableAndWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new GlobalVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:341
  def GlobalVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new GlobalVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:346
  def GlobalVariableOrWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new GlobalVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:351
  def GlobalVariableReadNode(name, location = T.unsafe(nil)); end

  # Create a new GlobalVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:356
  def GlobalVariableTargetNode(name, location = T.unsafe(nil)); end

  # Create a new GlobalVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:361
  def GlobalVariableWriteNode(name, name_loc, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new HashNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:366
  def HashNode(opening_loc, elements, closing_loc, location = T.unsafe(nil)); end

  # Create a new HashPatternNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:371
  def HashPatternNode(constant, elements, rest, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new IfNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:376
  def IfNode(if_keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new ImaginaryNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:381
  def ImaginaryNode(numeric, location = T.unsafe(nil)); end

  # Create a new ImplicitNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:386
  def ImplicitNode(value, location = T.unsafe(nil)); end

  # Create a new ImplicitRestNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:391
  def ImplicitRestNode(location = T.unsafe(nil)); end

  # Create a new InNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:396
  def InNode(pattern, statements, in_loc, then_loc, location = T.unsafe(nil)); end

  # Create a new IndexAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:401
  def IndexAndWriteNode(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new IndexOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:406
  def IndexOperatorWriteNode(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new IndexOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:411
  def IndexOrWriteNode(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new IndexTargetNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:416
  def IndexTargetNode(flags, receiver, opening_loc, arguments, closing_loc, block, location = T.unsafe(nil)); end

  # Create a new InstanceVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:421
  def InstanceVariableAndWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new InstanceVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:426
  def InstanceVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new InstanceVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:431
  def InstanceVariableOrWriteNode(name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new InstanceVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:436
  def InstanceVariableReadNode(name, location = T.unsafe(nil)); end

  # Create a new InstanceVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:441
  def InstanceVariableTargetNode(name, location = T.unsafe(nil)); end

  # Create a new InstanceVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:446
  def InstanceVariableWriteNode(name, name_loc, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new IntegerNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:451
  def IntegerNode(flags, location = T.unsafe(nil)); end

  # Create a new InterpolatedMatchLastLineNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:456
  def InterpolatedMatchLastLineNode(flags, opening_loc, parts, closing_loc, location = T.unsafe(nil)); end

  # Create a new InterpolatedRegularExpressionNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:461
  def InterpolatedRegularExpressionNode(flags, opening_loc, parts, closing_loc, location = T.unsafe(nil)); end

  # Create a new InterpolatedStringNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:466
  def InterpolatedStringNode(opening_loc, parts, closing_loc, location = T.unsafe(nil)); end

  # Create a new InterpolatedSymbolNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:471
  def InterpolatedSymbolNode(opening_loc, parts, closing_loc, location = T.unsafe(nil)); end

  # Create a new InterpolatedXStringNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:476
  def InterpolatedXStringNode(opening_loc, parts, closing_loc, location = T.unsafe(nil)); end

  # Create a new KeywordHashNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:481
  def KeywordHashNode(flags, elements, location = T.unsafe(nil)); end

  # Create a new KeywordRestParameterNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:486
  def KeywordRestParameterNode(flags, name, name_loc, operator_loc, location = T.unsafe(nil)); end

  # Create a new LambdaNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:491
  def LambdaNode(locals, operator_loc, opening_loc, closing_loc, parameters, body, location = T.unsafe(nil)); end

  # Create a new LocalVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:496
  def LocalVariableAndWriteNode(name_loc, operator_loc, value, name, depth, location = T.unsafe(nil)); end

  # Create a new LocalVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:501
  def LocalVariableOperatorWriteNode(name_loc, operator_loc, value, name, operator, depth, location = T.unsafe(nil)); end

  # Create a new LocalVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:506
  def LocalVariableOrWriteNode(name_loc, operator_loc, value, name, depth, location = T.unsafe(nil)); end

  # Create a new LocalVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:511
  def LocalVariableReadNode(name, depth, location = T.unsafe(nil)); end

  # Create a new LocalVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:516
  def LocalVariableTargetNode(name, depth, location = T.unsafe(nil)); end

  # Create a new LocalVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:521
  def LocalVariableWriteNode(name, depth, name_loc, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new Location object
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:41
  def Location(source = T.unsafe(nil), start_offset = T.unsafe(nil), length = T.unsafe(nil)); end

  # Create a new MatchLastLineNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:526
  def MatchLastLineNode(flags, opening_loc, content_loc, closing_loc, unescaped, location = T.unsafe(nil)); end

  # Create a new MatchPredicateNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:531
  def MatchPredicateNode(value, pattern, operator_loc, location = T.unsafe(nil)); end

  # Create a new MatchRequiredNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:536
  def MatchRequiredNode(value, pattern, operator_loc, location = T.unsafe(nil)); end

  # Create a new MatchWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:541
  def MatchWriteNode(call, targets, location = T.unsafe(nil)); end

  # Create a new MissingNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:546
  def MissingNode(location = T.unsafe(nil)); end

  # Create a new ModuleNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:551
  def ModuleNode(locals, module_keyword_loc, constant_path, body, end_keyword_loc, name, location = T.unsafe(nil)); end

  # Create a new MultiTargetNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:556
  def MultiTargetNode(lefts, rest, rights, lparen_loc, rparen_loc, location = T.unsafe(nil)); end

  # Create a new MultiWriteNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:561
  def MultiWriteNode(lefts, rest, rights, lparen_loc, rparen_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new NextNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:566
  def NextNode(arguments, keyword_loc, location = T.unsafe(nil)); end

  # Create a new NilNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:571
  def NilNode(location = T.unsafe(nil)); end

  # Create a new NoKeywordsParameterNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:576
  def NoKeywordsParameterNode(operator_loc, keyword_loc, location = T.unsafe(nil)); end

  # Create a new NumberedParametersNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:581
  def NumberedParametersNode(maximum, location = T.unsafe(nil)); end

  # Create a new NumberedReferenceReadNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:586
  def NumberedReferenceReadNode(number, location = T.unsafe(nil)); end

  # Create a new OptionalKeywordParameterNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:591
  def OptionalKeywordParameterNode(flags, name, name_loc, value, location = T.unsafe(nil)); end

  # Create a new OptionalParameterNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:596
  def OptionalParameterNode(flags, name, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new OrNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:601
  def OrNode(left, right, operator_loc, location = T.unsafe(nil)); end

  # Create a new ParametersNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:606
  def ParametersNode(requireds, optionals, rest, posts, keywords, keyword_rest, block, location = T.unsafe(nil)); end

  # Create a new ParenthesesNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:611
  def ParenthesesNode(body, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new PinnedExpressionNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:616
  def PinnedExpressionNode(expression, operator_loc, lparen_loc, rparen_loc, location = T.unsafe(nil)); end

  # Create a new PinnedVariableNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:621
  def PinnedVariableNode(variable, operator_loc, location = T.unsafe(nil)); end

  # Create a new PostExecutionNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:626
  def PostExecutionNode(statements, keyword_loc, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new PreExecutionNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:631
  def PreExecutionNode(statements, keyword_loc, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new ProgramNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:636
  def ProgramNode(locals, statements, location = T.unsafe(nil)); end

  # Create a new RangeNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:641
  def RangeNode(flags, left, right, operator_loc, location = T.unsafe(nil)); end

  # Create a new RationalNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:646
  def RationalNode(numeric, location = T.unsafe(nil)); end

  # Create a new RedoNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:651
  def RedoNode(location = T.unsafe(nil)); end

  # Create a new RegularExpressionNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:656
  def RegularExpressionNode(flags, opening_loc, content_loc, closing_loc, unescaped, location = T.unsafe(nil)); end

  # Create a new RequiredKeywordParameterNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:661
  def RequiredKeywordParameterNode(flags, name, name_loc, location = T.unsafe(nil)); end

  # Create a new RequiredParameterNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:666
  def RequiredParameterNode(flags, name, location = T.unsafe(nil)); end

  # Create a new RescueModifierNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:671
  def RescueModifierNode(expression, keyword_loc, rescue_expression, location = T.unsafe(nil)); end

  # Create a new RescueNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:676
  def RescueNode(keyword_loc, exceptions, operator_loc, reference, statements, consequent, location = T.unsafe(nil)); end

  # Create a new RestParameterNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:681
  def RestParameterNode(flags, name, name_loc, operator_loc, location = T.unsafe(nil)); end

  # Create a new RetryNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:686
  def RetryNode(location = T.unsafe(nil)); end

  # Create a new ReturnNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:691
  def ReturnNode(keyword_loc, arguments, location = T.unsafe(nil)); end

  # Create a new SelfNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:696
  def SelfNode(location = T.unsafe(nil)); end

  # Create a new SingletonClassNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:701
  def SingletonClassNode(locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new SourceEncodingNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:706
  def SourceEncodingNode(location = T.unsafe(nil)); end

  # Create a new SourceFileNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:711
  def SourceFileNode(filepath, location = T.unsafe(nil)); end

  # Create a new SourceLineNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:716
  def SourceLineNode(location = T.unsafe(nil)); end

  # Create a new SplatNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:721
  def SplatNode(operator_loc, expression, location = T.unsafe(nil)); end

  # Create a new StatementsNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:726
  def StatementsNode(body, location = T.unsafe(nil)); end

  # Create a new StringNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:731
  def StringNode(flags, opening_loc, content_loc, closing_loc, unescaped, location = T.unsafe(nil)); end

  # Create a new SuperNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:736
  def SuperNode(keyword_loc, lparen_loc, arguments, rparen_loc, block, location = T.unsafe(nil)); end

  # Create a new SymbolNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:741
  def SymbolNode(flags, opening_loc, value_loc, closing_loc, unescaped, location = T.unsafe(nil)); end

  # Create a new TrueNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:746
  def TrueNode(location = T.unsafe(nil)); end

  # Create a new UndefNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:751
  def UndefNode(names, keyword_loc, location = T.unsafe(nil)); end

  # Create a new UnlessNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:756
  def UnlessNode(keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new UntilNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:761
  def UntilNode(flags, keyword_loc, closing_loc, predicate, statements, location = T.unsafe(nil)); end

  # Create a new WhenNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:766
  def WhenNode(keyword_loc, conditions, statements, location = T.unsafe(nil)); end

  # Create a new WhileNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:771
  def WhileNode(flags, keyword_loc, closing_loc, predicate, statements, location = T.unsafe(nil)); end

  # Create a new XStringNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:776
  def XStringNode(flags, opening_loc, content_loc, closing_loc, unescaped, location = T.unsafe(nil)); end

  # Create a new YieldNode node
  #
  # source://prism-0.23.0/lib/prism/dsl.rb:781
  def YieldNode(keyword_loc, lparen_loc, arguments, rparen_loc, location = T.unsafe(nil)); end
end

# This module is used for testing and debugging and is not meant to be used by
# consumers of this library.
#
# source://prism-0.23.0/lib/prism/debug.rb:6
module Prism::Debug
  class << self
    # :call-seq:
    #   Debug::cruby_locals(source) -> Array
    #
    # For the given source, compiles with CRuby and returns a list of all of the
    # sets of local variables that were encountered.
    #
    # source://prism-0.23.0/lib/prism/debug.rb:54
    def cruby_locals(source); end

    def format_errors(_arg0, _arg1); end
    def inspect_node(_arg0); end
    def memsize(_arg0); end
    def named_captures(_arg0); end

    # :call-seq:
    #   Debug::newlines(source) -> Array
    #
    # For the given source string, return the byte offsets of every newline in
    # the source.
    #
    # source://prism-0.23.0/lib/prism/debug.rb:202
    def newlines(source); end

    # :call-seq:
    #   Debug::prism_locals(source) -> Array
    #
    # For the given source, parses with prism and returns a list of all of the
    # sets of local variables that were encountered.
    #
    # source://prism-0.23.0/lib/prism/debug.rb:98
    def prism_locals(source); end

    def profile_file(_arg0); end
  end
end

# Used to hold the place of a local that will be in the local table but
# cannot be accessed directly from the source code. For example, the
# iteration variable in a for loop or the positional parameter on a method
# definition that is destructured.
#
# source://prism-0.23.0/lib/prism/debug.rb:90
Prism::Debug::AnonymousLocal = T.let(T.unsafe(nil), Object)

# A wrapper around a RubyVM::InstructionSequence that provides a more
# convenient interface for accessing parts of the iseq.
#
# source://prism-0.23.0/lib/prism/debug.rb:9
class Prism::Debug::ISeq
  # @return [ISeq] a new instance of ISeq
  #
  # source://prism-0.23.0/lib/prism/debug.rb:12
  def initialize(parts); end

  # source://prism-0.23.0/lib/prism/debug.rb:28
  def each_child; end

  # source://prism-0.23.0/lib/prism/debug.rb:24
  def instructions; end

  # source://prism-0.23.0/lib/prism/debug.rb:20
  def local_table; end

  # source://prism-0.23.0/lib/prism/debug.rb:10
  def parts; end

  # source://prism-0.23.0/lib/prism/debug.rb:16
  def type; end
end

# Represents a method definition.
#
#     def method
#     end
#     ^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:5423
class Prism::DefNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Node? receiver, ParametersNode? parameters, Node? body, Array[Symbol] locals, Location def_keyword_loc, Location? operator_loc, Location? lparen_loc, Location? rparen_loc, Location? equal_loc, Location? end_keyword_loc, Location location) -> void
  #
  # @return [DefNode] a new instance of DefNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5461
  def initialize(name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:5479
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5437
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5484
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5498
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5489
  def compact_child_nodes; end

  # def copy: (**params) -> DefNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5503
  sig { params(params: T.untyped).returns(Prism::DefNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5484
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, receiver: Node?, parameters: ParametersNode?, body: Node?, locals: Array[Symbol], def_keyword_loc: Location, operator_loc: Location?, lparen_loc: Location?, rparen_loc: Location?, equal_loc: Location?, end_keyword_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:5525
  def deconstruct_keys(keys); end

  # def def_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5530
  sig { returns(String) }
  def def_keyword; end

  # attr_reader def_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:5443
  sig { returns(Prism::Location) }
  def def_keyword_loc; end

  # def end_keyword: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5555
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5458
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  # def equal: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5550
  sig { returns(T.nilable(String)) }
  def equal; end

  # attr_reader equal_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5455
  sig { returns(T.nilable(Prism::Location)) }
  def equal_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5560
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5440
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def lparen: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5540
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5449
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:5425
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:5428
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5535
  sig { returns(T.nilable(String)) }
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5446
  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  # attr_reader parameters: ParametersNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5434
  sig { returns(T.nilable(Prism::ParametersNode)) }
  def parameters; end

  # attr_reader receiver: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5431
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def rparen: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5545
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5452
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:5606
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:5616
    def type; end
  end
end

# Represents the use of the `defined?` keyword.
#
#     defined?(a)
#     ^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:5625
class Prism::DefinedNode < ::Prism::Node
  # def initialize: (Location? lparen_loc, Node value, Location? rparen_loc, Location keyword_loc, Location location) -> void
  #
  # @return [DefinedNode] a new instance of DefinedNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5639
  def initialize(lparen_loc, value, rparen_loc, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:5649
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5654
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5664
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5659
  def compact_child_nodes; end

  # def copy: (**params) -> DefinedNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5669
  sig { params(params: T.untyped).returns(Prism::DefinedNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5654
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { lparen_loc: Location?, value: Node, rparen_loc: Location?, keyword_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:5683
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5703
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5698
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:5636
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5688
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5627
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5693
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5633
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:5727
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:5630
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:5737
    def type; end
  end
end

# DesugarCompiler is a compiler that desugars Ruby code into a more primitive
# form. This is useful for consumers that want to deal with fewer node types.
#
# source://prism-0.23.0/lib/prism/desugar_compiler.rb:6
class Prism::DesugarCompiler < ::Prism::MutationCompiler
  # @@foo &&= bar
  #
  # becomes
  #
  # @@foo && @@foo = bar
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:12
  def visit_class_variable_and_write_node(node); end

  # @@foo += bar
  #
  # becomes
  #
  # @@foo = @@foo + bar
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:30
  def visit_class_variable_operator_write_node(node); end

  # @@foo ||= bar
  #
  # becomes
  #
  # defined?(@@foo) ? @@foo : @@foo = bar
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:21
  def visit_class_variable_or_write_node(node); end

  # Foo &&= bar
  #
  # becomes
  #
  # Foo && Foo = bar
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:39
  def visit_constant_and_write_node(node); end

  # Foo += bar
  #
  # becomes
  #
  # Foo = Foo + bar
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:57
  def visit_constant_operator_write_node(node); end

  # Foo ||= bar
  #
  # becomes
  #
  # defined?(Foo) ? Foo : Foo = bar
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:48
  def visit_constant_or_write_node(node); end

  # $foo &&= bar
  #
  # becomes
  #
  # $foo && $foo = bar
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:66
  def visit_global_variable_and_write_node(node); end

  # $foo += bar
  #
  # becomes
  #
  # $foo = $foo + bar
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:84
  def visit_global_variable_operator_write_node(node); end

  # $foo ||= bar
  #
  # becomes
  #
  # defined?($foo) ? $foo : $foo = bar
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:75
  def visit_global_variable_or_write_node(node); end

  # becomes
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:93
  def visit_instance_variable_and_write_node(node); end

  # becomes
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:111
  def visit_instance_variable_operator_write_node(node); end

  # becomes
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:102
  def visit_instance_variable_or_write_node(node); end

  # foo &&= bar
  #
  # becomes
  #
  # foo && foo = bar
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:120
  def visit_local_variable_and_write_node(node); end

  # foo += bar
  #
  # becomes
  #
  # foo = foo + bar
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:138
  def visit_local_variable_operator_write_node(node); end

  # foo ||= bar
  #
  # becomes
  #
  # foo || foo = bar
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:129
  def visit_local_variable_or_write_node(node); end

  private

  # Desugar `x &&= y` to `x && x = y`
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:145
  def desugar_and_write_node(node, read_class, write_class, *arguments); end

  # Desugar `x += y` to `x = x + y`
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:155
  def desugar_operator_write_node(node, read_class, write_class, *arguments); end

  # Desugar `x ||= y` to `defined?(x) ? x : x = y`
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:187
  def desugar_or_write_defined_node(node, read_class, write_class, *arguments); end

  # Desugar `x ||= y` to `x || x = y`
  #
  # source://prism-0.23.0/lib/prism/desugar_compiler.rb:177
  def desugar_or_write_node(node, read_class, write_class, *arguments); end
end

# The dispatcher class fires events for nodes that are found while walking an
# AST to all registered listeners. It's useful for performing different types
# of analysis on the AST while only having to walk the tree once.
#
# To use the dispatcher, you would first instantiate it and register listeners
# for the events you're interested in:
#
#     class OctalListener
#       def on_integer_node_enter(node)
#         if node.octal? && !node.slice.start_with?("0o")
#           warn("Octal integers should be written with the 0o prefix")
#         end
#       end
#     end
#
#     dispatcher = Dispatcher.new
#     dispatcher.register(listener, :on_integer_node_enter)
#
# Then, you can walk any number of trees and dispatch events to the listeners:
#
#     result = Prism.parse("001 + 002 + 003")
#     dispatcher.dispatch(result.value)
#
# Optionally, you can also use `#dispatch_once` to dispatch enter and leave
# events for a single node without recursing further down the tree. This can
# be useful in circumstances where you want to reuse the listeners you already
# have registers but want to stop walking the tree at a certain point.
#
#     integer = result.value.statements.body.first.receiver.receiver
#     dispatcher.dispatch_once(integer)
#
# source://prism-0.23.0/lib/prism/dispatcher.rb:40
class Prism::Dispatcher < ::Prism::Visitor
  # Initialize a new dispatcher.
  #
  # @return [Dispatcher] a new instance of Dispatcher
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:45
  def initialize; end

  # Walks `root` dispatching events to all registered listeners.
  #
  # def dispatch: (Node) -> void
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:16
  def dispatch(node); end

  # Dispatches a single event for `node` to all registered listeners.
  #
  # def dispatch_once: (Node) -> void
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:64
  def dispatch_once(node); end

  # attr_reader listeners: Hash[Symbol, Array[Listener]]
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:42
  def listeners; end

  # Register a listener for one or more events.
  #
  # def register: (Listener, *Symbol) -> void
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:52
  def register(listener, *events); end

  # Dispatch enter and leave events for AliasGlobalVariableNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:70
  def visit_alias_global_variable_node(node); end

  # Dispatch enter and leave events for AliasMethodNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:78
  def visit_alias_method_node(node); end

  # Dispatch enter and leave events for AlternationPatternNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:86
  def visit_alternation_pattern_node(node); end

  # Dispatch enter and leave events for AndNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:94
  def visit_and_node(node); end

  # Dispatch enter and leave events for ArgumentsNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:102
  def visit_arguments_node(node); end

  # Dispatch enter and leave events for ArrayNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:110
  def visit_array_node(node); end

  # Dispatch enter and leave events for ArrayPatternNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:118
  def visit_array_pattern_node(node); end

  # Dispatch enter and leave events for AssocNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:126
  def visit_assoc_node(node); end

  # Dispatch enter and leave events for AssocSplatNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:134
  def visit_assoc_splat_node(node); end

  # Dispatch enter and leave events for BackReferenceReadNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:142
  def visit_back_reference_read_node(node); end

  # Dispatch enter and leave events for BeginNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:150
  def visit_begin_node(node); end

  # Dispatch enter and leave events for BlockArgumentNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:158
  def visit_block_argument_node(node); end

  # Dispatch enter and leave events for BlockLocalVariableNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:166
  def visit_block_local_variable_node(node); end

  # Dispatch enter and leave events for BlockNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:174
  def visit_block_node(node); end

  # Dispatch enter and leave events for BlockParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:182
  def visit_block_parameter_node(node); end

  # Dispatch enter and leave events for BlockParametersNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:190
  def visit_block_parameters_node(node); end

  # Dispatch enter and leave events for BreakNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:198
  def visit_break_node(node); end

  # Dispatch enter and leave events for CallAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:206
  def visit_call_and_write_node(node); end

  # Dispatch enter and leave events for CallNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:214
  def visit_call_node(node); end

  # Dispatch enter and leave events for CallOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:222
  def visit_call_operator_write_node(node); end

  # Dispatch enter and leave events for CallOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:230
  def visit_call_or_write_node(node); end

  # Dispatch enter and leave events for CallTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:238
  def visit_call_target_node(node); end

  # Dispatch enter and leave events for CapturePatternNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:246
  def visit_capture_pattern_node(node); end

  # Dispatch enter and leave events for CaseMatchNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:254
  def visit_case_match_node(node); end

  # Dispatch enter and leave events for CaseNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:262
  def visit_case_node(node); end

  # Dispatch enter and leave events for ClassNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:270
  def visit_class_node(node); end

  # Dispatch enter and leave events for ClassVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:278
  def visit_class_variable_and_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:286
  def visit_class_variable_operator_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:294
  def visit_class_variable_or_write_node(node); end

  # Dispatch enter and leave events for ClassVariableReadNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:302
  def visit_class_variable_read_node(node); end

  # Dispatch enter and leave events for ClassVariableTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:310
  def visit_class_variable_target_node(node); end

  # Dispatch enter and leave events for ClassVariableWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:318
  def visit_class_variable_write_node(node); end

  # Dispatch enter and leave events for ConstantAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:326
  def visit_constant_and_write_node(node); end

  # Dispatch enter and leave events for ConstantOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:334
  def visit_constant_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:342
  def visit_constant_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:350
  def visit_constant_path_and_write_node(node); end

  # Dispatch enter and leave events for ConstantPathNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:358
  def visit_constant_path_node(node); end

  # Dispatch enter and leave events for ConstantPathOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:366
  def visit_constant_path_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantPathOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:374
  def visit_constant_path_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:382
  def visit_constant_path_target_node(node); end

  # Dispatch enter and leave events for ConstantPathWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:390
  def visit_constant_path_write_node(node); end

  # Dispatch enter and leave events for ConstantReadNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:398
  def visit_constant_read_node(node); end

  # Dispatch enter and leave events for ConstantTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:406
  def visit_constant_target_node(node); end

  # Dispatch enter and leave events for ConstantWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:414
  def visit_constant_write_node(node); end

  # Dispatch enter and leave events for DefNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:422
  def visit_def_node(node); end

  # Dispatch enter and leave events for DefinedNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:430
  def visit_defined_node(node); end

  # Dispatch enter and leave events for ElseNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:438
  def visit_else_node(node); end

  # Dispatch enter and leave events for EmbeddedStatementsNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:446
  def visit_embedded_statements_node(node); end

  # Dispatch enter and leave events for EmbeddedVariableNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:454
  def visit_embedded_variable_node(node); end

  # Dispatch enter and leave events for EnsureNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:462
  def visit_ensure_node(node); end

  # Dispatch enter and leave events for FalseNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:470
  def visit_false_node(node); end

  # Dispatch enter and leave events for FindPatternNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:478
  def visit_find_pattern_node(node); end

  # Dispatch enter and leave events for FlipFlopNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:486
  def visit_flip_flop_node(node); end

  # Dispatch enter and leave events for FloatNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:494
  def visit_float_node(node); end

  # Dispatch enter and leave events for ForNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:502
  def visit_for_node(node); end

  # Dispatch enter and leave events for ForwardingArgumentsNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:510
  def visit_forwarding_arguments_node(node); end

  # Dispatch enter and leave events for ForwardingParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:518
  def visit_forwarding_parameter_node(node); end

  # Dispatch enter and leave events for ForwardingSuperNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:526
  def visit_forwarding_super_node(node); end

  # Dispatch enter and leave events for GlobalVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:534
  def visit_global_variable_and_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:542
  def visit_global_variable_operator_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:550
  def visit_global_variable_or_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableReadNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:558
  def visit_global_variable_read_node(node); end

  # Dispatch enter and leave events for GlobalVariableTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:566
  def visit_global_variable_target_node(node); end

  # Dispatch enter and leave events for GlobalVariableWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:574
  def visit_global_variable_write_node(node); end

  # Dispatch enter and leave events for HashNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:582
  def visit_hash_node(node); end

  # Dispatch enter and leave events for HashPatternNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:590
  def visit_hash_pattern_node(node); end

  # Dispatch enter and leave events for IfNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:598
  def visit_if_node(node); end

  # Dispatch enter and leave events for ImaginaryNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:606
  def visit_imaginary_node(node); end

  # Dispatch enter and leave events for ImplicitNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:614
  def visit_implicit_node(node); end

  # Dispatch enter and leave events for ImplicitRestNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:622
  def visit_implicit_rest_node(node); end

  # Dispatch enter and leave events for InNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:630
  def visit_in_node(node); end

  # Dispatch enter and leave events for IndexAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:638
  def visit_index_and_write_node(node); end

  # Dispatch enter and leave events for IndexOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:646
  def visit_index_operator_write_node(node); end

  # Dispatch enter and leave events for IndexOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:654
  def visit_index_or_write_node(node); end

  # Dispatch enter and leave events for IndexTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:662
  def visit_index_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:670
  def visit_instance_variable_and_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:678
  def visit_instance_variable_operator_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:686
  def visit_instance_variable_or_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableReadNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:694
  def visit_instance_variable_read_node(node); end

  # Dispatch enter and leave events for InstanceVariableTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:702
  def visit_instance_variable_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:710
  def visit_instance_variable_write_node(node); end

  # Dispatch enter and leave events for IntegerNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:718
  def visit_integer_node(node); end

  # Dispatch enter and leave events for InterpolatedMatchLastLineNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:726
  def visit_interpolated_match_last_line_node(node); end

  # Dispatch enter and leave events for InterpolatedRegularExpressionNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:734
  def visit_interpolated_regular_expression_node(node); end

  # Dispatch enter and leave events for InterpolatedStringNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:742
  def visit_interpolated_string_node(node); end

  # Dispatch enter and leave events for InterpolatedSymbolNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:750
  def visit_interpolated_symbol_node(node); end

  # Dispatch enter and leave events for InterpolatedXStringNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:758
  def visit_interpolated_x_string_node(node); end

  # Dispatch enter and leave events for KeywordHashNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:766
  def visit_keyword_hash_node(node); end

  # Dispatch enter and leave events for KeywordRestParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:774
  def visit_keyword_rest_parameter_node(node); end

  # Dispatch enter and leave events for LambdaNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:782
  def visit_lambda_node(node); end

  # Dispatch enter and leave events for LocalVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:790
  def visit_local_variable_and_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:798
  def visit_local_variable_operator_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:806
  def visit_local_variable_or_write_node(node); end

  # Dispatch enter and leave events for LocalVariableReadNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:814
  def visit_local_variable_read_node(node); end

  # Dispatch enter and leave events for LocalVariableTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:822
  def visit_local_variable_target_node(node); end

  # Dispatch enter and leave events for LocalVariableWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:830
  def visit_local_variable_write_node(node); end

  # Dispatch enter and leave events for MatchLastLineNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:838
  def visit_match_last_line_node(node); end

  # Dispatch enter and leave events for MatchPredicateNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:846
  def visit_match_predicate_node(node); end

  # Dispatch enter and leave events for MatchRequiredNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:854
  def visit_match_required_node(node); end

  # Dispatch enter and leave events for MatchWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:862
  def visit_match_write_node(node); end

  # Dispatch enter and leave events for MissingNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:870
  def visit_missing_node(node); end

  # Dispatch enter and leave events for ModuleNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:878
  def visit_module_node(node); end

  # Dispatch enter and leave events for MultiTargetNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:886
  def visit_multi_target_node(node); end

  # Dispatch enter and leave events for MultiWriteNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:894
  def visit_multi_write_node(node); end

  # Dispatch enter and leave events for NextNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:902
  def visit_next_node(node); end

  # Dispatch enter and leave events for NilNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:910
  def visit_nil_node(node); end

  # Dispatch enter and leave events for NoKeywordsParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:918
  def visit_no_keywords_parameter_node(node); end

  # Dispatch enter and leave events for NumberedParametersNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:926
  def visit_numbered_parameters_node(node); end

  # Dispatch enter and leave events for NumberedReferenceReadNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:934
  def visit_numbered_reference_read_node(node); end

  # Dispatch enter and leave events for OptionalKeywordParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:942
  def visit_optional_keyword_parameter_node(node); end

  # Dispatch enter and leave events for OptionalParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:950
  def visit_optional_parameter_node(node); end

  # Dispatch enter and leave events for OrNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:958
  def visit_or_node(node); end

  # Dispatch enter and leave events for ParametersNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:966
  def visit_parameters_node(node); end

  # Dispatch enter and leave events for ParenthesesNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:974
  def visit_parentheses_node(node); end

  # Dispatch enter and leave events for PinnedExpressionNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:982
  def visit_pinned_expression_node(node); end

  # Dispatch enter and leave events for PinnedVariableNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:990
  def visit_pinned_variable_node(node); end

  # Dispatch enter and leave events for PostExecutionNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:998
  def visit_post_execution_node(node); end

  # Dispatch enter and leave events for PreExecutionNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1006
  def visit_pre_execution_node(node); end

  # Dispatch enter and leave events for ProgramNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1014
  def visit_program_node(node); end

  # Dispatch enter and leave events for RangeNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1022
  def visit_range_node(node); end

  # Dispatch enter and leave events for RationalNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1030
  def visit_rational_node(node); end

  # Dispatch enter and leave events for RedoNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1038
  def visit_redo_node(node); end

  # Dispatch enter and leave events for RegularExpressionNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1046
  def visit_regular_expression_node(node); end

  # Dispatch enter and leave events for RequiredKeywordParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1054
  def visit_required_keyword_parameter_node(node); end

  # Dispatch enter and leave events for RequiredParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1062
  def visit_required_parameter_node(node); end

  # Dispatch enter and leave events for RescueModifierNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1070
  def visit_rescue_modifier_node(node); end

  # Dispatch enter and leave events for RescueNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1078
  def visit_rescue_node(node); end

  # Dispatch enter and leave events for RestParameterNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1086
  def visit_rest_parameter_node(node); end

  # Dispatch enter and leave events for RetryNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1094
  def visit_retry_node(node); end

  # Dispatch enter and leave events for ReturnNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1102
  def visit_return_node(node); end

  # Dispatch enter and leave events for SelfNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1110
  def visit_self_node(node); end

  # Dispatch enter and leave events for SingletonClassNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1118
  def visit_singleton_class_node(node); end

  # Dispatch enter and leave events for SourceEncodingNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1126
  def visit_source_encoding_node(node); end

  # Dispatch enter and leave events for SourceFileNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1134
  def visit_source_file_node(node); end

  # Dispatch enter and leave events for SourceLineNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1142
  def visit_source_line_node(node); end

  # Dispatch enter and leave events for SplatNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1150
  def visit_splat_node(node); end

  # Dispatch enter and leave events for StatementsNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1158
  def visit_statements_node(node); end

  # Dispatch enter and leave events for StringNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1166
  def visit_string_node(node); end

  # Dispatch enter and leave events for SuperNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1174
  def visit_super_node(node); end

  # Dispatch enter and leave events for SymbolNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1182
  def visit_symbol_node(node); end

  # Dispatch enter and leave events for TrueNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1190
  def visit_true_node(node); end

  # Dispatch enter and leave events for UndefNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1198
  def visit_undef_node(node); end

  # Dispatch enter and leave events for UnlessNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1206
  def visit_unless_node(node); end

  # Dispatch enter and leave events for UntilNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1214
  def visit_until_node(node); end

  # Dispatch enter and leave events for WhenNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1222
  def visit_when_node(node); end

  # Dispatch enter and leave events for WhileNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1230
  def visit_while_node(node); end

  # Dispatch enter and leave events for XStringNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1238
  def visit_x_string_node(node); end

  # Dispatch enter and leave events for YieldNode nodes and continue
  # walking the tree.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1246
  def visit_yield_node(node); end
end

# source://prism-0.23.0/lib/prism/dispatcher.rb:1252
class Prism::Dispatcher::DispatchOnce < ::Prism::Visitor
  # @return [DispatchOnce] a new instance of DispatchOnce
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1255
  def initialize(listeners); end

  # Returns the value of attribute listeners.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1253
  def listeners; end

  # Dispatch enter and leave events for AliasGlobalVariableNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1260
  def visit_alias_global_variable_node(node); end

  # Dispatch enter and leave events for AliasMethodNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1266
  def visit_alias_method_node(node); end

  # Dispatch enter and leave events for AlternationPatternNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1272
  def visit_alternation_pattern_node(node); end

  # Dispatch enter and leave events for AndNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1278
  def visit_and_node(node); end

  # Dispatch enter and leave events for ArgumentsNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1284
  def visit_arguments_node(node); end

  # Dispatch enter and leave events for ArrayNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1290
  def visit_array_node(node); end

  # Dispatch enter and leave events for ArrayPatternNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1296
  def visit_array_pattern_node(node); end

  # Dispatch enter and leave events for AssocNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1302
  def visit_assoc_node(node); end

  # Dispatch enter and leave events for AssocSplatNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1308
  def visit_assoc_splat_node(node); end

  # Dispatch enter and leave events for BackReferenceReadNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1314
  def visit_back_reference_read_node(node); end

  # Dispatch enter and leave events for BeginNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1320
  def visit_begin_node(node); end

  # Dispatch enter and leave events for BlockArgumentNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1326
  def visit_block_argument_node(node); end

  # Dispatch enter and leave events for BlockLocalVariableNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1332
  def visit_block_local_variable_node(node); end

  # Dispatch enter and leave events for BlockNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1338
  def visit_block_node(node); end

  # Dispatch enter and leave events for BlockParameterNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1344
  def visit_block_parameter_node(node); end

  # Dispatch enter and leave events for BlockParametersNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1350
  def visit_block_parameters_node(node); end

  # Dispatch enter and leave events for BreakNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1356
  def visit_break_node(node); end

  # Dispatch enter and leave events for CallAndWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1362
  def visit_call_and_write_node(node); end

  # Dispatch enter and leave events for CallNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1368
  def visit_call_node(node); end

  # Dispatch enter and leave events for CallOperatorWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1374
  def visit_call_operator_write_node(node); end

  # Dispatch enter and leave events for CallOrWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1380
  def visit_call_or_write_node(node); end

  # Dispatch enter and leave events for CallTargetNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1386
  def visit_call_target_node(node); end

  # Dispatch enter and leave events for CapturePatternNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1392
  def visit_capture_pattern_node(node); end

  # Dispatch enter and leave events for CaseMatchNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1398
  def visit_case_match_node(node); end

  # Dispatch enter and leave events for CaseNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1404
  def visit_case_node(node); end

  # Dispatch enter and leave events for ClassNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1410
  def visit_class_node(node); end

  # Dispatch enter and leave events for ClassVariableAndWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1416
  def visit_class_variable_and_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOperatorWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1422
  def visit_class_variable_operator_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOrWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1428
  def visit_class_variable_or_write_node(node); end

  # Dispatch enter and leave events for ClassVariableReadNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1434
  def visit_class_variable_read_node(node); end

  # Dispatch enter and leave events for ClassVariableTargetNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1440
  def visit_class_variable_target_node(node); end

  # Dispatch enter and leave events for ClassVariableWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1446
  def visit_class_variable_write_node(node); end

  # Dispatch enter and leave events for ConstantAndWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1452
  def visit_constant_and_write_node(node); end

  # Dispatch enter and leave events for ConstantOperatorWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1458
  def visit_constant_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantOrWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1464
  def visit_constant_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathAndWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1470
  def visit_constant_path_and_write_node(node); end

  # Dispatch enter and leave events for ConstantPathNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1476
  def visit_constant_path_node(node); end

  # Dispatch enter and leave events for ConstantPathOperatorWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1482
  def visit_constant_path_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantPathOrWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1488
  def visit_constant_path_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathTargetNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1494
  def visit_constant_path_target_node(node); end

  # Dispatch enter and leave events for ConstantPathWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1500
  def visit_constant_path_write_node(node); end

  # Dispatch enter and leave events for ConstantReadNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1506
  def visit_constant_read_node(node); end

  # Dispatch enter and leave events for ConstantTargetNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1512
  def visit_constant_target_node(node); end

  # Dispatch enter and leave events for ConstantWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1518
  def visit_constant_write_node(node); end

  # Dispatch enter and leave events for DefNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1524
  def visit_def_node(node); end

  # Dispatch enter and leave events for DefinedNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1530
  def visit_defined_node(node); end

  # Dispatch enter and leave events for ElseNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1536
  def visit_else_node(node); end

  # Dispatch enter and leave events for EmbeddedStatementsNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1542
  def visit_embedded_statements_node(node); end

  # Dispatch enter and leave events for EmbeddedVariableNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1548
  def visit_embedded_variable_node(node); end

  # Dispatch enter and leave events for EnsureNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1554
  def visit_ensure_node(node); end

  # Dispatch enter and leave events for FalseNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1560
  def visit_false_node(node); end

  # Dispatch enter and leave events for FindPatternNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1566
  def visit_find_pattern_node(node); end

  # Dispatch enter and leave events for FlipFlopNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1572
  def visit_flip_flop_node(node); end

  # Dispatch enter and leave events for FloatNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1578
  def visit_float_node(node); end

  # Dispatch enter and leave events for ForNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1584
  def visit_for_node(node); end

  # Dispatch enter and leave events for ForwardingArgumentsNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1590
  def visit_forwarding_arguments_node(node); end

  # Dispatch enter and leave events for ForwardingParameterNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1596
  def visit_forwarding_parameter_node(node); end

  # Dispatch enter and leave events for ForwardingSuperNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1602
  def visit_forwarding_super_node(node); end

  # Dispatch enter and leave events for GlobalVariableAndWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1608
  def visit_global_variable_and_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOperatorWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1614
  def visit_global_variable_operator_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOrWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1620
  def visit_global_variable_or_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableReadNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1626
  def visit_global_variable_read_node(node); end

  # Dispatch enter and leave events for GlobalVariableTargetNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1632
  def visit_global_variable_target_node(node); end

  # Dispatch enter and leave events for GlobalVariableWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1638
  def visit_global_variable_write_node(node); end

  # Dispatch enter and leave events for HashNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1644
  def visit_hash_node(node); end

  # Dispatch enter and leave events for HashPatternNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1650
  def visit_hash_pattern_node(node); end

  # Dispatch enter and leave events for IfNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1656
  def visit_if_node(node); end

  # Dispatch enter and leave events for ImaginaryNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1662
  def visit_imaginary_node(node); end

  # Dispatch enter and leave events for ImplicitNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1668
  def visit_implicit_node(node); end

  # Dispatch enter and leave events for ImplicitRestNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1674
  def visit_implicit_rest_node(node); end

  # Dispatch enter and leave events for InNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1680
  def visit_in_node(node); end

  # Dispatch enter and leave events for IndexAndWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1686
  def visit_index_and_write_node(node); end

  # Dispatch enter and leave events for IndexOperatorWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1692
  def visit_index_operator_write_node(node); end

  # Dispatch enter and leave events for IndexOrWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1698
  def visit_index_or_write_node(node); end

  # Dispatch enter and leave events for IndexTargetNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1704
  def visit_index_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableAndWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1710
  def visit_instance_variable_and_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOperatorWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1716
  def visit_instance_variable_operator_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOrWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1722
  def visit_instance_variable_or_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableReadNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1728
  def visit_instance_variable_read_node(node); end

  # Dispatch enter and leave events for InstanceVariableTargetNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1734
  def visit_instance_variable_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1740
  def visit_instance_variable_write_node(node); end

  # Dispatch enter and leave events for IntegerNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1746
  def visit_integer_node(node); end

  # Dispatch enter and leave events for InterpolatedMatchLastLineNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1752
  def visit_interpolated_match_last_line_node(node); end

  # Dispatch enter and leave events for InterpolatedRegularExpressionNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1758
  def visit_interpolated_regular_expression_node(node); end

  # Dispatch enter and leave events for InterpolatedStringNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1764
  def visit_interpolated_string_node(node); end

  # Dispatch enter and leave events for InterpolatedSymbolNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1770
  def visit_interpolated_symbol_node(node); end

  # Dispatch enter and leave events for InterpolatedXStringNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1776
  def visit_interpolated_x_string_node(node); end

  # Dispatch enter and leave events for KeywordHashNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1782
  def visit_keyword_hash_node(node); end

  # Dispatch enter and leave events for KeywordRestParameterNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1788
  def visit_keyword_rest_parameter_node(node); end

  # Dispatch enter and leave events for LambdaNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1794
  def visit_lambda_node(node); end

  # Dispatch enter and leave events for LocalVariableAndWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1800
  def visit_local_variable_and_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOperatorWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1806
  def visit_local_variable_operator_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOrWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1812
  def visit_local_variable_or_write_node(node); end

  # Dispatch enter and leave events for LocalVariableReadNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1818
  def visit_local_variable_read_node(node); end

  # Dispatch enter and leave events for LocalVariableTargetNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1824
  def visit_local_variable_target_node(node); end

  # Dispatch enter and leave events for LocalVariableWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1830
  def visit_local_variable_write_node(node); end

  # Dispatch enter and leave events for MatchLastLineNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1836
  def visit_match_last_line_node(node); end

  # Dispatch enter and leave events for MatchPredicateNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1842
  def visit_match_predicate_node(node); end

  # Dispatch enter and leave events for MatchRequiredNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1848
  def visit_match_required_node(node); end

  # Dispatch enter and leave events for MatchWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1854
  def visit_match_write_node(node); end

  # Dispatch enter and leave events for MissingNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1860
  def visit_missing_node(node); end

  # Dispatch enter and leave events for ModuleNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1866
  def visit_module_node(node); end

  # Dispatch enter and leave events for MultiTargetNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1872
  def visit_multi_target_node(node); end

  # Dispatch enter and leave events for MultiWriteNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1878
  def visit_multi_write_node(node); end

  # Dispatch enter and leave events for NextNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1884
  def visit_next_node(node); end

  # Dispatch enter and leave events for NilNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1890
  def visit_nil_node(node); end

  # Dispatch enter and leave events for NoKeywordsParameterNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1896
  def visit_no_keywords_parameter_node(node); end

  # Dispatch enter and leave events for NumberedParametersNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1902
  def visit_numbered_parameters_node(node); end

  # Dispatch enter and leave events for NumberedReferenceReadNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1908
  def visit_numbered_reference_read_node(node); end

  # Dispatch enter and leave events for OptionalKeywordParameterNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1914
  def visit_optional_keyword_parameter_node(node); end

  # Dispatch enter and leave events for OptionalParameterNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1920
  def visit_optional_parameter_node(node); end

  # Dispatch enter and leave events for OrNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1926
  def visit_or_node(node); end

  # Dispatch enter and leave events for ParametersNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1932
  def visit_parameters_node(node); end

  # Dispatch enter and leave events for ParenthesesNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1938
  def visit_parentheses_node(node); end

  # Dispatch enter and leave events for PinnedExpressionNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1944
  def visit_pinned_expression_node(node); end

  # Dispatch enter and leave events for PinnedVariableNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1950
  def visit_pinned_variable_node(node); end

  # Dispatch enter and leave events for PostExecutionNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1956
  def visit_post_execution_node(node); end

  # Dispatch enter and leave events for PreExecutionNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1962
  def visit_pre_execution_node(node); end

  # Dispatch enter and leave events for ProgramNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1968
  def visit_program_node(node); end

  # Dispatch enter and leave events for RangeNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1974
  def visit_range_node(node); end

  # Dispatch enter and leave events for RationalNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1980
  def visit_rational_node(node); end

  # Dispatch enter and leave events for RedoNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1986
  def visit_redo_node(node); end

  # Dispatch enter and leave events for RegularExpressionNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1992
  def visit_regular_expression_node(node); end

  # Dispatch enter and leave events for RequiredKeywordParameterNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:1998
  def visit_required_keyword_parameter_node(node); end

  # Dispatch enter and leave events for RequiredParameterNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2004
  def visit_required_parameter_node(node); end

  # Dispatch enter and leave events for RescueModifierNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2010
  def visit_rescue_modifier_node(node); end

  # Dispatch enter and leave events for RescueNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2016
  def visit_rescue_node(node); end

  # Dispatch enter and leave events for RestParameterNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2022
  def visit_rest_parameter_node(node); end

  # Dispatch enter and leave events for RetryNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2028
  def visit_retry_node(node); end

  # Dispatch enter and leave events for ReturnNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2034
  def visit_return_node(node); end

  # Dispatch enter and leave events for SelfNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2040
  def visit_self_node(node); end

  # Dispatch enter and leave events for SingletonClassNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2046
  def visit_singleton_class_node(node); end

  # Dispatch enter and leave events for SourceEncodingNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2052
  def visit_source_encoding_node(node); end

  # Dispatch enter and leave events for SourceFileNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2058
  def visit_source_file_node(node); end

  # Dispatch enter and leave events for SourceLineNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2064
  def visit_source_line_node(node); end

  # Dispatch enter and leave events for SplatNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2070
  def visit_splat_node(node); end

  # Dispatch enter and leave events for StatementsNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2076
  def visit_statements_node(node); end

  # Dispatch enter and leave events for StringNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2082
  def visit_string_node(node); end

  # Dispatch enter and leave events for SuperNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2088
  def visit_super_node(node); end

  # Dispatch enter and leave events for SymbolNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2094
  def visit_symbol_node(node); end

  # Dispatch enter and leave events for TrueNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2100
  def visit_true_node(node); end

  # Dispatch enter and leave events for UndefNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2106
  def visit_undef_node(node); end

  # Dispatch enter and leave events for UnlessNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2112
  def visit_unless_node(node); end

  # Dispatch enter and leave events for UntilNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2118
  def visit_until_node(node); end

  # Dispatch enter and leave events for WhenNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2124
  def visit_when_node(node); end

  # Dispatch enter and leave events for WhileNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2130
  def visit_while_node(node); end

  # Dispatch enter and leave events for XStringNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2136
  def visit_x_string_node(node); end

  # Dispatch enter and leave events for YieldNode nodes.
  #
  # source://prism-0.23.0/lib/prism/dispatcher.rb:2142
  def visit_yield_node(node); end
end

# This visitor provides the ability to call Node#to_dot, which converts a
# subtree into a graphviz dot graph.
#
# source://prism-0.23.0/lib/prism/dot_visitor.rb:13
class Prism::DotVisitor < ::Prism::Visitor
  # Initialize a new dot visitor.
  #
  # @return [DotVisitor] a new instance of DotVisitor
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:105
  def initialize; end

  # The digraph that is being built.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:102
  def digraph; end

  # Convert this visitor into a graphviz dot graph string.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:110
  def to_dot; end

  # Visit a AliasGlobalVariableNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:115
  def visit_alias_global_variable_node(node); end

  # Visit a AliasMethodNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:140
  def visit_alias_method_node(node); end

  # Visit a AlternationPatternNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:165
  def visit_alternation_pattern_node(node); end

  # Visit a AndNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:190
  def visit_and_node(node); end

  # Visit a ArgumentsNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:215
  def visit_arguments_node(node); end

  # Visit a ArrayNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:245
  def visit_array_node(node); end

  # Visit a ArrayPatternNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:285
  def visit_array_pattern_node(node); end

  # Visit a AssocNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:347
  def visit_assoc_node(node); end

  # Visit a AssocSplatNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:374
  def visit_assoc_splat_node(node); end

  # Visit a BackReferenceReadNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:397
  def visit_back_reference_read_node(node); end

  # Visit a BeginNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:414
  def visit_begin_node(node); end

  # Visit a BlockArgumentNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:462
  def visit_block_argument_node(node); end

  # Visit a BlockLocalVariableNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:485
  def visit_block_local_variable_node(node); end

  # Visit a BlockNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:505
  def visit_block_node(node); end

  # Visit a BlockParameterNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:540
  def visit_block_parameter_node(node); end

  # Visit a BlockParametersNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:568
  def visit_block_parameters_node(node); end

  # Visit a BreakNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:611
  def visit_break_node(node); end

  # Visit a CallAndWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:634
  def visit_call_and_write_node(node); end

  # Visit a CallNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:680
  def visit_call_node(node); end

  # Visit a CallOperatorWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:738
  def visit_call_operator_write_node(node); end

  # Visit a CallOrWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:787
  def visit_call_or_write_node(node); end

  # Visit a CallTargetNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:833
  def visit_call_target_node(node); end

  # Visit a CapturePatternNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:863
  def visit_capture_pattern_node(node); end

  # Visit a CaseMatchNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:888
  def visit_case_match_node(node); end

  # Visit a CaseNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:933
  def visit_case_node(node); end

  # Visit a ClassNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:978
  def visit_class_node(node); end

  # Visit a ClassVariableAndWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1025
  def visit_class_variable_and_write_node(node); end

  # Visit a ClassVariableOperatorWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1052
  def visit_class_variable_operator_write_node(node); end

  # Visit a ClassVariableOrWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1082
  def visit_class_variable_or_write_node(node); end

  # Visit a ClassVariableReadNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1109
  def visit_class_variable_read_node(node); end

  # Visit a ClassVariableTargetNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1126
  def visit_class_variable_target_node(node); end

  # Visit a ClassVariableWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1143
  def visit_class_variable_write_node(node); end

  # Visit a ConstantAndWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1172
  def visit_constant_and_write_node(node); end

  # Visit a ConstantOperatorWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1199
  def visit_constant_operator_write_node(node); end

  # Visit a ConstantOrWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1229
  def visit_constant_or_write_node(node); end

  # Visit a ConstantPathAndWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1256
  def visit_constant_path_and_write_node(node); end

  # Visit a ConstantPathNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1281
  def visit_constant_path_node(node); end

  # Visit a ConstantPathOperatorWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1308
  def visit_constant_path_operator_write_node(node); end

  # Visit a ConstantPathOrWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1336
  def visit_constant_path_or_write_node(node); end

  # Visit a ConstantPathTargetNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1361
  def visit_constant_path_target_node(node); end

  # Visit a ConstantPathWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1388
  def visit_constant_path_write_node(node); end

  # Visit a ConstantReadNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1413
  def visit_constant_read_node(node); end

  # Visit a ConstantTargetNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1430
  def visit_constant_target_node(node); end

  # Visit a ConstantWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1447
  def visit_constant_write_node(node); end

  # Visit a DefNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1474
  def visit_def_node(node); end

  # Visit a DefinedNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1543
  def visit_defined_node(node); end

  # Visit a ElseNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1574
  def visit_else_node(node); end

  # Visit a EmbeddedStatementsNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1602
  def visit_embedded_statements_node(node); end

  # Visit a EmbeddedVariableNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1628
  def visit_embedded_variable_node(node); end

  # Visit a EnsureNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1649
  def visit_ensure_node(node); end

  # Visit a FalseNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1675
  def visit_false_node(node); end

  # Visit a FindPatternNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1689
  def visit_find_pattern_node(node); end

  # Visit a FlipFlopNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1740
  def visit_flip_flop_node(node); end

  # Visit a FloatNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1772
  def visit_float_node(node); end

  # Visit a ForNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1786
  def visit_for_node(node); end

  # Visit a ForwardingArgumentsNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1828
  def visit_forwarding_arguments_node(node); end

  # Visit a ForwardingParameterNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1842
  def visit_forwarding_parameter_node(node); end

  # Visit a ForwardingSuperNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1856
  def visit_forwarding_super_node(node); end

  # Visit a GlobalVariableAndWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1876
  def visit_global_variable_and_write_node(node); end

  # Visit a GlobalVariableOperatorWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1903
  def visit_global_variable_operator_write_node(node); end

  # Visit a GlobalVariableOrWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1933
  def visit_global_variable_or_write_node(node); end

  # Visit a GlobalVariableReadNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1960
  def visit_global_variable_read_node(node); end

  # Visit a GlobalVariableTargetNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1977
  def visit_global_variable_target_node(node); end

  # Visit a GlobalVariableWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:1994
  def visit_global_variable_write_node(node); end

  # Visit a HashNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2021
  def visit_hash_node(node); end

  # Visit a HashPatternNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2054
  def visit_hash_pattern_node(node); end

  # Visit a IfNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2103
  def visit_if_node(node); end

  # Visit a ImaginaryNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2148
  def visit_imaginary_node(node); end

  # Visit a ImplicitNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2166
  def visit_implicit_node(node); end

  # Visit a ImplicitRestNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2184
  def visit_implicit_rest_node(node); end

  # Visit a InNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2198
  def visit_in_node(node); end

  # Visit a IndexAndWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2230
  def visit_index_and_write_node(node); end

  # Visit a IndexOperatorWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2283
  def visit_index_operator_write_node(node); end

  # Visit a IndexOrWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2339
  def visit_index_or_write_node(node); end

  # Visit a IndexTargetNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2392
  def visit_index_target_node(node); end

  # Visit a InstanceVariableAndWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2431
  def visit_instance_variable_and_write_node(node); end

  # Visit a InstanceVariableOperatorWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2458
  def visit_instance_variable_operator_write_node(node); end

  # Visit a InstanceVariableOrWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2488
  def visit_instance_variable_or_write_node(node); end

  # Visit a InstanceVariableReadNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2515
  def visit_instance_variable_read_node(node); end

  # Visit a InstanceVariableTargetNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2532
  def visit_instance_variable_target_node(node); end

  # Visit a InstanceVariableWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2549
  def visit_instance_variable_write_node(node); end

  # Visit a IntegerNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2576
  def visit_integer_node(node); end

  # Visit a InterpolatedMatchLastLineNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2593
  def visit_interpolated_match_last_line_node(node); end

  # Visit a InterpolatedRegularExpressionNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2629
  def visit_interpolated_regular_expression_node(node); end

  # Visit a InterpolatedStringNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2665
  def visit_interpolated_string_node(node); end

  # Visit a InterpolatedSymbolNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2702
  def visit_interpolated_symbol_node(node); end

  # Visit a InterpolatedXStringNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2739
  def visit_interpolated_x_string_node(node); end

  # Visit a KeywordHashNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2772
  def visit_keyword_hash_node(node); end

  # Visit a KeywordRestParameterNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2802
  def visit_keyword_rest_parameter_node(node); end

  # Visit a LambdaNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2830
  def visit_lambda_node(node); end

  # Visit a LocalVariableAndWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2868
  def visit_local_variable_and_write_node(node); end

  # Visit a LocalVariableOperatorWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2898
  def visit_local_variable_operator_write_node(node); end

  # Visit a LocalVariableOrWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2931
  def visit_local_variable_or_write_node(node); end

  # Visit a LocalVariableReadNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2961
  def visit_local_variable_read_node(node); end

  # Visit a LocalVariableTargetNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:2981
  def visit_local_variable_target_node(node); end

  # Visit a LocalVariableWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3001
  def visit_local_variable_write_node(node); end

  # Visit a MatchLastLineNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3031
  def visit_match_last_line_node(node); end

  # Visit a MatchPredicateNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3060
  def visit_match_predicate_node(node); end

  # Visit a MatchRequiredNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3085
  def visit_match_required_node(node); end

  # Visit a MatchWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3110
  def visit_match_write_node(node); end

  # Visit a MissingNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3141
  def visit_missing_node(node); end

  # Visit a ModuleNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3155
  def visit_module_node(node); end

  # Visit a MultiTargetNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3191
  def visit_multi_target_node(node); end

  # Visit a MultiWriteNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3247
  def visit_multi_write_node(node); end

  # Visit a NextNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3310
  def visit_next_node(node); end

  # Visit a NilNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3333
  def visit_nil_node(node); end

  # Visit a NoKeywordsParameterNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3347
  def visit_no_keywords_parameter_node(node); end

  # Visit a NumberedParametersNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3367
  def visit_numbered_parameters_node(node); end

  # Visit a NumberedReferenceReadNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3384
  def visit_numbered_reference_read_node(node); end

  # Visit a OptionalKeywordParameterNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3401
  def visit_optional_keyword_parameter_node(node); end

  # Visit a OptionalParameterNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3428
  def visit_optional_parameter_node(node); end

  # Visit a OrNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3458
  def visit_or_node(node); end

  # Visit a ParametersNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3483
  def visit_parameters_node(node); end

  # Visit a ParenthesesNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3567
  def visit_parentheses_node(node); end

  # Visit a PinnedExpressionNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3593
  def visit_pinned_expression_node(node); end

  # Visit a PinnedVariableNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3620
  def visit_pinned_variable_node(node); end

  # Visit a PostExecutionNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3641
  def visit_post_execution_node(node); end

  # Visit a PreExecutionNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3670
  def visit_pre_execution_node(node); end

  # Visit a ProgramNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3699
  def visit_program_node(node); end

  # Visit a RangeNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3720
  def visit_range_node(node); end

  # Visit a RationalNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3752
  def visit_rational_node(node); end

  # Visit a RedoNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3770
  def visit_redo_node(node); end

  # Visit a RegularExpressionNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3784
  def visit_regular_expression_node(node); end

  # Visit a RequiredKeywordParameterNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3813
  def visit_required_keyword_parameter_node(node); end

  # Visit a RequiredParameterNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3836
  def visit_required_parameter_node(node); end

  # Visit a RescueModifierNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3856
  def visit_rescue_modifier_node(node); end

  # Visit a RescueNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3881
  def visit_rescue_node(node); end

  # Visit a RestParameterNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3934
  def visit_rest_parameter_node(node); end

  # Visit a RetryNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3962
  def visit_retry_node(node); end

  # Visit a ReturnNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3976
  def visit_return_node(node); end

  # Visit a SelfNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:3999
  def visit_self_node(node); end

  # Visit a SingletonClassNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4013
  def visit_singleton_class_node(node); end

  # Visit a SourceEncodingNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4049
  def visit_source_encoding_node(node); end

  # Visit a SourceFileNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4063
  def visit_source_file_node(node); end

  # Visit a SourceLineNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4080
  def visit_source_line_node(node); end

  # Visit a SplatNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4094
  def visit_splat_node(node); end

  # Visit a StatementsNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4117
  def visit_statements_node(node); end

  # Visit a StringNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4144
  def visit_string_node(node); end

  # Visit a SuperNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4177
  def visit_super_node(node); end

  # Visit a SymbolNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4216
  def visit_symbol_node(node); end

  # Visit a TrueNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4251
  def visit_true_node(node); end

  # Visit a UndefNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4265
  def visit_undef_node(node); end

  # Visit a UnlessNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4295
  def visit_unless_node(node); end

  # Visit a UntilNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4338
  def visit_until_node(node); end

  # Visit a WhenNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4373
  def visit_when_node(node); end

  # Visit a WhileNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4409
  def visit_while_node(node); end

  # Visit a XStringNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4444
  def visit_x_string_node(node); end

  # Visit a YieldNode node.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4473
  def visit_yield_node(node); end

  private

  # Inspect a node that has arguments_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4519
  def arguments_node_flags_inspect(node); end

  # Inspect a node that has array_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4527
  def array_node_flags_inspect(node); end

  # Inspect a node that has call_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4535
  def call_node_flags_inspect(node); end

  # Inspect a node that has encoding_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4546
  def encoding_flags_inspect(node); end

  # Inspect a node that has integer_base_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4555
  def integer_base_flags_inspect(node); end

  # Inspect a node that has keyword_hash_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4566
  def keyword_hash_node_flags_inspect(node); end

  # Inspect a location to display the start and end line and column numbers.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4513
  def location_inspect(location); end

  # Inspect a node that has loop_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4574
  def loop_flags_inspect(node); end

  # Generate a unique node ID for a node throughout the digraph.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4508
  def node_id(node); end

  # Inspect a node that has parameter_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4582
  def parameter_flags_inspect(node); end

  # Inspect a node that has range_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4590
  def range_flags_inspect(node); end

  # Inspect a node that has regular_expression_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4598
  def regular_expression_flags_inspect(node); end

  # Inspect a node that has string_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4616
  def string_flags_inspect(node); end

  # Inspect a node that has symbol_flags flags to display the flags as a
  # comma-separated list.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:4626
  def symbol_flags_inspect(node); end
end

# source://prism-0.23.0/lib/prism/dot_visitor.rb:58
class Prism::DotVisitor::Digraph
  # @return [Digraph] a new instance of Digraph
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:61
  def initialize; end

  # source://prism-0.23.0/lib/prism/dot_visitor.rb:75
  def edge(value); end

  # Returns the value of attribute edges.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:59
  def edges; end

  # source://prism-0.23.0/lib/prism/dot_visitor.rb:67
  def node(value); end

  # Returns the value of attribute nodes.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:59
  def nodes; end

  # source://prism-0.23.0/lib/prism/dot_visitor.rb:79
  def to_dot; end

  # source://prism-0.23.0/lib/prism/dot_visitor.rb:71
  def waypoint(value); end

  # Returns the value of attribute waypoints.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:59
  def waypoints; end
end

# source://prism-0.23.0/lib/prism/dot_visitor.rb:14
class Prism::DotVisitor::Field
  # @return [Field] a new instance of Field
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:17
  def initialize(name, value, port); end

  # Returns the value of attribute name.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:15
  def name; end

  # Returns the value of attribute port.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:15
  def port; end

  # source://prism-0.23.0/lib/prism/dot_visitor.rb:23
  def to_dot; end

  # Returns the value of attribute value.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:15
  def value; end
end

# source://prism-0.23.0/lib/prism/dot_visitor.rb:32
class Prism::DotVisitor::Table
  # @return [Table] a new instance of Table
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:35
  def initialize(name); end

  # source://prism-0.23.0/lib/prism/dot_visitor.rb:40
  def field(name, value = T.unsafe(nil), port: T.unsafe(nil)); end

  # Returns the value of attribute fields.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:33
  def fields; end

  # Returns the value of attribute name.
  #
  # source://prism-0.23.0/lib/prism/dot_visitor.rb:33
  def name; end

  # source://prism-0.23.0/lib/prism/dot_visitor.rb:44
  def to_dot; end
end

# Represents an `else` clause in a `case`, `if`, or `unless` statement.
#
#     if a then b else c end
#                 ^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:5746
class Prism::ElseNode < ::Prism::Node
  # def initialize: (Location else_keyword_loc, StatementsNode? statements, Location? end_keyword_loc, Location location) -> void
  #
  # @return [ElseNode] a new instance of ElseNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5757
  def initialize(else_keyword_loc, statements, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:5766
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5771
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5783
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5776
  def compact_child_nodes; end

  # def copy: (**params) -> ElseNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5788
  sig { params(params: T.untyped).returns(Prism::ElseNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5771
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { else_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:5801
  def deconstruct_keys(keys); end

  # def else_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5806
  sig { returns(String) }
  def else_keyword; end

  # attr_reader else_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:5748
  sig { returns(Prism::Location) }
  def else_keyword_loc; end

  # def end_keyword: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5811
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5754
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5816
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5751
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:5843
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:5853
    def type; end
  end
end

# EmbDocComment objects correspond to comments that are surrounded by =begin
# and =end.
#
# source://prism-0.23.0/lib/prism/parse_result.rb:290
class Prism::EmbDocComment < ::Prism::Comment
  # Returns a string representation of this comment.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:297
  def inspect; end

  # This can only be true for inline comments.
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:292
  def trailing?; end
end

# Represents an interpolated set of statements.
#
#     "foo #{bar}"
#          ^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:5862
class Prism::EmbeddedStatementsNode < ::Prism::Node
  # def initialize: (Location opening_loc, StatementsNode? statements, Location closing_loc, Location location) -> void
  #
  # @return [EmbeddedStatementsNode] a new instance of EmbeddedStatementsNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5873
  def initialize(opening_loc, statements, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:5882
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5887
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5927
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:5870
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5899
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5892
  def compact_child_nodes; end

  # def copy: (**params) -> EmbeddedStatementsNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5904
  sig { params(params: T.untyped).returns(Prism::EmbeddedStatementsNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5887
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { opening_loc: Location, statements: StatementsNode?, closing_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:5917
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5932
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:5922
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:5864
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:5867
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:5959
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:5969
    def type; end
  end
end

# Represents an interpolated variable.
#
#     "foo #@bar"
#          ^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:5978
class Prism::EmbeddedVariableNode < ::Prism::Node
  # def initialize: (Location operator_loc, Node variable, Location location) -> void
  #
  # @return [EmbeddedVariableNode] a new instance of EmbeddedVariableNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:5986
  def initialize(operator_loc, variable, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:5994
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5999
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6009
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6004
  def compact_child_nodes; end

  # def copy: (**params) -> EmbeddedVariableNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6014
  sig { params(params: T.untyped).returns(Prism::EmbeddedVariableNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:5999
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { operator_loc: Location, variable: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:6026
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6036
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6031
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:5980
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:6058
  def type; end

  # attr_reader variable: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:5983
  sig { returns(Prism::Node) }
  def variable; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:6068
    def type; end
  end
end

# Flags for nodes that have unescaped content.
#
# source://prism-0.23.0/lib/prism/node.rb:17758
module Prism::EncodingFlags; end

# internal bytes forced the encoding to binary
#
# source://prism-0.23.0/lib/prism/node.rb:17763
Prism::EncodingFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to UTF-8
#
# source://prism-0.23.0/lib/prism/node.rb:17760
Prism::EncodingFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

# Represents an `ensure` clause in a `begin` statement.
#
#     begin
#       foo
#     ensure
#     ^^^^^^
#       bar
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:6081
class Prism::EnsureNode < ::Prism::Node
  # def initialize: (Location ensure_keyword_loc, StatementsNode? statements, Location end_keyword_loc, Location location) -> void
  #
  # @return [EnsureNode] a new instance of EnsureNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6092
  def initialize(ensure_keyword_loc, statements, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:6101
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6106
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6118
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6111
  def compact_child_nodes; end

  # def copy: (**params) -> EnsureNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6123
  sig { params(params: T.untyped).returns(Prism::EnsureNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6106
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { ensure_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:6136
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6146
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:6089
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def ensure_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6141
  sig { returns(String) }
  def ensure_keyword; end

  # attr_reader ensure_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:6083
  sig { returns(Prism::Location) }
  def ensure_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6151
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:6086
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:6178
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:6188
    def type; end
  end
end

# Represents the use of the literal `false` keyword.
#
#     false
#     ^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:6197
class Prism::FalseNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [FalseNode] a new instance of FalseNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6199
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:6205
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6210
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6220
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6215
  def compact_child_nodes; end

  # def copy: (**params) -> FalseNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6225
  sig { params(params: T.untyped).returns(Prism::FalseNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6210
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:6235
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6240
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:6259
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:6269
    def type; end
  end
end

# Represents a find pattern in pattern matching.
#
#     foo in *bar, baz, *qux
#            ^^^^^^^^^^^^^^^
#
#     foo in [*bar, baz, *qux]
#            ^^^^^^^^^^^^^^^^^
#
#     foo in Foo(*bar, baz, *qux)
#            ^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:6284
class Prism::FindPatternNode < ::Prism::Node
  # def initialize: (Node? constant, Node left, Array[Node] requireds, Node right, Location? opening_loc, Location? closing_loc, Location location) -> void
  #
  # @return [FindPatternNode] a new instance of FindPatternNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6304
  def initialize(constant, left, requireds, right, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:6316
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6321
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:6367
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:6301
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6336
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6326
  def compact_child_nodes; end

  # attr_reader constant: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:6286
  sig { returns(T.nilable(Prism::Node)) }
  def constant; end

  # def copy: (**params) -> FindPatternNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6341
  sig { params(params: T.untyped).returns(Prism::FindPatternNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6321
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { constant: Node?, left: Node, requireds: Array[Node], right: Node, opening_loc: Location?, closing_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:6357
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6372
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:6289
  sig { returns(Prism::Node) }
  def left; end

  # def opening: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:6362
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:6298
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader requireds: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6292
  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  # attr_reader right: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:6295
  sig { returns(Prism::Node) }
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:6404
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:6414
    def type; end
  end
end

# Represents the use of the `..` or `...` operators to create flip flops.
#
#     baz if foo .. bar
#            ^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:6423
class Prism::FlipFlopNode < ::Prism::Node
  # def initialize: (Integer flags, Node? left, Node? right, Location operator_loc, Location location) -> void
  #
  # @return [FlipFlopNode] a new instance of FlipFlopNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6438
  def initialize(flags, left, right, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:6448
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6453
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6466
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6458
  def compact_child_nodes; end

  # def copy: (**params) -> FlipFlopNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6471
  sig { params(params: T.untyped).returns(Prism::FlipFlopNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6453
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, left: Node?, right: Node?, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:6485
  def deconstruct_keys(keys); end

  # def exclude_end?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6490
  sig { returns(T::Boolean) }
  def exclude_end?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6500
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:6429
  sig { returns(T.nilable(Prism::Node)) }
  def left; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6495
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:6435
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader right: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:6432
  sig { returns(T.nilable(Prism::Node)) }
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:6534
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:6425
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:6544
    def type; end
  end
end

# Represents a floating point number literal.
#
#     1.0
#     ^^^
#
# source://prism-0.23.0/lib/prism/node.rb:6553
class Prism::FloatNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [FloatNode] a new instance of FloatNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6555
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:6561
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6566
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6576
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6571
  def compact_child_nodes; end

  # def copy: (**params) -> FloatNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6581
  sig { params(params: T.untyped).returns(Prism::FloatNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6566
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:6591
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6596
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:6615
  def type; end

  # Returns the value of the node as a Ruby Float.
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:62
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:6625
    def type; end
  end
end

# Represents the use of the `for` keyword.
#
#     for i in a end
#     ^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:6634
class Prism::ForNode < ::Prism::Node
  # def initialize: (Node index, Node collection, StatementsNode? statements, Location for_keyword_loc, Location in_keyword_loc, Location? do_keyword_loc, Location end_keyword_loc, Location location) -> void
  #
  # @return [ForNode] a new instance of ForNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6657
  def initialize(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:6670
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6675
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # attr_reader collection: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:6639
  sig { returns(Prism::Node) }
  def collection; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6689
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6680
  def compact_child_nodes; end

  # def copy: (**params) -> ForNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6694
  sig { params(params: T.untyped).returns(Prism::ForNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6675
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { index: Node, collection: Node, statements: StatementsNode?, for_keyword_loc: Location, in_keyword_loc: Location, do_keyword_loc: Location?, end_keyword_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:6711
  def deconstruct_keys(keys); end

  # def do_keyword: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:6726
  sig { returns(T.nilable(String)) }
  def do_keyword; end

  # attr_reader do_keyword_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:6651
  sig { returns(T.nilable(Prism::Location)) }
  def do_keyword_loc; end

  # def end_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6731
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:6654
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def for_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6716
  sig { returns(String) }
  def for_keyword; end

  # attr_reader for_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:6645
  sig { returns(Prism::Location) }
  def for_keyword_loc; end

  # def in_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6721
  sig { returns(String) }
  def in_keyword; end

  # attr_reader in_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:6648
  sig { returns(Prism::Location) }
  def in_keyword_loc; end

  # attr_reader index: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:6636
  sig { returns(Prism::Node) }
  def index; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6736
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:6642
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:6769
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:6779
    def type; end
  end
end

# Represents forwarding all arguments to this method to another method.
#
#     def foo(...)
#       bar(...)
#           ^^^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:6790
class Prism::ForwardingArgumentsNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [ForwardingArgumentsNode] a new instance of ForwardingArgumentsNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6792
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:6798
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6803
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6813
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6808
  def compact_child_nodes; end

  # def copy: (**params) -> ForwardingArgumentsNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6818
  sig { params(params: T.untyped).returns(Prism::ForwardingArgumentsNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6803
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:6828
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6833
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:6852
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:6862
    def type; end
  end
end

# Represents the use of the forwarding parameter in a method, block, or lambda declaration.
#
#     def foo(...)
#             ^^^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:6872
class Prism::ForwardingParameterNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [ForwardingParameterNode] a new instance of ForwardingParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6874
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:6880
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6885
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6895
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6890
  def compact_child_nodes; end

  # def copy: (**params) -> ForwardingParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6900
  sig { params(params: T.untyped).returns(Prism::ForwardingParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6885
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:6910
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:6915
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:6934
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:6944
    def type; end
  end
end

# Represents the use of the `super` keyword without parentheses or arguments.
#
#     super
#     ^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:6953
class Prism::ForwardingSuperNode < ::Prism::Node
  # def initialize: (BlockNode? block, Location location) -> void
  #
  # @return [ForwardingSuperNode] a new instance of ForwardingSuperNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6958
  def initialize(block, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:6965
  def accept(visitor); end

  # attr_reader block: BlockNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:6955
  sig { returns(T.nilable(Prism::BlockNode)) }
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6970
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6982
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6975
  def compact_child_nodes; end

  # def copy: (**params) -> ForwardingSuperNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:6987
  sig { params(params: T.untyped).returns(Prism::ForwardingSuperNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:6970
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { block: BlockNode?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:6998
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7003
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7028
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:7038
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a global variable.
#
#     $target &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:7047
class Prism::GlobalVariableAndWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Node value, Location location) -> void
  #
  # @return [GlobalVariableAndWriteNode] a new instance of GlobalVariableAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7061
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:7071
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7076
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7086
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7081
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7091
  sig { params(params: T.untyped).returns(Prism::GlobalVariableAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7076
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:7105
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7115
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7049
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:7052
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7110
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:7055
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7139
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:7058
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:7149
    def type; end
  end
end

# Represents assigning to a global variable using an operator that isn't `=`.
#
#     $target += value
#     ^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:7158
class Prism::GlobalVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Node value, Symbol operator, Location location) -> void
  #
  # @return [GlobalVariableOperatorWriteNode] a new instance of GlobalVariableOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7175
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:7186
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7191
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7201
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7196
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7206
  sig { params(params: T.untyped).returns(Prism::GlobalVariableOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7191
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:7221
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7226
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7160
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:7163
  sig { returns(Prism::Location) }
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7172
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:7166
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7251
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:7169
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:7261
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a global variable.
#
#     $target ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:7270
class Prism::GlobalVariableOrWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Node value, Location location) -> void
  #
  # @return [GlobalVariableOrWriteNode] a new instance of GlobalVariableOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7284
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:7294
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7299
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7309
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7304
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7314
  sig { params(params: T.untyped).returns(Prism::GlobalVariableOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7299
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:7328
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7338
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7272
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:7275
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7333
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:7278
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7362
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:7281
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:7372
    def type; end
  end
end

# Represents referencing a global variable.
#
#     $foo
#     ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:7381
class Prism::GlobalVariableReadNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [GlobalVariableReadNode] a new instance of GlobalVariableReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7390
  def initialize(name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:7397
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7402
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7412
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7407
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7417
  sig { params(params: T.untyped).returns(Prism::GlobalVariableReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7402
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:7428
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7433
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the global variable, which is a `$` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifier). Alternatively, it can be one of the special global variables designated by a symbol.
  #
  #     $foo   # name `:$foo`
  #
  #     $_Test # name `:$_Test`
  #
  # source://prism-0.23.0/lib/prism/node.rb:7387
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7453
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:7463
    def type; end
  end
end

# Represents writing to a global variable in a context that doesn't have an explicit value.
#
#     $foo, $bar = baz
#     ^^^^  ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:7472
class Prism::GlobalVariableTargetNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [GlobalVariableTargetNode] a new instance of GlobalVariableTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7477
  def initialize(name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:7484
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7489
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7499
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7494
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7504
  sig { params(params: T.untyped).returns(Prism::GlobalVariableTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7489
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:7515
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7520
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7474
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7540
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:7550
    def type; end
  end
end

# Represents writing to a global variable.
#
#     $foo = 1
#     ^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:7559
class Prism::GlobalVariableWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Node value, Location operator_loc, Location location) -> void
  #
  # @return [GlobalVariableWriteNode] a new instance of GlobalVariableWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7573
  def initialize(name, name_loc, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:7583
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7588
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7598
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7593
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7603
  sig { params(params: T.untyped).returns(Prism::GlobalVariableWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7588
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:7617
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7627
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7561
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:7564
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7622
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:7570
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7651
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:7567
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:7661
    def type; end
  end
end

# Represents a hash literal.
#
#     { a => b }
#     ^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:7670
class Prism::HashNode < ::Prism::Node
  # def initialize: (Location opening_loc, Array[Node] elements, Location closing_loc, Location location) -> void
  #
  # @return [HashNode] a new instance of HashNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7693
  def initialize(opening_loc, elements, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:7702
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7707
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7745
  sig { returns(String) }
  def closing; end

  # The location of the closing brace.
  #
  #     { a => b }
  #              ^
  #
  # source://prism-0.23.0/lib/prism/node.rb:7690
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7717
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7712
  def compact_child_nodes; end

  # def copy: (**params) -> HashNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7722
  sig { params(params: T.untyped).returns(Prism::HashNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7707
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { opening_loc: Location, elements: Array[Node], closing_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:7735
  def deconstruct_keys(keys); end

  # The elements of the hash. These can be either `AssocNode`s or `AssocSplatNode`s.
  #
  #     { a: b }
  #       ^^^^
  #
  #     { **foo }
  #       ^^^^^
  #
  # source://prism-0.23.0/lib/prism/node.rb:7684
  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7750
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7740
  sig { returns(String) }
  def opening; end

  # The location of the opening brace.
  #
  #     { a => b }
  #     ^
  #
  # source://prism-0.23.0/lib/prism/node.rb:7675
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7772
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:7782
    def type; end
  end
end

# Represents a hash pattern in pattern matching.
#
#     foo => { a: 1, b: 2 }
#            ^^^^^^^^^^^^^^
#
#     foo => { a: 1, b: 2, **c }
#            ^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:7794
class Prism::HashPatternNode < ::Prism::Node
  # def initialize: (Node? constant, Array[Node] elements, Node? rest, Location? opening_loc, Location? closing_loc, Location location) -> void
  #
  # @return [HashPatternNode] a new instance of HashPatternNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7811
  def initialize(constant, elements, rest, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:7822
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7827
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:7871
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:7808
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7841
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7832
  def compact_child_nodes; end

  # attr_reader constant: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:7796
  sig { returns(T.nilable(Prism::Node)) }
  def constant; end

  # def copy: (**params) -> HashPatternNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7846
  sig { params(params: T.untyped).returns(Prism::HashPatternNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7827
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { constant: Node?, elements: Array[Node], rest: Node?, opening_loc: Location?, closing_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:7861
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7799
  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:7876
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:7866
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:7805
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader rest: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:7802
  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:7910
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:7920
    def type; end
  end
end

# source://prism-0.23.0/lib/prism/node_ext.rb:35
module Prism::HeredocQuery
  # Returns true if this node was represented as a heredoc in the source code.
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:37
  def heredoc?; end
end

# Represents the use of the `if` keyword, either in the block form or the modifier form.
#
#     bar if foo
#     ^^^^^^^^^^
#
#     if foo then bar end
#     ^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:7932
class Prism::IfNode < ::Prism::Node
  # def initialize: (Location? if_keyword_loc, Node predicate, Location? then_keyword_loc, StatementsNode? statements, Node? consequent, Location? end_keyword_loc, Location location) -> void
  #
  # @return [IfNode] a new instance of IfNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7952
  def initialize(if_keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:7964
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7973
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7987
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7978
  def compact_child_nodes; end

  # attr_reader consequent: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:7946
  sig { returns(T.nilable(Prism::Node)) }
  def consequent; end

  # def copy: (**params) -> IfNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:7992
  sig { params(params: T.untyped).returns(Prism::IfNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:7973
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { if_keyword_loc: Location?, predicate: Node, then_keyword_loc: Location?, statements: StatementsNode?, consequent: Node?, end_keyword_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:8008
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8023
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:7949
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  # def if_keyword: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8013
  sig { returns(T.nilable(String)) }
  def if_keyword; end

  # attr_reader if_keyword_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:7934
  sig { returns(T.nilable(Prism::Location)) }
  def if_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8028
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader predicate: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:7937
  sig { returns(Prism::Node) }
  def predicate; end

  # source://prism-0.23.0/lib/prism/node.rb:7968
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:7943
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # def then_keyword: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8018
  sig { returns(T.nilable(String)) }
  def then_keyword; end

  # attr_reader then_keyword_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:7940
  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:8064
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:8074
    def type; end
  end
end

# Represents an imaginary number literal.
#
#     1.0i
#     ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:8083
class Prism::ImaginaryNode < ::Prism::Node
  # def initialize: (Node numeric, Location location) -> void
  #
  # @return [ImaginaryNode] a new instance of ImaginaryNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8088
  def initialize(numeric, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:8095
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8100
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8110
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8105
  def compact_child_nodes; end

  # def copy: (**params) -> ImaginaryNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8115
  sig { params(params: T.untyped).returns(Prism::ImaginaryNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8100
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { numeric: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:8126
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8131
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader numeric: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:8085
  sig { returns(Prism::Node) }
  def numeric; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:8152
  def type; end

  # Returns the value of the node as a Ruby Complex.
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:69
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:8162
    def type; end
  end
end

# Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.
#
#     { foo: }
#       ^^^^
#
#     { Foo: }
#       ^^^^
#
#     foo in { bar: }
#              ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:8177
class Prism::ImplicitNode < ::Prism::Node
  # def initialize: (Node value, Location location) -> void
  #
  # @return [ImplicitNode] a new instance of ImplicitNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8182
  def initialize(value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:8189
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8194
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8204
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8199
  def compact_child_nodes; end

  # def copy: (**params) -> ImplicitNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8209
  sig { params(params: T.untyped).returns(Prism::ImplicitNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8194
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:8220
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8225
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:8246
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:8179
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:8256
    def type; end
  end
end

# Represents using a trailing comma to indicate an implicit rest parameter.
#
#     foo { |bar,| }
#               ^
#
#     foo in [bar,]
#                ^
#
#     for foo, in bar do end
#            ^
#
#     foo, = bar
#        ^
#
# source://prism-0.23.0/lib/prism/node.rb:8274
class Prism::ImplicitRestNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [ImplicitRestNode] a new instance of ImplicitRestNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8276
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:8282
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8287
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8297
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8292
  def compact_child_nodes; end

  # def copy: (**params) -> ImplicitRestNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8302
  sig { params(params: T.untyped).returns(Prism::ImplicitRestNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8287
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:8312
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8317
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:8336
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:8346
    def type; end
  end
end

# Represents the use of the `in` keyword in a case statement.
#
#     case a; in b then c end
#             ^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:8355
class Prism::InNode < ::Prism::Node
  # def initialize: (Node pattern, StatementsNode? statements, Location in_loc, Location? then_loc, Location location) -> void
  #
  # @return [InNode] a new instance of InNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8369
  def initialize(pattern, statements, in_loc, then_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:8379
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8384
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8397
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8389
  def compact_child_nodes; end

  # def copy: (**params) -> InNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8402
  sig { params(params: T.untyped).returns(Prism::InNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8384
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { pattern: Node, statements: StatementsNode?, in_loc: Location, then_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:8416
  def deconstruct_keys(keys); end

  # def in: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8421
  sig { returns(String) }
  def in; end

  # attr_reader in_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:8363
  sig { returns(Prism::Location) }
  def in_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8431
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader pattern: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:8357
  sig { returns(Prism::Node) }
  def pattern; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8360
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # def then: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8426
  sig { returns(T.nilable(String)) }
  def then; end

  # attr_reader then_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8366
  sig { returns(T.nilable(Prism::Location)) }
  def then_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:8460
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:8470
    def type; end
  end
end

# Represents the use of the `&&=` operator on a call to the `[]` method.
#
#     foo.bar[baz] &&= value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:8479
class Prism::IndexAndWriteNode < ::Prism::Node
  # def initialize: (Integer flags, Node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, Node? block, Location operator_loc, Node value, Location location) -> void
  #
  # @return [IndexAndWriteNode] a new instance of IndexAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8509
  def initialize(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:8524
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8494
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8583
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # attr_reader block: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8500
  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8593
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8488
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8529
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8603
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:8497
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8544
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8534
  def compact_child_nodes; end

  # def copy: (**params) -> IndexAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8549
  sig { params(params: T.untyped).returns(Prism::IndexAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8529
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:8568
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8588
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8613
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8598
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:8491
  sig { returns(Prism::Location) }
  def opening_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8608
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:8503
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader receiver: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8485
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8573
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:8658
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:8506
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8578
  sig { returns(T::Boolean) }
  def variable_call?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:8481
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:8668
    def type; end
  end
end

# Represents the use of an assignment operator on a call to `[]`.
#
#     foo.bar[baz] += value
#     ^^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:8677
class Prism::IndexOperatorWriteNode < ::Prism::Node
  # def initialize: (Integer flags, Node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, Node? block, Symbol operator, Location operator_loc, Node value, Location location) -> void
  #
  # @return [IndexOperatorWriteNode] a new instance of IndexOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8710
  def initialize(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:8726
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8692
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8786
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # attr_reader block: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8698
  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8796
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8686
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8731
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8806
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:8695
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8746
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8736
  def compact_child_nodes; end

  # def copy: (**params) -> IndexOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8751
  sig { params(params: T.untyped).returns(Prism::IndexOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8731
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, operator: Symbol, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:8771
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8791
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8811
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8801
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:8689
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:8701
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:8704
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader receiver: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8683
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8776
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:8857
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:8707
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8781
  sig { returns(T::Boolean) }
  def variable_call?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:8679
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:8867
    def type; end
  end
end

# Represents the use of the `||=` operator on a call to `[]`.
#
#     foo.bar[baz] ||= value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:8876
class Prism::IndexOrWriteNode < ::Prism::Node
  # def initialize: (Integer flags, Node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, Node? block, Location operator_loc, Node value, Location location) -> void
  #
  # @return [IndexOrWriteNode] a new instance of IndexOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8906
  def initialize(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:8921
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8891
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8980
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # attr_reader block: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8897
  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8990
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8885
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8926
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9000
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:8894
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8941
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8931
  def compact_child_nodes; end

  # def copy: (**params) -> IndexOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:8946
  sig { params(params: T.untyped).returns(Prism::IndexOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8926
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:8965
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8985
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9010
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:8995
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:8888
  sig { returns(Prism::Location) }
  def opening_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9005
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:8900
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader receiver: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:8882
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8970
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9055
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:8903
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:8975
  sig { returns(T::Boolean) }
  def variable_call?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:8878
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:9065
    def type; end
  end
end

# Represents assigning to an index.
#
#     foo[bar], = 1
#     ^^^^^^^^
#
#     begin
#     rescue => foo[bar]
#               ^^^^^^^^
#     end
#
#     for foo[bar] in baz do end
#         ^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:9082
class Prism::IndexTargetNode < ::Prism::Node
  # def initialize: (Integer flags, Node receiver, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, Node? block, Location location) -> void
  #
  # @return [IndexTargetNode] a new instance of IndexTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9103
  def initialize(flags, receiver, opening_loc, arguments, closing_loc, block, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:9115
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:9094
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9170
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # attr_reader block: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:9100
  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9120
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9185
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:9097
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9134
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9125
  def compact_child_nodes; end

  # def copy: (**params) -> IndexTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9139
  sig { params(params: T.untyped).returns(Prism::IndexTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9120
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, receiver: Node, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:9155
  def deconstruct_keys(keys); end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9175
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9190
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9180
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:9091
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader receiver: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:9088
  sig { returns(Prism::Node) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9160
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9227
  def type; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9165
  sig { returns(T::Boolean) }
  def variable_call?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:9084
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:9237
    def type; end
  end
end

# InlineComment objects are the most common. They correspond to comments in
# the source file like this one that start with #.
#
# source://prism-0.23.0/lib/prism/parse_result.rb:275
class Prism::InlineComment < ::Prism::Comment
  # Returns a string representation of this comment.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:283
  def inspect; end

  # Returns true if this comment happens on the same line as other code and
  # false if the comment is by itself.
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:278
  sig { override.returns(T::Boolean) }
  def trailing?; end
end

# Represents the use of the `&&=` operator for assignment to an instance variable.
#
#     @target &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:9246
class Prism::InstanceVariableAndWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Node value, Location location) -> void
  #
  # @return [InstanceVariableAndWriteNode] a new instance of InstanceVariableAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9260
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:9270
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9275
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9285
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9280
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9290
  sig { params(params: T.untyped).returns(Prism::InstanceVariableAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9275
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:9304
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9314
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9248
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:9251
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9309
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:9254
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9338
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:9257
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:9348
    def type; end
  end
end

# Represents assigning to an instance variable using an operator that isn't `=`.
#
#     @target += value
#     ^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:9357
class Prism::InstanceVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Node value, Symbol operator, Location location) -> void
  #
  # @return [InstanceVariableOperatorWriteNode] a new instance of InstanceVariableOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9374
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:9385
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9390
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9400
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9395
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9405
  sig { params(params: T.untyped).returns(Prism::InstanceVariableOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9390
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:9420
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9425
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9359
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:9362
  sig { returns(Prism::Location) }
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9371
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:9365
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9450
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:9368
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:9460
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to an instance variable.
#
#     @target ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:9469
class Prism::InstanceVariableOrWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Location operator_loc, Node value, Location location) -> void
  #
  # @return [InstanceVariableOrWriteNode] a new instance of InstanceVariableOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9483
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:9493
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9498
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9508
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9503
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9513
  sig { params(params: T.untyped).returns(Prism::InstanceVariableOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9498
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:9527
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9537
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9471
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:9474
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9532
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:9477
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9561
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:9480
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:9571
    def type; end
  end
end

# Represents referencing an instance variable.
#
#     @foo
#     ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:9580
class Prism::InstanceVariableReadNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [InstanceVariableReadNode] a new instance of InstanceVariableReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9589
  def initialize(name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:9596
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9601
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9611
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9606
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9616
  sig { params(params: T.untyped).returns(Prism::InstanceVariableReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9601
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:9627
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9632
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the instance variable, which is a `@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     @x     # name `:@x`
  #
  #     @_test # name `:@_test`
  #
  # source://prism-0.23.0/lib/prism/node.rb:9586
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9652
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:9662
    def type; end
  end
end

# Represents writing to an instance variable in a context that doesn't have an explicit value.
#
#     @foo, @bar = baz
#     ^^^^  ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:9671
class Prism::InstanceVariableTargetNode < ::Prism::Node
  # def initialize: (Symbol name, Location location) -> void
  #
  # @return [InstanceVariableTargetNode] a new instance of InstanceVariableTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9676
  def initialize(name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:9683
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9688
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9698
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9693
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9703
  sig { params(params: T.untyped).returns(Prism::InstanceVariableTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9688
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:9714
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9719
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9673
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9739
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:9749
    def type; end
  end
end

# Represents writing to an instance variable.
#
#     @foo = 1
#     ^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:9758
class Prism::InstanceVariableWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Location name_loc, Node value, Location operator_loc, Location location) -> void
  #
  # @return [InstanceVariableWriteNode] a new instance of InstanceVariableWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9772
  def initialize(name, name_loc, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:9782
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9787
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9797
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9792
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9802
  sig { params(params: T.untyped).returns(Prism::InstanceVariableWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9787
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:9816
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9826
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9760
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:9763
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9821
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:9769
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9850
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:9766
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:9860
    def type; end
  end
end

# Flags for integer nodes that correspond to the base of the integer.
#
# source://prism-0.23.0/lib/prism/node.rb:17767
module Prism::IntegerBaseFlags; end

# 0b prefix
#
# source://prism-0.23.0/lib/prism/node.rb:17769
Prism::IntegerBaseFlags::BINARY = T.let(T.unsafe(nil), Integer)

# 0d or no prefix
#
# source://prism-0.23.0/lib/prism/node.rb:17772
Prism::IntegerBaseFlags::DECIMAL = T.let(T.unsafe(nil), Integer)

# 0x prefix
#
# source://prism-0.23.0/lib/prism/node.rb:17778
Prism::IntegerBaseFlags::HEXADECIMAL = T.let(T.unsafe(nil), Integer)

# 0o or 0 prefix
#
# source://prism-0.23.0/lib/prism/node.rb:17775
Prism::IntegerBaseFlags::OCTAL = T.let(T.unsafe(nil), Integer)

# Represents an integer number literal.
#
#     1
#     ^
#
# source://prism-0.23.0/lib/prism/node.rb:9869
class Prism::IntegerNode < ::Prism::Node
  # def initialize: (Integer flags, Location location) -> void
  #
  # @return [IntegerNode] a new instance of IntegerNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9875
  def initialize(flags, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:9882
  def accept(visitor); end

  # def binary?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9918
  sig { returns(T::Boolean) }
  def binary?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9887
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9897
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9892
  def compact_child_nodes; end

  # def copy: (**params) -> IntegerNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9902
  sig { params(params: T.untyped).returns(Prism::IntegerNode) }
  def copy(**params); end

  # def decimal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9923
  sig { returns(T::Boolean) }
  def decimal?; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9887
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:9913
  def deconstruct_keys(keys); end

  # def hexadecimal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9933
  sig { returns(T::Boolean) }
  def hexadecimal?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:9938
  def inspect(inspector = T.unsafe(nil)); end

  # def octal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9928
  sig { returns(T::Boolean) }
  def octal?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:9959
  def type; end

  # Returns the value of the node as a Ruby Integer.
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:76
  def value; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:9871
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:9969
    def type; end
  end
end

# Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.
#
#     if /foo #{bar} baz/ then end
#        ^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:9978
class Prism::InterpolatedMatchLastLineNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # def initialize: (Integer flags, Location opening_loc, Array[Node] parts, Location closing_loc, Location location) -> void
  #
  # @return [InterpolatedMatchLastLineNode] a new instance of InterpolatedMatchLastLineNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:9993
  def initialize(flags, opening_loc, parts, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:10003
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10072
  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10013
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10107
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:9990
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10023
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10018
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedMatchLastLineNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10028
  sig { params(params: T.untyped).returns(Prism::InterpolatedMatchLastLineNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10013
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location, parts: Array[Node], closing_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:10042
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10067
  sig { returns(T::Boolean) }
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10052
  sig { returns(T::Boolean) }
  def extended?; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10092
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10097
  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10087
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10047
  sig { returns(T::Boolean) }
  def ignore_case?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10112
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10057
  sig { returns(T::Boolean) }
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10062
  sig { returns(T::Boolean) }
  def once?; end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10102
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:9984
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:9987
  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  # source://prism-0.23.0/lib/prism/node.rb:10007
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:10136
  def type; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10082
  sig { returns(T::Boolean) }
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10077
  sig { returns(T::Boolean) }
  def windows_31j?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:9980
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:10146
    def type; end
  end
end

# Represents a regular expression literal that contains interpolation.
#
#     /foo #{bar} baz/
#     ^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:10155
class Prism::InterpolatedRegularExpressionNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # def initialize: (Integer flags, Location opening_loc, Array[Node] parts, Location closing_loc, Location location) -> void
  #
  # @return [InterpolatedRegularExpressionNode] a new instance of InterpolatedRegularExpressionNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10170
  def initialize(flags, opening_loc, parts, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:10180
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10249
  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10190
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10284
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:10167
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10200
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10195
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedRegularExpressionNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10205
  sig { params(params: T.untyped).returns(Prism::InterpolatedRegularExpressionNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10190
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location, parts: Array[Node], closing_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:10219
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10244
  sig { returns(T::Boolean) }
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10229
  sig { returns(T::Boolean) }
  def extended?; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10269
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10274
  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10264
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10224
  sig { returns(T::Boolean) }
  def ignore_case?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10289
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10234
  sig { returns(T::Boolean) }
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10239
  sig { returns(T::Boolean) }
  def once?; end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10279
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:10161
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10164
  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  # source://prism-0.23.0/lib/prism/node.rb:10184
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:10313
  def type; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10259
  sig { returns(T::Boolean) }
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10254
  sig { returns(T::Boolean) }
  def windows_31j?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:10157
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:10323
    def type; end
  end
end

# Represents a string literal that contains interpolation.
#
#     "foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:10332
class Prism::InterpolatedStringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  # def initialize: (Location? opening_loc, Array[Node] parts, Location? closing_loc, Location location) -> void
  #
  # @return [InterpolatedStringNode] a new instance of InterpolatedStringNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10343
  def initialize(opening_loc, parts, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:10352
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10362
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:10400
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:10340
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10372
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10367
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedStringNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10377
  sig { params(params: T.untyped).returns(Prism::InterpolatedStringNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10362
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { opening_loc: Location?, parts: Array[Node], closing_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:10390
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10405
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:10395
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:10334
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10337
  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  # source://prism-0.23.0/lib/prism/node.rb:10356
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:10427
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:10437
    def type; end
  end
end

# Represents a symbol literal that contains interpolation.
#
#     :"foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:10446
class Prism::InterpolatedSymbolNode < ::Prism::Node
  # def initialize: (Location? opening_loc, Array[Node] parts, Location? closing_loc, Location location) -> void
  #
  # @return [InterpolatedSymbolNode] a new instance of InterpolatedSymbolNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10457
  def initialize(opening_loc, parts, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:10466
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10476
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:10514
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:10454
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10486
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10481
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedSymbolNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10491
  sig { params(params: T.untyped).returns(Prism::InterpolatedSymbolNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10476
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { opening_loc: Location?, parts: Array[Node], closing_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:10504
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10519
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:10509
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:10448
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10451
  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  # source://prism-0.23.0/lib/prism/node.rb:10470
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:10541
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:10551
    def type; end
  end
end

# Represents an xstring literal that contains interpolation.
#
#     `foo #{bar} baz`
#     ^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:10560
class Prism::InterpolatedXStringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  # def initialize: (Location opening_loc, Array[Node] parts, Location closing_loc, Location location) -> void
  #
  # @return [InterpolatedXStringNode] a new instance of InterpolatedXStringNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10571
  def initialize(opening_loc, parts, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:10580
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10590
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10628
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:10568
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10600
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10595
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedXStringNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10605
  sig { params(params: T.untyped).returns(Prism::InterpolatedXStringNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10590
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { opening_loc: Location, parts: Array[Node], closing_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:10618
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10633
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10623
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:10562
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10565
  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  # source://prism-0.23.0/lib/prism/node.rb:10584
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:10655
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:10665
    def type; end
  end
end

# Represents a hash literal without opening and closing braces.
#
#     foo(a: b)
#         ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:10674
class Prism::KeywordHashNode < ::Prism::Node
  # def initialize: (Integer flags, Array[Node] elements, Location location) -> void
  #
  # @return [KeywordHashNode] a new instance of KeywordHashNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10683
  def initialize(flags, elements, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:10691
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10696
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10706
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10701
  def compact_child_nodes; end

  # def copy: (**params) -> KeywordHashNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10711
  sig { params(params: T.untyped).returns(Prism::KeywordHashNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10696
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, elements: Array[Node], location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:10723
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10680
  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10733
  def inspect(inspector = T.unsafe(nil)); end

  # def symbol_keys?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10728
  sig { returns(T::Boolean) }
  def symbol_keys?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:10755
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:10676
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:10765
    def type; end
  end
end

# Flags for keyword hash nodes.
#
# source://prism-0.23.0/lib/prism/node.rb:17782
module Prism::KeywordHashNodeFlags; end

# a keyword hash which only has `AssocNode` elements all with symbol keys, which means the elements can be treated as keyword arguments
#
# source://prism-0.23.0/lib/prism/node.rb:17784
Prism::KeywordHashNodeFlags::SYMBOL_KEYS = T.let(T.unsafe(nil), Integer)

# Represents a keyword rest parameter to a method, block, or lambda definition.
#
#     def a(**b)
#           ^^^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:10775
class Prism::KeywordRestParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol? name, Location? name_loc, Location operator_loc, Location location) -> void
  #
  # @return [KeywordRestParameterNode] a new instance of KeywordRestParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10790
  def initialize(flags, name, name_loc, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:10800
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10805
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10815
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10810
  def compact_child_nodes; end

  # def copy: (**params) -> KeywordRestParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10820
  sig { params(params: T.untyped).returns(Prism::KeywordRestParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10805
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:10834
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10849
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol?
  #
  # source://prism-0.23.0/lib/prism/node.rb:10781
  sig { returns(T.nilable(Symbol)) }
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:10784
  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10844
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:10787
  sig { returns(Prism::Location) }
  def operator_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10839
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:10877
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:10777
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:10887
    def type; end
  end
end

# Represents using a lambda literal (not the lambda method call).
#
#     ->(value) { value * 2 }
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:10896
class Prism::LambdaNode < ::Prism::Node
  # def initialize: (Array[Symbol] locals, Location operator_loc, Location opening_loc, Location closing_loc, Node? parameters, Node? body, Location location) -> void
  #
  # @return [LambdaNode] a new instance of LambdaNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10916
  def initialize(locals, operator_loc, opening_loc, closing_loc, parameters, body, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:10928
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:10913
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10933
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10982
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:10907
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10946
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10938
  def compact_child_nodes; end

  # def copy: (**params) -> LambdaNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:10951
  sig { params(params: T.untyped).returns(Prism::LambdaNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10933
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { locals: Array[Symbol], operator_loc: Location, opening_loc: Location, closing_loc: Location, parameters: Node?, body: Node?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:10967
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10987
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism-0.23.0/lib/prism/node.rb:10898
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10977
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:10904
  sig { returns(Prism::Location) }
  def opening_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:10972
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:10901
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader parameters: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:10910
  sig { returns(T.nilable(Prism::Node)) }
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11022
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:11032
    def type; end
  end
end

# This class is responsible for lexing the source using prism and then
# converting those tokens to be compatible with Ripper. In the vast majority
# of cases, this is a one-to-one mapping of the token type. Everything else
# generally lines up. However, there are a few cases that require special
# handling.
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:12
class Prism::LexCompat
  # @return [LexCompat] a new instance of LexCompat
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:600
  def initialize(source, **options); end

  # Returns the value of attribute options.
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:598
  def options; end

  # source://prism-0.23.0/lib/prism/lex_compat.rb:605
  def result; end

  # Returns the value of attribute source.
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:598
  def source; end
end

# Ripper doesn't include the rest of the token in the event, so we need to
# trim it down to just the content on the first line when comparing.
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:211
class Prism::LexCompat::EndContentToken < ::Prism::LexCompat::Token
  # source://prism-0.23.0/lib/prism/lex_compat.rb:212
  def ==(other); end
end

# A heredoc in this case is a list of tokens that belong to the body of the
# heredoc that should be appended onto the list of tokens when the heredoc
# closes.
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:272
module Prism::LexCompat::Heredoc
  class << self
    # Here we will split between the two types of heredocs and return the
    # object that will store their tokens.
    #
    # source://prism-0.23.0/lib/prism/lex_compat.rb:584
    def build(opening); end
  end
end

# Dash heredocs are a little more complicated. They are a list of tokens
# that need to be split on "\\\n" to mimic Ripper's behavior. We also need
# to keep track of the state that the heredoc was opened in.
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:296
class Prism::LexCompat::Heredoc::DashHeredoc
  # @return [DashHeredoc] a new instance of DashHeredoc
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:299
  def initialize(split); end

  # source://prism-0.23.0/lib/prism/lex_compat.rb:304
  def <<(token); end

  # source://prism-0.23.0/lib/prism/lex_compat.rb:297
  def split; end

  # source://prism-0.23.0/lib/prism/lex_compat.rb:308
  def to_a; end

  # source://prism-0.23.0/lib/prism/lex_compat.rb:297
  def tokens; end
end

# Heredocs that are dedenting heredocs are a little more complicated.
# Ripper outputs on_ignored_sp tokens for the whitespace that is being
# removed from the output. prism only modifies the node itself and keeps
# the token the same. This simplifies prism, but makes comparing against
# Ripper much harder because there is a length mismatch.
#
# Fortunately, we already have to pull out the heredoc tokens in order to
# insert them into the stream in the correct order. As such, we can do
# some extra manipulation on the tokens to make them match Ripper's
# output by mirroring the dedent logic that Ripper uses.
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:355
class Prism::LexCompat::Heredoc::DedentingHeredoc
  # @return [DedentingHeredoc] a new instance of DedentingHeredoc
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:360
  def initialize; end

  # As tokens are coming in, we track the minimum amount of common leading
  # whitespace on plain string content tokens. This allows us to later
  # remove that amount of whitespace from the beginning of each line.
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:371
  def <<(token); end

  # Returns the value of attribute dedent.
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:358
  def dedent; end

  # Returns the value of attribute dedent_next.
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:358
  def dedent_next; end

  # Returns the value of attribute embexpr_balance.
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:358
  def embexpr_balance; end

  # source://prism-0.23.0/lib/prism/lex_compat.rb:408
  def to_a; end

  # Returns the value of attribute tokens.
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:358
  def tokens; end
end

# source://prism-0.23.0/lib/prism/lex_compat.rb:356
Prism::LexCompat::Heredoc::DedentingHeredoc::TAB_WIDTH = T.let(T.unsafe(nil), Integer)

# Heredocs that are no dash or tilde heredocs are just a list of tokens.
# We need to keep them around so that we can insert them in the correct
# order back into the token stream and set the state of the last token to
# the state that the heredoc was opened in.
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:277
class Prism::LexCompat::Heredoc::PlainHeredoc
  # @return [PlainHeredoc] a new instance of PlainHeredoc
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:280
  def initialize; end

  # source://prism-0.23.0/lib/prism/lex_compat.rb:284
  def <<(token); end

  # source://prism-0.23.0/lib/prism/lex_compat.rb:288
  def to_a; end

  # source://prism-0.23.0/lib/prism/lex_compat.rb:278
  def tokens; end
end

# Ident tokens for the most part are exactly the same, except sometimes we
# know an ident is a local when ripper doesn't (when they are introduced
# through named captures in regular expressions). In that case we don't
# compare the state.
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:229
class Prism::LexCompat::IdentToken < ::Prism::LexCompat::Token
  # source://prism-0.23.0/lib/prism/lex_compat.rb:230
  def ==(other); end
end

# Tokens where state should be ignored
# used for :on_comment, :on_heredoc_end, :on_embexpr_end
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:219
class Prism::LexCompat::IgnoreStateToken < ::Prism::LexCompat::Token
  # source://prism-0.23.0/lib/prism/lex_compat.rb:220
  def ==(other); end
end

# Ignored newlines can occasionally have a LABEL state attached to them, so
# we compare the state differently here.
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:240
class Prism::LexCompat::IgnoredNewlineToken < ::Prism::LexCompat::Token
  # source://prism-0.23.0/lib/prism/lex_compat.rb:241
  def ==(other); end
end

# If we have an identifier that follows a method name like:
#
#     def foo bar
#
# then Ripper will mark bar as END|LABEL if there is a local in a parent
# scope named bar because it hasn't pushed the local table yet. We do this
# more accurately, so we need to allow comparing against both END and
# END|LABEL.
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:260
class Prism::LexCompat::ParamToken < ::Prism::LexCompat::Token
  # source://prism-0.23.0/lib/prism/lex_compat.rb:261
  def ==(other); end
end

# This is a mapping of prism token types to Ripper token types. This is a
# many-to-one mapping because we split up our token types, whereas Ripper
# tends to group them.
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:16
Prism::LexCompat::RIPPER = T.let(T.unsafe(nil), Hash)

# When we produce tokens, we produce the same arrays that Ripper does.
# However, we add a couple of convenience methods onto them to make them a
# little easier to work with. We delegate all other methods to the array.
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:187
class Prism::LexCompat::Token < ::SimpleDelegator
  # The type of the token.
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:194
  def event; end

  # The location of the token in the source.
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:189
  def location; end

  # The state of the lexer when this token was produced.
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:204
  def state; end

  # The slice of the source that this token represents.
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:199
  def value; end
end

# This is a class that wraps the Ripper lexer to produce almost exactly the
# same tokens.
#
# source://prism-0.23.0/lib/prism/lex_compat.rb:853
class Prism::LexRipper
  # @return [LexRipper] a new instance of LexRipper
  #
  # source://prism-0.23.0/lib/prism/lex_compat.rb:856
  def initialize(source); end

  # source://prism-0.23.0/lib/prism/lex_compat.rb:860
  def result; end

  # source://prism-0.23.0/lib/prism/lex_compat.rb:854
  def source; end

  private

  # source://prism-0.23.0/lib/prism/lex_compat.rb:894
  def lex(source); end
end

# Represents the use of the `&&=` operator for assignment to a local variable.
#
#     target &&= value
#     ^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:11041
class Prism::LocalVariableAndWriteNode < ::Prism::Node
  # def initialize: (Location name_loc, Location operator_loc, Node value, Symbol name, Integer depth, Location location) -> void
  #
  # @return [LocalVariableAndWriteNode] a new instance of LocalVariableAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11058
  def initialize(name_loc, operator_loc, value, name, depth, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:11069
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11074
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11084
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11079
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableAndWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11089
  sig { params(params: T.untyped).returns(Prism::LocalVariableAndWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11074
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:11104
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:11055
  sig { returns(Integer) }
  def depth; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11114
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11052
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:11043
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11109
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:11046
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11139
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:11049
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:11149
    def type; end
  end
end

# Represents assigning to a local variable using an operator that isn't `=`.
#
#     target += value
#     ^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:11158
class Prism::LocalVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (Location name_loc, Location operator_loc, Node value, Symbol name, Symbol operator, Integer depth, Location location) -> void
  #
  # @return [LocalVariableOperatorWriteNode] a new instance of LocalVariableOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11178
  def initialize(name_loc, operator_loc, value, name, operator, depth, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:11190
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11195
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11205
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11200
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableOperatorWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11210
  sig { params(params: T.untyped).returns(Prism::LocalVariableOperatorWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11195
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name_loc: Location, operator_loc: Location, value: Node, name: Symbol, operator: Symbol, depth: Integer, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:11226
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:11175
  sig { returns(Integer) }
  def depth; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11231
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11169
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:11160
  sig { returns(Prism::Location) }
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11172
  sig { returns(Symbol) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:11163
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11257
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:11166
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:11267
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a local variable.
#
#     target ||= value
#     ^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:11276
class Prism::LocalVariableOrWriteNode < ::Prism::Node
  # def initialize: (Location name_loc, Location operator_loc, Node value, Symbol name, Integer depth, Location location) -> void
  #
  # @return [LocalVariableOrWriteNode] a new instance of LocalVariableOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11293
  def initialize(name_loc, operator_loc, value, name, depth, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:11304
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11309
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11319
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11314
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableOrWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11324
  sig { params(params: T.untyped).returns(Prism::LocalVariableOrWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11309
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:11339
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:11290
  sig { returns(Integer) }
  def depth; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11349
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11287
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:11278
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11344
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:11281
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11374
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:11284
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:11384
    def type; end
  end
end

# Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.
#
#     foo
#     ^^^
#
# source://prism-0.23.0/lib/prism/node.rb:11393
class Prism::LocalVariableReadNode < ::Prism::Node
  # def initialize: (Symbol name, Integer depth, Location location) -> void
  #
  # @return [LocalVariableReadNode] a new instance of LocalVariableReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11419
  def initialize(name, depth, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:11427
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11432
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11442
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11437
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11447
  sig { params(params: T.untyped).returns(Prism::LocalVariableReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11432
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, depth: Integer, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:11459
  def deconstruct_keys(keys); end

  # The number of visible scopes that should be searched to find the origin of this local variable.
  #
  #     foo = 1; foo # depth 0
  #
  #     bar = 2; tap { bar } # depth 1
  #
  # The specific rules for calculating the depth may differ from individual Ruby implementations, as they are not specified by the language. For more information, see [the Prism documentation](https://github.com/ruby/prism/blob/main/docs/local_variable_depth.md).
  #
  # source://prism-0.23.0/lib/prism/node.rb:11416
  sig { returns(Integer) }
  def depth; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11464
  def inspect(inspector = T.unsafe(nil)); end

  # The name of the local variable, which is an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     x      # name `:x`
  #
  #     _Test  # name `:_Test`
  #
  # Note that this can also be an underscore followed by a number for the default block parameters.
  #
  #     _1     # name `:_1`
  #
  # Finally, for the default `it` block parameter, the name is `0it`. This is to distinguish it from an `it` local variable that is explicitly declared.
  #
  #     it     # name `:0it`
  #
  # source://prism-0.23.0/lib/prism/node.rb:11407
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11485
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:11495
    def type; end
  end
end

# Represents writing to a local variable in a context that doesn't have an explicit value.
#
#     foo, bar = baz
#     ^^^  ^^^
#
# source://prism-0.23.0/lib/prism/node.rb:11504
class Prism::LocalVariableTargetNode < ::Prism::Node
  # def initialize: (Symbol name, Integer depth, Location location) -> void
  #
  # @return [LocalVariableTargetNode] a new instance of LocalVariableTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11512
  def initialize(name, depth, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:11520
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11525
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11535
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11530
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11540
  sig { params(params: T.untyped).returns(Prism::LocalVariableTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11525
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, depth: Integer, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:11552
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:11509
  sig { returns(Integer) }
  def depth; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11557
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11506
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11578
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:11588
    def type; end
  end
end

# Represents writing to a local variable.
#
#     foo = 1
#     ^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:11597
class Prism::LocalVariableWriteNode < ::Prism::Node
  # def initialize: (Symbol name, Integer depth, Location name_loc, Node value, Location operator_loc, Location location) -> void
  #
  # @return [LocalVariableWriteNode] a new instance of LocalVariableWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11614
  def initialize(name, depth, name_loc, value, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:11625
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11630
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11640
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11635
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11645
  sig { params(params: T.untyped).returns(Prism::LocalVariableWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11630
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { name: Symbol, depth: Integer, name_loc: Location, value: Node, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:11660
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:11602
  sig { returns(Integer) }
  def depth; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11670
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11599
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:11605
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11665
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:11611
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11695
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:11608
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:11705
    def type; end
  end
end

# This represents a location in the source.
#
# source://prism-0.23.0/lib/prism/parse_result.rb:98
class Prism::Location
  # Create a new location object with the given source, start byte offset, and
  # byte length.
  #
  # @return [Location] a new instance of Location
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:116
  def initialize(source, start_offset, length); end

  # Returns true if the given other location is equal to this location.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:232
  def ==(other); end

  # The list of comments attached to this location
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:112
  sig { returns(T::Array[Prism::Comment]) }
  def comments; end

  # Create a new location object with the given options.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:124
  sig { params(options: T.untyped).returns(Prism::Location) }
  def copy(**options); end

  # Implement the hash pattern matching interface for Location.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:222
  def deconstruct_keys(keys); end

  # The column number in characters where this location ends from the start of
  # the line.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:211
  def end_character_column; end

  # The character offset from the beginning of the source where this location
  # ends.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:160
  def end_character_offset; end

  # The column number in code units of the given encoding where this location
  # ends from the start of the line.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:217
  def end_code_units_column(encoding = T.unsafe(nil)); end

  # The offset from the start of the file in code units of the given encoding.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:165
  def end_code_units_offset(encoding = T.unsafe(nil)); end

  # The column number in bytes where this location ends from the start of the
  # line.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:205
  sig { returns(Integer) }
  def end_column; end

  # The line number where this location ends.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:181
  sig { returns(Integer) }
  def end_line; end

  # The byte offset from the beginning of the source where this location ends.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:154
  sig { returns(Integer) }
  def end_offset; end

  # Returns a string representation of this location.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:133
  def inspect; end

  # Returns a new location that stretches from this location to the given
  # other location. Raises an error if this location is not before the other
  # location or if they don't share the same source.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:241
  def join(other); end

  # The length of this location in bytes.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:109
  def length; end

  # Implement the pretty print interface for Location.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:227
  def pretty_print(q); end

  # The source code that this location represents.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:138
  sig { returns(String) }
  def slice; end

  # The column number in characters where this location ends from the start of
  # the line.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:193
  def start_character_column; end

  # The character offset from the beginning of the source where this location
  # starts.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:144
  def start_character_offset; end

  # The column number in code units of the given encoding where this location
  # starts from the start of the line.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:199
  def start_code_units_column(encoding = T.unsafe(nil)); end

  # The offset from the start of the file in code units of the given encoding.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:149
  def start_code_units_offset(encoding = T.unsafe(nil)); end

  # The column number in bytes where this location starts from the start of
  # the line.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:187
  sig { returns(Integer) }
  def start_column; end

  # The line number where this location starts.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:170
  sig { returns(Integer) }
  def start_line; end

  # The content of the line where this location starts before this location.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:175
  def start_line_slice; end

  # The byte offset from the beginning of the source where this location
  # starts.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:106
  sig { returns(Integer) }
  def start_offset; end

  protected

  # A Source object that is used to determine more information from the given
  # offset and length.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:101
  def source; end

  class << self
    # Returns a null location that does not correspond to a source and points to
    # the beginning of the file. Useful for when you want a location object but
    # do not care where it points.
    #
    # source://prism-0.23.0/lib/prism/parse_result.rb:251
    def null; end
  end
end

# Flags for while and until loop nodes.
#
# source://prism-0.23.0/lib/prism/node.rb:17788
module Prism::LoopFlags; end

# a loop after a begin statement, so the body is executed first before the condition
#
# source://prism-0.23.0/lib/prism/node.rb:17790
Prism::LoopFlags::BEGIN_MODIFIER = T.let(T.unsafe(nil), Integer)

# This represents a magic comment that was encountered during parsing.
#
# source://prism-0.23.0/lib/prism/parse_result.rb:303
class Prism::MagicComment
  # Create a new magic comment object with the given key and value locations.
  #
  # @return [MagicComment] a new instance of MagicComment
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:311
  def initialize(key_loc, value_loc); end

  # Implement the hash pattern matching interface for MagicComment.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:327
  def deconstruct_keys(keys); end

  # Returns a string representation of this magic comment.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:332
  def inspect; end

  # Returns the key of the magic comment by slicing it from the source code.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:317
  def key; end

  # A Location object representing the location of the key in the source.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:305
  def key_loc; end

  # Returns the value of the magic comment by slicing it from the source code.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:322
  def value; end

  # A Location object representing the location of the value in the source.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:308
  def value_loc; end
end

# Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.
#
#     if /foo/i then end
#        ^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:11714
class Prism::MatchLastLineNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # def initialize: (Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped, Location location) -> void
  #
  # @return [MatchLastLineNode] a new instance of MatchLastLineNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11732
  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:11743
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11808
  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11748
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11848
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:11726
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11758
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11753
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11843
  sig { returns(String) }
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:11723
  sig { returns(Prism::Location) }
  def content_loc; end

  # def copy: (**params) -> MatchLastLineNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11763
  sig { params(params: T.untyped).returns(Prism::MatchLastLineNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11748
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:11778
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11803
  sig { returns(T::Boolean) }
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11788
  sig { returns(T::Boolean) }
  def extended?; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11828
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11833
  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11823
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11783
  sig { returns(T::Boolean) }
  def ignore_case?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11853
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11793
  sig { returns(T::Boolean) }
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11798
  sig { returns(T::Boolean) }
  def once?; end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11838
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:11720
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11878
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11729
  sig { returns(String) }
  def unescaped; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11818
  sig { returns(T::Boolean) }
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11813
  sig { returns(T::Boolean) }
  def windows_31j?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:11716
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:11888
    def type; end
  end
end

# Represents the use of the modifier `in` operator.
#
#     foo in bar
#     ^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:11897
class Prism::MatchPredicateNode < ::Prism::Node
  # def initialize: (Node value, Node pattern, Location operator_loc, Location location) -> void
  #
  # @return [MatchPredicateNode] a new instance of MatchPredicateNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11908
  def initialize(value, pattern, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:11917
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11922
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11932
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11927
  def compact_child_nodes; end

  # def copy: (**params) -> MatchPredicateNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:11937
  sig { params(params: T.untyped).returns(Prism::MatchPredicateNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:11922
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { value: Node, pattern: Node, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:11950
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11960
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:11955
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:11905
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader pattern: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:11902
  sig { returns(Prism::Node) }
  def pattern; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:11984
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:11899
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:11994
    def type; end
  end
end

# Represents the use of the `=>` operator.
#
#     foo => bar
#     ^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:12003
class Prism::MatchRequiredNode < ::Prism::Node
  # def initialize: (Node value, Node pattern, Location operator_loc, Location location) -> void
  #
  # @return [MatchRequiredNode] a new instance of MatchRequiredNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12014
  def initialize(value, pattern, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:12023
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12028
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12038
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12033
  def compact_child_nodes; end

  # def copy: (**params) -> MatchRequiredNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12043
  sig { params(params: T.untyped).returns(Prism::MatchRequiredNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12028
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { value: Node, pattern: Node, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:12056
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12066
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12061
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:12011
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader pattern: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:12008
  sig { returns(Prism::Node) }
  def pattern; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:12090
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:12005
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:12100
    def type; end
  end
end

# Represents writing local variables using a regular expression match with named capture groups.
#
#     /(?<foo>bar)/ =~ baz
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:12109
class Prism::MatchWriteNode < ::Prism::Node
  # def initialize: (CallNode call, Array[Node] targets, Location location) -> void
  #
  # @return [MatchWriteNode] a new instance of MatchWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12117
  def initialize(call, targets, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:12125
  def accept(visitor); end

  # attr_reader call: CallNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12111
  sig { returns(Prism::CallNode) }
  def call; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12130
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12140
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12135
  def compact_child_nodes; end

  # def copy: (**params) -> MatchWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12145
  sig { params(params: T.untyped).returns(Prism::MatchWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12130
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { call: CallNode, targets: Array[Node], location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:12157
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12162
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader targets: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12114
  sig { returns(T::Array[Prism::Node]) }
  def targets; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:12184
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:12194
    def type; end
  end
end

# Represents a node that is missing from the source and results in a syntax error.
#
# source://prism-0.23.0/lib/prism/node.rb:12200
class Prism::MissingNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [MissingNode] a new instance of MissingNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12202
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:12208
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12213
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12223
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12218
  def compact_child_nodes; end

  # def copy: (**params) -> MissingNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12228
  sig { params(params: T.untyped).returns(Prism::MissingNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12213
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:12238
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12243
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:12262
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:12272
    def type; end
  end
end

# Represents a module declaration involving the `module` keyword.
#
#     module Foo end
#     ^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:12281
class Prism::ModuleNode < ::Prism::Node
  # def initialize: (Array[Symbol] locals, Location module_keyword_loc, Node constant_path, Node? body, Location end_keyword_loc, Symbol name, Location location) -> void
  #
  # @return [ModuleNode] a new instance of ModuleNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12301
  def initialize(locals, module_keyword_loc, constant_path, body, end_keyword_loc, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:12313
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:12292
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12318
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12331
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12323
  def compact_child_nodes; end

  # attr_reader constant_path: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:12289
  sig { returns(Prism::Node) }
  def constant_path; end

  # def copy: (**params) -> ModuleNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12336
  sig { params(params: T.untyped).returns(Prism::ModuleNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12318
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { locals: Array[Symbol], module_keyword_loc: Location, constant_path: Node, body: Node?, end_keyword_loc: Location, name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:12352
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12362
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:12295
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12367
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12283
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def module_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12357
  sig { returns(String) }
  def module_keyword; end

  # attr_reader module_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:12286
  sig { returns(Prism::Location) }
  def module_keyword_loc; end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:12298
  sig { returns(Symbol) }
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:12398
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:12408
    def type; end
  end
end

# Represents a multi-target expression.
#
#     a, (b, c) = 1, 2, 3
#        ^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:12417
class Prism::MultiTargetNode < ::Prism::Node
  # def initialize: (Array[Node] lefts, Node? rest, Array[Node] rights, Location? lparen_loc, Location? rparen_loc, Location location) -> void
  #
  # @return [MultiTargetNode] a new instance of MultiTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12434
  def initialize(lefts, rest, rights, lparen_loc, rparen_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:12445
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12450
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12464
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12455
  def compact_child_nodes; end

  # def copy: (**params) -> MultiTargetNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12469
  sig { params(params: T.untyped).returns(Prism::MultiTargetNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12450
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { lefts: Array[Node], rest: Node?, rights: Array[Node], lparen_loc: Location?, rparen_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:12484
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12499
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader lefts: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12419
  sig { returns(T::Array[Prism::Node]) }
  def lefts; end

  # def lparen: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:12489
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:12428
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # attr_reader rest: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:12422
  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  # attr_reader rights: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12425
  sig { returns(T::Array[Prism::Node]) }
  def rights; end

  # def rparen: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:12494
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:12431
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:12528
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:12538
    def type; end
  end
end

# Represents a write to a multi-target expression.
#
#     a, b, c = 1, 2, 3
#     ^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:12547
class Prism::MultiWriteNode < ::Prism::Node
  # def initialize: (Array[Node] lefts, Node? rest, Array[Node] rights, Location? lparen_loc, Location? rparen_loc, Location operator_loc, Node value, Location location) -> void
  #
  # @return [MultiWriteNode] a new instance of MultiWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12570
  def initialize(lefts, rest, rights, lparen_loc, rparen_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:12583
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12588
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12603
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12593
  def compact_child_nodes; end

  # def copy: (**params) -> MultiWriteNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12608
  sig { params(params: T.untyped).returns(Prism::MultiWriteNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12588
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { lefts: Array[Node], rest: Node?, rights: Array[Node], lparen_loc: Location?, rparen_loc: Location?, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:12625
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12645
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader lefts: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12549
  sig { returns(T::Array[Prism::Node]) }
  def lefts; end

  # def lparen: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:12630
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:12558
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12640
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:12564
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader rest: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:12552
  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  # attr_reader rights: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12555
  sig { returns(T::Array[Prism::Node]) }
  def rights; end

  # def rparen: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:12635
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:12561
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:12677
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:12567
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:12687
    def type; end
  end
end

# This visitor walks through the tree and copies each node as it is being
# visited. This is useful for consumers that want to mutate the tree, as you
# can change subtrees in place without effecting the rest of the tree.
#
# source://prism-0.23.0/lib/prism/mutation_compiler.rb:12
class Prism::MutationCompiler < ::Prism::Compiler
  # Copy a AliasGlobalVariableNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:14
  def visit_alias_global_variable_node(node); end

  # Copy a AliasMethodNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:19
  def visit_alias_method_node(node); end

  # Copy a AlternationPatternNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:24
  def visit_alternation_pattern_node(node); end

  # Copy a AndNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:29
  def visit_and_node(node); end

  # Copy a ArgumentsNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:34
  def visit_arguments_node(node); end

  # Copy a ArrayNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:39
  def visit_array_node(node); end

  # Copy a ArrayPatternNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:44
  def visit_array_pattern_node(node); end

  # Copy a AssocNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:49
  def visit_assoc_node(node); end

  # Copy a AssocSplatNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:54
  def visit_assoc_splat_node(node); end

  # Copy a BackReferenceReadNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:59
  def visit_back_reference_read_node(node); end

  # Copy a BeginNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:64
  def visit_begin_node(node); end

  # Copy a BlockArgumentNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:69
  def visit_block_argument_node(node); end

  # Copy a BlockLocalVariableNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:74
  def visit_block_local_variable_node(node); end

  # Copy a BlockNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:79
  def visit_block_node(node); end

  # Copy a BlockParameterNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:84
  def visit_block_parameter_node(node); end

  # Copy a BlockParametersNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:89
  def visit_block_parameters_node(node); end

  # Copy a BreakNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:94
  def visit_break_node(node); end

  # Copy a CallAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:99
  def visit_call_and_write_node(node); end

  # Copy a CallNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:104
  def visit_call_node(node); end

  # Copy a CallOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:109
  def visit_call_operator_write_node(node); end

  # Copy a CallOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:114
  def visit_call_or_write_node(node); end

  # Copy a CallTargetNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:119
  def visit_call_target_node(node); end

  # Copy a CapturePatternNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:124
  def visit_capture_pattern_node(node); end

  # Copy a CaseMatchNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:129
  def visit_case_match_node(node); end

  # Copy a CaseNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:134
  def visit_case_node(node); end

  # Copy a ClassNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:139
  def visit_class_node(node); end

  # Copy a ClassVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:144
  def visit_class_variable_and_write_node(node); end

  # Copy a ClassVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:149
  def visit_class_variable_operator_write_node(node); end

  # Copy a ClassVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:154
  def visit_class_variable_or_write_node(node); end

  # Copy a ClassVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:159
  def visit_class_variable_read_node(node); end

  # Copy a ClassVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:164
  def visit_class_variable_target_node(node); end

  # Copy a ClassVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:169
  def visit_class_variable_write_node(node); end

  # Copy a ConstantAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:174
  def visit_constant_and_write_node(node); end

  # Copy a ConstantOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:179
  def visit_constant_operator_write_node(node); end

  # Copy a ConstantOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:184
  def visit_constant_or_write_node(node); end

  # Copy a ConstantPathAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:189
  def visit_constant_path_and_write_node(node); end

  # Copy a ConstantPathNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:194
  def visit_constant_path_node(node); end

  # Copy a ConstantPathOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:199
  def visit_constant_path_operator_write_node(node); end

  # Copy a ConstantPathOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:204
  def visit_constant_path_or_write_node(node); end

  # Copy a ConstantPathTargetNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:209
  def visit_constant_path_target_node(node); end

  # Copy a ConstantPathWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:214
  def visit_constant_path_write_node(node); end

  # Copy a ConstantReadNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:219
  def visit_constant_read_node(node); end

  # Copy a ConstantTargetNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:224
  def visit_constant_target_node(node); end

  # Copy a ConstantWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:229
  def visit_constant_write_node(node); end

  # Copy a DefNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:234
  def visit_def_node(node); end

  # Copy a DefinedNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:239
  def visit_defined_node(node); end

  # Copy a ElseNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:244
  def visit_else_node(node); end

  # Copy a EmbeddedStatementsNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:249
  def visit_embedded_statements_node(node); end

  # Copy a EmbeddedVariableNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:254
  def visit_embedded_variable_node(node); end

  # Copy a EnsureNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:259
  def visit_ensure_node(node); end

  # Copy a FalseNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:264
  def visit_false_node(node); end

  # Copy a FindPatternNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:269
  def visit_find_pattern_node(node); end

  # Copy a FlipFlopNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:274
  def visit_flip_flop_node(node); end

  # Copy a FloatNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:279
  def visit_float_node(node); end

  # Copy a ForNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:284
  def visit_for_node(node); end

  # Copy a ForwardingArgumentsNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:289
  def visit_forwarding_arguments_node(node); end

  # Copy a ForwardingParameterNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:294
  def visit_forwarding_parameter_node(node); end

  # Copy a ForwardingSuperNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:299
  def visit_forwarding_super_node(node); end

  # Copy a GlobalVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:304
  def visit_global_variable_and_write_node(node); end

  # Copy a GlobalVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:309
  def visit_global_variable_operator_write_node(node); end

  # Copy a GlobalVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:314
  def visit_global_variable_or_write_node(node); end

  # Copy a GlobalVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:319
  def visit_global_variable_read_node(node); end

  # Copy a GlobalVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:324
  def visit_global_variable_target_node(node); end

  # Copy a GlobalVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:329
  def visit_global_variable_write_node(node); end

  # Copy a HashNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:334
  def visit_hash_node(node); end

  # Copy a HashPatternNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:339
  def visit_hash_pattern_node(node); end

  # Copy a IfNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:344
  def visit_if_node(node); end

  # Copy a ImaginaryNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:349
  def visit_imaginary_node(node); end

  # Copy a ImplicitNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:354
  def visit_implicit_node(node); end

  # Copy a ImplicitRestNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:359
  def visit_implicit_rest_node(node); end

  # Copy a InNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:364
  def visit_in_node(node); end

  # Copy a IndexAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:369
  def visit_index_and_write_node(node); end

  # Copy a IndexOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:374
  def visit_index_operator_write_node(node); end

  # Copy a IndexOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:379
  def visit_index_or_write_node(node); end

  # Copy a IndexTargetNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:384
  def visit_index_target_node(node); end

  # Copy a InstanceVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:389
  def visit_instance_variable_and_write_node(node); end

  # Copy a InstanceVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:394
  def visit_instance_variable_operator_write_node(node); end

  # Copy a InstanceVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:399
  def visit_instance_variable_or_write_node(node); end

  # Copy a InstanceVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:404
  def visit_instance_variable_read_node(node); end

  # Copy a InstanceVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:409
  def visit_instance_variable_target_node(node); end

  # Copy a InstanceVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:414
  def visit_instance_variable_write_node(node); end

  # Copy a IntegerNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:419
  def visit_integer_node(node); end

  # Copy a InterpolatedMatchLastLineNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:424
  def visit_interpolated_match_last_line_node(node); end

  # Copy a InterpolatedRegularExpressionNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:429
  def visit_interpolated_regular_expression_node(node); end

  # Copy a InterpolatedStringNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:434
  def visit_interpolated_string_node(node); end

  # Copy a InterpolatedSymbolNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:439
  def visit_interpolated_symbol_node(node); end

  # Copy a InterpolatedXStringNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:444
  def visit_interpolated_x_string_node(node); end

  # Copy a KeywordHashNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:449
  def visit_keyword_hash_node(node); end

  # Copy a KeywordRestParameterNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:454
  def visit_keyword_rest_parameter_node(node); end

  # Copy a LambdaNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:459
  def visit_lambda_node(node); end

  # Copy a LocalVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:464
  def visit_local_variable_and_write_node(node); end

  # Copy a LocalVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:469
  def visit_local_variable_operator_write_node(node); end

  # Copy a LocalVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:474
  def visit_local_variable_or_write_node(node); end

  # Copy a LocalVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:479
  def visit_local_variable_read_node(node); end

  # Copy a LocalVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:484
  def visit_local_variable_target_node(node); end

  # Copy a LocalVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:489
  def visit_local_variable_write_node(node); end

  # Copy a MatchLastLineNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:494
  def visit_match_last_line_node(node); end

  # Copy a MatchPredicateNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:499
  def visit_match_predicate_node(node); end

  # Copy a MatchRequiredNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:504
  def visit_match_required_node(node); end

  # Copy a MatchWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:509
  def visit_match_write_node(node); end

  # Copy a MissingNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:514
  def visit_missing_node(node); end

  # Copy a ModuleNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:519
  def visit_module_node(node); end

  # Copy a MultiTargetNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:524
  def visit_multi_target_node(node); end

  # Copy a MultiWriteNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:529
  def visit_multi_write_node(node); end

  # Copy a NextNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:534
  def visit_next_node(node); end

  # Copy a NilNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:539
  def visit_nil_node(node); end

  # Copy a NoKeywordsParameterNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:544
  def visit_no_keywords_parameter_node(node); end

  # Copy a NumberedParametersNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:549
  def visit_numbered_parameters_node(node); end

  # Copy a NumberedReferenceReadNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:554
  def visit_numbered_reference_read_node(node); end

  # Copy a OptionalKeywordParameterNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:559
  def visit_optional_keyword_parameter_node(node); end

  # Copy a OptionalParameterNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:564
  def visit_optional_parameter_node(node); end

  # Copy a OrNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:569
  def visit_or_node(node); end

  # Copy a ParametersNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:574
  def visit_parameters_node(node); end

  # Copy a ParenthesesNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:579
  def visit_parentheses_node(node); end

  # Copy a PinnedExpressionNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:584
  def visit_pinned_expression_node(node); end

  # Copy a PinnedVariableNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:589
  def visit_pinned_variable_node(node); end

  # Copy a PostExecutionNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:594
  def visit_post_execution_node(node); end

  # Copy a PreExecutionNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:599
  def visit_pre_execution_node(node); end

  # Copy a ProgramNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:604
  def visit_program_node(node); end

  # Copy a RangeNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:609
  def visit_range_node(node); end

  # Copy a RationalNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:614
  def visit_rational_node(node); end

  # Copy a RedoNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:619
  def visit_redo_node(node); end

  # Copy a RegularExpressionNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:624
  def visit_regular_expression_node(node); end

  # Copy a RequiredKeywordParameterNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:629
  def visit_required_keyword_parameter_node(node); end

  # Copy a RequiredParameterNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:634
  def visit_required_parameter_node(node); end

  # Copy a RescueModifierNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:639
  def visit_rescue_modifier_node(node); end

  # Copy a RescueNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:644
  def visit_rescue_node(node); end

  # Copy a RestParameterNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:649
  def visit_rest_parameter_node(node); end

  # Copy a RetryNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:654
  def visit_retry_node(node); end

  # Copy a ReturnNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:659
  def visit_return_node(node); end

  # Copy a SelfNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:664
  def visit_self_node(node); end

  # Copy a SingletonClassNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:669
  def visit_singleton_class_node(node); end

  # Copy a SourceEncodingNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:674
  def visit_source_encoding_node(node); end

  # Copy a SourceFileNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:679
  def visit_source_file_node(node); end

  # Copy a SourceLineNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:684
  def visit_source_line_node(node); end

  # Copy a SplatNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:689
  def visit_splat_node(node); end

  # Copy a StatementsNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:694
  def visit_statements_node(node); end

  # Copy a StringNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:699
  def visit_string_node(node); end

  # Copy a SuperNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:704
  def visit_super_node(node); end

  # Copy a SymbolNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:709
  def visit_symbol_node(node); end

  # Copy a TrueNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:714
  def visit_true_node(node); end

  # Copy a UndefNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:719
  def visit_undef_node(node); end

  # Copy a UnlessNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:724
  def visit_unless_node(node); end

  # Copy a UntilNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:729
  def visit_until_node(node); end

  # Copy a WhenNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:734
  def visit_when_node(node); end

  # Copy a WhileNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:739
  def visit_while_node(node); end

  # Copy a XStringNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:744
  def visit_x_string_node(node); end

  # Copy a YieldNode node
  #
  # source://prism-0.23.0/lib/prism/mutation_compiler.rb:749
  def visit_yield_node(node); end
end

# Represents the use of the `next` keyword.
#
#     next 1
#     ^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:12696
class Prism::NextNode < ::Prism::Node
  # def initialize: (ArgumentsNode? arguments, Location keyword_loc, Location location) -> void
  #
  # @return [NextNode] a new instance of NextNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12704
  def initialize(arguments, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:12712
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:12698
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12717
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12729
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12722
  def compact_child_nodes; end

  # def copy: (**params) -> NextNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12734
  sig { params(params: T.untyped).returns(Prism::NextNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12717
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { arguments: ArgumentsNode?, keyword_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:12746
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12756
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12751
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:12701
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:12782
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:12792
    def type; end
  end
end

# Represents the use of the `nil` keyword.
#
#     nil
#     ^^^
#
# source://prism-0.23.0/lib/prism/node.rb:12801
class Prism::NilNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [NilNode] a new instance of NilNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12803
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:12809
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12814
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12824
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12819
  def compact_child_nodes; end

  # def copy: (**params) -> NilNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12829
  sig { params(params: T.untyped).returns(Prism::NilNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12814
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:12839
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12844
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:12863
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:12873
    def type; end
  end
end

# Represents the use of `**nil` inside method arguments.
#
#     def a(**nil)
#           ^^^^^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:12883
class Prism::NoKeywordsParameterNode < ::Prism::Node
  # def initialize: (Location operator_loc, Location keyword_loc, Location location) -> void
  #
  # @return [NoKeywordsParameterNode] a new instance of NoKeywordsParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12891
  def initialize(operator_loc, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:12899
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12904
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12914
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12909
  def compact_child_nodes; end

  # def copy: (**params) -> NoKeywordsParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12919
  sig { params(params: T.untyped).returns(Prism::NoKeywordsParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:12904
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { operator_loc: Location, keyword_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:12931
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12946
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12941
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:12888
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:12936
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:12885
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:12967
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:12977
    def type; end
  end
end

# This represents a node in the tree. It is the parent class of all of the
# various node types.
#
# source://prism-0.23.0/lib/prism/node.rb:11
class Prism::Node
  # Accepts a visitor and calls back into the specialized visit function.
  #
  # @raise [NoMethodError]
  #
  # source://prism-0.23.0/lib/prism/node.rb:55
  def accept(visitor); end

  # Returns an array of child nodes, including `nil`s in the place of optional
  # nodes that were not present.
  #
  # @raise [NoMethodError]
  #
  # source://prism-0.23.0/lib/prism/node.rb:61
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # Returns an array of child nodes and locations that could potentially have
  # comments attached to them.
  #
  # @raise [NoMethodError]
  #
  # source://prism-0.23.0/lib/prism/node.rb:75
  def comment_targets; end

  # Returns an array of child nodes, excluding any `nil`s in the place of
  # optional nodes that were not present.
  #
  # @raise [NoMethodError]
  #
  # source://prism-0.23.0/lib/prism/node.rb:69
  sig { returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # Returns an array of child nodes, including `nil`s in the place of optional
  # nodes that were not present.
  #
  # @raise [NoMethodError]
  #
  # source://prism-0.23.0/lib/prism/node.rb:61
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # A Location instance that represents the location of this node in the
  # source.
  #
  # source://prism-0.23.0/lib/prism/node.rb:14
  sig { returns(Prism::Location) }
  def location; end

  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16
  def newline?; end

  # Similar to inspect, but respects the current level of indentation given by
  # the pretty print object.
  #
  # source://prism-0.23.0/lib/prism/node.rb:35
  def pretty_print(q); end

  # source://prism-0.23.0/lib/prism/node.rb:20
  def set_newline_flag(newline_marked); end

  # Slice the location of the node from the source.
  #
  # source://prism-0.23.0/lib/prism/node.rb:29
  sig { returns(String) }
  def slice; end

  # Convert this node into a graphviz dot graph string.
  #
  # source://prism-0.23.0/lib/prism/node.rb:43
  sig { returns(String) }
  def to_dot; end

  # Returns a symbol symbolizing the type of node that this represents. This
  # is particularly useful for case statements and array comparisons.
  #
  # @raise [NoMethodError]
  #
  # source://prism-0.23.0/lib/prism/node.rb:81
  sig { returns(Symbol) }
  def type; end
end

# This object is responsible for generating the output for the inspect method
# implementations of child nodes.
#
# source://prism-0.23.0/lib/prism/node_inspector.rb:6
class Prism::NodeInspector
  # @return [NodeInspector] a new instance of NodeInspector
  #
  # source://prism-0.23.0/lib/prism/node_inspector.rb:9
  def initialize(prefix = T.unsafe(nil)); end

  # Appends a line to the output with the current prefix.
  #
  # source://prism-0.23.0/lib/prism/node_inspector.rb:15
  def <<(line); end

  # Returns a new inspector that can be used to inspect a child node.
  #
  # source://prism-0.23.0/lib/prism/node_inspector.rb:59
  def child_inspector(append); end

  # Generates a string that represents a child node.
  #
  # source://prism-0.23.0/lib/prism/node_inspector.rb:54
  def child_node(node, append); end

  # This generates a string that is used as the header of the inspect output
  # for any given node.
  #
  # source://prism-0.23.0/lib/prism/node_inspector.rb:21
  def header(node); end

  # Generates a string that represents a list of nodes. It handles properly
  # using the box drawing characters to make the output look nice.
  #
  # source://prism-0.23.0/lib/prism/node_inspector.rb:31
  def list(prefix, nodes); end

  # Generates a string that represents a location field on a node.
  #
  # source://prism-0.23.0/lib/prism/node_inspector.rb:45
  def location(value); end

  # source://prism-0.23.0/lib/prism/node_inspector.rb:7
  sig { returns(String) }
  def output; end

  # source://prism-0.23.0/lib/prism/node_inspector.rb:7
  sig { returns(String) }
  def prefix; end

  # Returns the output as a string.
  #
  # source://prism-0.23.0/lib/prism/node_inspector.rb:64
  sig { returns(String) }
  def to_str; end
end

# Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.
#
#     -> { _1 + _2 }
#     ^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:12986
class Prism::NumberedParametersNode < ::Prism::Node
  # def initialize: (Integer maximum, Location location) -> void
  #
  # @return [NumberedParametersNode] a new instance of NumberedParametersNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:12991
  def initialize(maximum, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:12998
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13003
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13013
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13008
  def compact_child_nodes; end

  # def copy: (**params) -> NumberedParametersNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13018
  sig { params(params: T.untyped).returns(Prism::NumberedParametersNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13003
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { maximum: Integer, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:13029
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13034
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader maximum: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:12988
  sig { returns(Integer) }
  def maximum; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:13054
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:13064
    def type; end
  end
end

# Represents reading a numbered reference to a capture in the previous match.
#
#     $1
#     ^^
#
# source://prism-0.23.0/lib/prism/node.rb:13073
class Prism::NumberedReferenceReadNode < ::Prism::Node
  # def initialize: (Integer number, Location location) -> void
  #
  # @return [NumberedReferenceReadNode] a new instance of NumberedReferenceReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13084
  def initialize(number, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:13091
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13096
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13106
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13101
  def compact_child_nodes; end

  # def copy: (**params) -> NumberedReferenceReadNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13111
  sig { params(params: T.untyped).returns(Prism::NumberedReferenceReadNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13096
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { number: Integer, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:13122
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13127
  def inspect(inspector = T.unsafe(nil)); end

  # The (1-indexed, from the left) number of the capture group. Numbered references that would overflow a `uint32`  result in a `number` of exactly `2**32 - 1`.
  #
  #     $1          # number `1`
  #
  #     $5432       # number `5432`
  #
  #     $4294967296 # number `4294967295`
  #
  # source://prism-0.23.0/lib/prism/node.rb:13081
  sig { returns(Integer) }
  def number; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:13147
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:13157
    def type; end
  end
end

# Represents an optional keyword parameter to a method, block, or lambda definition.
#
#     def a(b: 1)
#           ^^^^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:13167
class Prism::OptionalKeywordParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol name, Location name_loc, Node value, Location location) -> void
  #
  # @return [OptionalKeywordParameterNode] a new instance of OptionalKeywordParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13182
  def initialize(flags, name, name_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:13192
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13197
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13207
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13202
  def compact_child_nodes; end

  # def copy: (**params) -> OptionalKeywordParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13212
  sig { params(params: T.untyped).returns(Prism::OptionalKeywordParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13197
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol, name_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:13226
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13236
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:13173
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:13176
  sig { returns(Prism::Location) }
  def name_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13231
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:13261
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:13179
  sig { returns(Prism::Node) }
  def value; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:13169
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:13271
    def type; end
  end
end

# Represents an optional parameter to a method, block, or lambda definition.
#
#     def a(b = 1)
#           ^^^^^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:13281
class Prism::OptionalParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol name, Location name_loc, Location operator_loc, Node value, Location location) -> void
  #
  # @return [OptionalParameterNode] a new instance of OptionalParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13299
  def initialize(flags, name, name_loc, operator_loc, value, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:13310
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13315
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13325
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13320
  def compact_child_nodes; end

  # def copy: (**params) -> OptionalParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13330
  sig { params(params: T.untyped).returns(Prism::OptionalParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13315
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:13345
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13360
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:13287
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:13290
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13355
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:13293
  sig { returns(Prism::Location) }
  def operator_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13350
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:13386
  def type; end

  # attr_reader value: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:13296
  sig { returns(Prism::Node) }
  def value; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:13283
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:13396
    def type; end
  end
end

# Represents the use of the `||` operator or the `or` keyword.
#
#     left or right
#     ^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:13405
class Prism::OrNode < ::Prism::Node
  # def initialize: (Node left, Node right, Location operator_loc, Location location) -> void
  #
  # @return [OrNode] a new instance of OrNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13431
  def initialize(left, right, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:13440
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13445
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13455
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13450
  def compact_child_nodes; end

  # def copy: (**params) -> OrNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13460
  sig { params(params: T.untyped).returns(Prism::OrNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13445
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { left: Node, right: Node, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:13473
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13483
  def inspect(inspector = T.unsafe(nil)); end

  # Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     left or right
  #     ^^^^
  #
  #     1 || 2
  #     ^
  #
  # source://prism-0.23.0/lib/prism/node.rb:13413
  sig { returns(Prism::Node) }
  def left; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13478
  sig { returns(String) }
  def operator; end

  # The location of the `or` keyword or the `||` operator.
  #
  #     left or right
  #          ^^
  #
  # source://prism-0.23.0/lib/prism/node.rb:13428
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Represents the right side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     left || right
  #             ^^^^^
  #
  #     1 or 2
  #          ^
  #
  # source://prism-0.23.0/lib/prism/node.rb:13422
  sig { returns(Prism::Node) }
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:13507
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:13517
    def type; end
  end
end

# A parser for the pack template language.
#
# source://prism-0.23.0/lib/prism/pack.rb:5
module Prism::Pack
  class << self
    def parse(_arg0, _arg1, _arg2); end
  end
end

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::AGNOSTIC_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::BACK = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::BER = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::BIG_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::COMMENT = T.let(T.unsafe(nil), Symbol)

# A directive in the pack template language.
#
# source://prism-0.23.0/lib/prism/pack.rb:59
class Prism::Pack::Directive
  # Initialize a new directive with the given values.
  #
  # @return [Directive] a new instance of Directive
  #
  # source://prism-0.23.0/lib/prism/pack.rb:88
  def initialize(version, variant, source, type, signed, endian, size, length_type, length); end

  # Provide a human-readable description of the directive.
  #
  # source://prism-0.23.0/lib/prism/pack.rb:130
  def describe; end

  # The type of endianness of the directive.
  #
  # source://prism-0.23.0/lib/prism/pack.rb:76
  def endian; end

  # The length of this directive (used for integers).
  #
  # source://prism-0.23.0/lib/prism/pack.rb:85
  def length; end

  # The length type of this directive (used for integers).
  #
  # source://prism-0.23.0/lib/prism/pack.rb:82
  def length_type; end

  # The type of signedness of the directive.
  #
  # source://prism-0.23.0/lib/prism/pack.rb:73
  def signed; end

  # The size of the directive.
  #
  # source://prism-0.23.0/lib/prism/pack.rb:79
  def size; end

  # A byteslice of the source string that this directive represents.
  #
  # source://prism-0.23.0/lib/prism/pack.rb:67
  def source; end

  # The type of the directive.
  #
  # source://prism-0.23.0/lib/prism/pack.rb:70
  def type; end

  # A symbol representing whether or not we are packing or unpacking.
  #
  # source://prism-0.23.0/lib/prism/pack.rb:64
  def variant; end

  # A symbol representing the version of Ruby.
  #
  # source://prism-0.23.0/lib/prism/pack.rb:61
  def version; end
end

# The descriptions of the various types of endianness.
#
# source://prism-0.23.0/lib/prism/pack.rb:101
Prism::Pack::Directive::ENDIAN_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# The descriptions of the various types of signedness.
#
# source://prism-0.23.0/lib/prism/pack.rb:110
Prism::Pack::Directive::SIGNED_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# The descriptions of the various types of sizes.
#
# source://prism-0.23.0/lib/prism/pack.rb:117
Prism::Pack::Directive::SIZE_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::ENDIAN_NA = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::FLOAT = T.let(T.unsafe(nil), Symbol)

# The result of parsing a pack template.
#
# source://prism-0.23.0/lib/prism/pack.rb:195
class Prism::Pack::Format
  # Create a new Format with the given directives and encoding.
  #
  # @return [Format] a new instance of Format
  #
  # source://prism-0.23.0/lib/prism/pack.rb:203
  def initialize(directives, encoding); end

  # Provide a human-readable description of the format.
  #
  # source://prism-0.23.0/lib/prism/pack.rb:209
  def describe; end

  # A list of the directives in the template.
  #
  # source://prism-0.23.0/lib/prism/pack.rb:197
  def directives; end

  # The encoding of the template.
  #
  # source://prism-0.23.0/lib/prism/pack.rb:200
  def encoding; end
end

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::INTEGER = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::LENGTH_FIXED = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::LENGTH_MAX = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::LENGTH_NA = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::LENGTH_RELATIVE = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::LITTLE_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::MOVE = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::NATIVE_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::NULL = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SIGNED = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SIGNED_NA = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SIZE_16 = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SIZE_32 = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SIZE_64 = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SIZE_8 = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SIZE_INT = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SIZE_LONG = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SIZE_LONG_LONG = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SIZE_NA = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SIZE_P = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SIZE_SHORT = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::SPACE = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::STRING_BASE64 = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::STRING_FIXED = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::STRING_HEX_HIGH = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::STRING_HEX_LOW = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::STRING_LSB = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::STRING_MIME = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::STRING_MSB = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::STRING_NULL_PADDED = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::STRING_NULL_TERMINATED = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::STRING_POINTER = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::STRING_SPACE_PADDED = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::STRING_UU = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::UNSIGNED = T.let(T.unsafe(nil), Symbol)

# source://prism-0.23.0/lib/prism/pack.rb:55
Prism::Pack::UTF8 = T.let(T.unsafe(nil), Symbol)

# Flags for parameter nodes.
#
# source://prism-0.23.0/lib/prism/node.rb:17794
module Prism::ParameterFlags; end

# a parameter name that has been repeated in the method signature
#
# source://prism-0.23.0/lib/prism/node.rb:17796
Prism::ParameterFlags::REPEATED_PARAMETER = T.let(T.unsafe(nil), Integer)

# Represents the list of parameters on a method, block, or lambda definition.
#
#     def a(b, c, d)
#           ^^^^^^^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:13527
class Prism::ParametersNode < ::Prism::Node
  # def initialize: (Array[Node] requireds, Array[Node] optionals, Node? rest, Array[Node] posts, Array[Node] keywords, Node? keyword_rest, BlockParameterNode? block, Location location) -> void
  #
  # @return [ParametersNode] a new instance of ParametersNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13550
  def initialize(requireds, optionals, rest, posts, keywords, keyword_rest, block, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:13563
  def accept(visitor); end

  # attr_reader block: BlockParameterNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:13547
  sig { returns(T.nilable(Prism::BlockParameterNode)) }
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13568
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13586
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13573
  def compact_child_nodes; end

  # def copy: (**params) -> ParametersNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13591
  sig { params(params: T.untyped).returns(Prism::ParametersNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13568
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { requireds: Array[Node], optionals: Array[Node], rest: Node?, posts: Array[Node], keywords: Array[Node], keyword_rest: Node?, block: BlockParameterNode?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:13608
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13613
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader keyword_rest: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:13544
  sig { returns(T.nilable(Prism::Node)) }
  def keyword_rest; end

  # attr_reader keywords: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13541
  sig { returns(T::Array[Prism::Node]) }
  def keywords; end

  # attr_reader optionals: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13532
  sig { returns(T::Array[Prism::Node]) }
  def optionals; end

  # attr_reader posts: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13538
  sig { returns(T::Array[Prism::Node]) }
  def posts; end

  # attr_reader requireds: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13529
  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  # attr_reader rest: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:13535
  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  # Mirrors the Method#parameters method.
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:172
  def signature; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:13654
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:13664
    def type; end
  end
end

# Represents a parenthesized expression
#
#     (10 + 34)
#     ^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:13673
class Prism::ParenthesesNode < ::Prism::Node
  # def initialize: (Node? body, Location opening_loc, Location closing_loc, Location location) -> void
  #
  # @return [ParenthesesNode] a new instance of ParenthesesNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13684
  def initialize(body, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:13693
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:13675
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13702
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13742
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:13681
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13714
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13707
  def compact_child_nodes; end

  # def copy: (**params) -> ParenthesesNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13719
  sig { params(params: T.untyped).returns(Prism::ParenthesesNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13702
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { body: Node?, opening_loc: Location, closing_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:13732
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13747
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13737
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:13678
  sig { returns(Prism::Location) }
  def opening_loc; end

  # source://prism-0.23.0/lib/prism/node.rb:13697
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:13774
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:13784
    def type; end
  end
end

# This represents an error that was encountered during parsing.
#
# source://prism-0.23.0/lib/prism/parse_result.rb:338
class Prism::ParseError
  # Create a new error object with the given message and location.
  #
  # @return [ParseError] a new instance of ParseError
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:349
  def initialize(message, location, level); end

  # Implement the hash pattern matching interface for ParseError.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:356
  def deconstruct_keys(keys); end

  # Returns a string representation of this error.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:361
  def inspect; end

  # The level of this error.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:346
  def level; end

  # A Location object representing the location of this error in the source.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:343
  sig { returns(Prism::Location) }
  def location; end

  # The message associated with this error.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:340
  sig { returns(String) }
  def message; end
end

# This represents the result of a call to ::parse or ::parse_file. It contains
# the AST, any comments that were encounters, and any errors that were
# encountered.
#
# source://prism-0.23.0/lib/prism/parse_result.rb:398
class Prism::ParseResult
  # Create a new parse result object with the given values.
  #
  # @return [ParseResult] a new instance of ParseResult
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:425
  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  # Attach the list of comments to their respective locations in the tree.
  #
  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:173
  def attach_comments!; end

  # The list of comments that were encountered during parsing.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:405
  sig { returns(T::Array[Prism::Comment]) }
  def comments; end

  # An optional location that represents the location of the __END__ marker
  # and the rest of the content of the file. This content is loaded into the
  # DATA constant when the file being parsed is the main file being executed.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:413
  def data_loc; end

  # Implement the hash pattern matching interface for ParseResult.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:436
  def deconstruct_keys(keys); end

  # The list of errors that were generated during parsing.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:416
  sig { returns(T::Array[Prism::ParseError]) }
  def errors; end

  # Returns true if there were errors during parsing and false if there were
  # not.
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:448
  def failure?; end

  # The list of magic comments that were encountered during parsing.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:408
  def magic_comments; end

  # Walk the tree and mark nodes that are on a new line.
  #
  # source://prism-0.23.0/lib/prism/parse_result/newlines.rb:60
  def mark_newlines!; end

  # A Source instance that represents the source code that was parsed.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:422
  sig { returns(Prism::Source) }
  def source; end

  # Returns true if there were no errors during parsing and false if there
  # were.
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:442
  def success?; end

  # The value that was generated by parsing. Normally this holds the AST, but
  # it can sometimes how a list of tokens or other results passed back from
  # the parser.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:402
  sig { returns(Prism::ProgramNode) }
  def value; end

  # The list of warnings that were generated during parsing.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:419
  sig { returns(T::Array[Prism::ParseWarning]) }
  def warnings; end
end

# When we've parsed the source, we have both the syntax tree and the list of
# comments that we found in the source. This class is responsible for
# walking the tree and finding the nearest location to attach each comment.
#
# It does this by first finding the nearest locations to each comment.
# Locations can either come from nodes directly or from location fields on
# nodes. For example, a `ClassNode` has an overall location encompassing the
# entire class, but it also has a location for the `class` keyword.
#
# Once the nearest locations are found, it determines which one to attach
# to. If it's a trailing comment (a comment on the same line as other source
# code), it will favor attaching to the nearest location that occurs before
# the comment. Otherwise it will favor attaching to the nearest location
# that is after the comment.
#
# source://prism-0.23.0/lib/prism/parse_result/comments.rb:19
class Prism::ParseResult::Comments
  # Create a new Comments object that will attach comments to the given
  # parse result.
  #
  # @return [Comments] a new instance of Comments
  #
  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:78
  def initialize(parse_result); end

  # Attach the comments to their respective locations in the tree by
  # mutating the parse result.
  #
  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:84
  def attach!; end

  # The parse result that we are attaching comments to.
  #
  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:74
  def parse_result; end

  private

  # Responsible for finding the nearest targets to the given comment within
  # the context of the given encapsulating node.
  #
  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:103
  def nearest_targets(node, comment); end
end

# A target for attaching comments that is based on a location field on a
# node. For example, the `end` token of a ClassNode.
#
# source://prism-0.23.0/lib/prism/parse_result/comments.rb:49
class Prism::ParseResult::Comments::LocationTarget
  # @return [LocationTarget] a new instance of LocationTarget
  #
  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:52
  def initialize(location); end

  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:68
  def <<(comment); end

  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:64
  def encloses?(comment); end

  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:60
  def end_offset; end

  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:50
  def location; end

  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:56
  def start_offset; end
end

# A target for attaching comments that is based on a specific node's
# location.
#
# source://prism-0.23.0/lib/prism/parse_result/comments.rb:22
class Prism::ParseResult::Comments::NodeTarget
  # @return [NodeTarget] a new instance of NodeTarget
  #
  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:25
  def initialize(node); end

  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:42
  def <<(comment); end

  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:37
  def encloses?(comment); end

  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:33
  def end_offset; end

  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:23
  def node; end

  # source://prism-0.23.0/lib/prism/parse_result/comments.rb:29
  def start_offset; end
end

# The :line tracepoint event gets fired whenever the Ruby VM encounters an
# expression on a new line. The types of expressions that can trigger this
# event are:
#
# * if statements
# * unless statements
# * nodes that are children of statements lists
#
# In order to keep track of the newlines, we have a list of offsets that
# come back from the parser. We assign these offsets to the first nodes that
# we find in the tree that are on those lines.
#
# Note that the logic in this file should be kept in sync with the Java
# MarkNewlinesVisitor, since that visitor is responsible for marking the
# newlines for JRuby/TruffleRuby.
#
# source://prism-0.23.0/lib/prism/parse_result/newlines.rb:20
class Prism::ParseResult::Newlines < ::Prism::Visitor
  # Create a new Newlines visitor with the given newline offsets.
  #
  # @return [Newlines] a new instance of Newlines
  #
  # source://prism-0.23.0/lib/prism/parse_result/newlines.rb:22
  def initialize(newline_marked); end

  # Permit block/lambda nodes to mark newlines within themselves.
  #
  # source://prism-0.23.0/lib/prism/parse_result/newlines.rb:27
  def visit_block_node(node); end

  # Mark if/unless nodes as newlines.
  #
  # source://prism-0.23.0/lib/prism/parse_result/newlines.rb:41
  def visit_if_node(node); end

  # Permit block/lambda nodes to mark newlines within themselves.
  #
  # source://prism-0.23.0/lib/prism/parse_result/newlines.rb:27
  def visit_lambda_node(node); end

  # Permit statements lists to mark newlines within themselves.
  #
  # source://prism-0.23.0/lib/prism/parse_result/newlines.rb:49
  def visit_statements_node(node); end

  # Mark if/unless nodes as newlines.
  #
  # source://prism-0.23.0/lib/prism/parse_result/newlines.rb:41
  def visit_unless_node(node); end
end

# This represents a warning that was encountered during parsing.
#
# source://prism-0.23.0/lib/prism/parse_result.rb:367
class Prism::ParseWarning
  # Create a new warning object with the given message and location.
  #
  # @return [ParseWarning] a new instance of ParseWarning
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:378
  def initialize(message, location, level); end

  # Implement the hash pattern matching interface for ParseWarning.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:385
  def deconstruct_keys(keys); end

  # Returns a string representation of this warning.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:390
  def inspect; end

  # The level of this warning.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:375
  def level; end

  # A Location object representing the location of this warning in the source.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:372
  sig { returns(Prism::Location) }
  def location; end

  # The message associated with this warning.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:369
  sig { returns(String) }
  def message; end
end

# A pattern is an object that wraps a Ruby pattern matching expression. The
# expression would normally be passed to an `in` clause within a `case`
# expression or a rightward assignment expression. For example, in the
# following snippet:
#
#     case node
#     in ConstantPathNode[ConstantReadNode[name: :Prism], ConstantReadNode[name: :Pattern]]
#     end
#
# the pattern is the <tt>ConstantPathNode[...]</tt> expression.
#
# The pattern gets compiled into an object that responds to #call by running
# the #compile method. This method itself will run back through Prism to
# parse the expression into a tree, then walk the tree to generate the
# necessary callable objects. For example, if you wanted to compile the
# expression above into a callable, you would:
#
#     callable = Prism::Pattern.new("ConstantPathNode[ConstantReadNode[name: :Prism], ConstantReadNode[name: :Pattern]]").compile
#     callable.call(node)
#
# The callable object returned by #compile is guaranteed to respond to #call
# with a single argument, which is the node to match against. It also is
# guaranteed to respond to #===, which means it itself can be used in a `case`
# expression, as in:
#
#     case node
#     when callable
#     end
#
# If the query given to the initializer cannot be compiled into a valid
# matcher (either because of a syntax error or because it is using syntax we
# do not yet support) then a Prism::Pattern::CompilationError will be
# raised.
#
# source://prism-0.23.0/lib/prism/pattern.rb:37
class Prism::Pattern
  # Create a new pattern with the given query. The query should be a string
  # containing a Ruby pattern matching expression.
  #
  # @return [Pattern] a new instance of Pattern
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:63
  def initialize(query); end

  # Compile the query into a callable object that can be used to match against
  # nodes.
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:70
  def compile; end

  # The query that this pattern was initialized with.
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:59
  def query; end

  # Scan the given node and all of its children for nodes that match the
  # pattern. If a block is given, it will be called with each node that
  # matches the pattern. If no block is given, an enumerator will be returned
  # that will yield each node that matches the pattern.
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:79
  def scan(root); end

  private

  # Shortcut for combining two procs into one that returns true if both return
  # true.
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:95
  def combine_and(left, right); end

  # Shortcut for combining two procs into one that returns true if either
  # returns true.
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:101
  def combine_or(left, right); end

  # in foo | bar
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:136
  def compile_alternation_pattern_node(node); end

  # in [foo, bar, baz]
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:111
  def compile_array_pattern_node(node); end

  # in Prism::ConstantReadNode
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:141
  def compile_constant_path_node(node); end

  # in ConstantReadNode
  # in String
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:153
  def compile_constant_read_node(node); end

  # Raise an error because the given node is not supported.
  #
  # @raise [CompilationError]
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:106
  def compile_error(node); end

  # in InstanceVariableReadNode[name: Symbol]
  # in { name: Symbol }
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:171
  def compile_hash_pattern_node(node); end

  # in nil
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:196
  def compile_nil_node(node); end

  # Compile any kind of node. Dispatch out to the individual compilation
  # methods based on the type of node.
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:225
  def compile_node(node); end

  # in /foo/
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:201
  def compile_regular_expression_node(node); end

  # in ""
  # in "foo"
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:209
  def compile_string_node(node); end

  # in :+
  # in :foo
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:217
  def compile_symbol_node(node); end
end

# Raised when the query given to a pattern is either invalid Ruby syntax or
# is using syntax that we don't yet support.
#
# source://prism-0.23.0/lib/prism/pattern.rb:40
class Prism::Pattern::CompilationError < ::StandardError
  # Create a new CompilationError with the given representation of the node
  # that caused the error.
  #
  # @return [CompilationError] a new instance of CompilationError
  #
  # source://prism-0.23.0/lib/prism/pattern.rb:43
  def initialize(repr); end
end

# Represents the use of the `^` operator for pinning an expression in a pattern matching expression.
#
#     foo in ^(bar)
#            ^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:13793
class Prism::PinnedExpressionNode < ::Prism::Node
  # def initialize: (Node expression, Location operator_loc, Location lparen_loc, Location rparen_loc, Location location) -> void
  #
  # @return [PinnedExpressionNode] a new instance of PinnedExpressionNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13807
  def initialize(expression, operator_loc, lparen_loc, rparen_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:13817
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13822
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13832
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13827
  def compact_child_nodes; end

  # def copy: (**params) -> PinnedExpressionNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13837
  sig { params(params: T.untyped).returns(Prism::PinnedExpressionNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13822
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { expression: Node, operator_loc: Location, lparen_loc: Location, rparen_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:13851
  def deconstruct_keys(keys); end

  # attr_reader expression: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:13795
  sig { returns(Prism::Node) }
  def expression; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13871
  def inspect(inspector = T.unsafe(nil)); end

  # def lparen: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13861
  sig { returns(String) }
  def lparen; end

  # attr_reader lparen_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:13801
  sig { returns(Prism::Location) }
  def lparen_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13856
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:13798
  sig { returns(Prism::Location) }
  def operator_loc; end

  # def rparen: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13866
  sig { returns(String) }
  def rparen; end

  # attr_reader rparen_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:13804
  sig { returns(Prism::Location) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:13895
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:13905
    def type; end
  end
end

# Represents the use of the `^` operator for pinning a variable in a pattern matching expression.
#
#     foo in ^bar
#            ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:13914
class Prism::PinnedVariableNode < ::Prism::Node
  # def initialize: (Node variable, Location operator_loc, Location location) -> void
  #
  # @return [PinnedVariableNode] a new instance of PinnedVariableNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13922
  def initialize(variable, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:13930
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13935
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13945
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13940
  def compact_child_nodes; end

  # def copy: (**params) -> PinnedVariableNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:13950
  sig { params(params: T.untyped).returns(Prism::PinnedVariableNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:13935
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { variable: Node, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:13962
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13972
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:13967
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:13919
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:13994
  def type; end

  # attr_reader variable: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:13916
  sig { returns(Prism::Node) }
  def variable; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:14004
    def type; end
  end
end

# Represents the use of the `END` keyword.
#
#     END { foo }
#     ^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:14013
class Prism::PostExecutionNode < ::Prism::Node
  # def initialize: (StatementsNode? statements, Location keyword_loc, Location opening_loc, Location closing_loc, Location location) -> void
  #
  # @return [PostExecutionNode] a new instance of PostExecutionNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14027
  def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:14037
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14042
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14088
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:14024
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14054
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14047
  def compact_child_nodes; end

  # def copy: (**params) -> PostExecutionNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14059
  sig { params(params: T.untyped).returns(Prism::PostExecutionNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14042
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:14073
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14093
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14078
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:14018
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14083
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:14021
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:14015
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:14121
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:14131
    def type; end
  end
end

# Represents the use of the `BEGIN` keyword.
#
#     BEGIN { foo }
#     ^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:14140
class Prism::PreExecutionNode < ::Prism::Node
  # def initialize: (StatementsNode? statements, Location keyword_loc, Location opening_loc, Location closing_loc, Location location) -> void
  #
  # @return [PreExecutionNode] a new instance of PreExecutionNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14154
  def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:14164
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14169
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14215
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:14151
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14181
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14174
  def compact_child_nodes; end

  # def copy: (**params) -> PreExecutionNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14186
  sig { params(params: T.untyped).returns(Prism::PreExecutionNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14169
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:14200
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14220
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14205
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:14145
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14210
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:14148
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:14142
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:14248
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:14258
    def type; end
  end
end

# The top level node of any parse tree.
#
# source://prism-0.23.0/lib/prism/node.rb:14264
class Prism::ProgramNode < ::Prism::Node
  # def initialize: (Array[Symbol] locals, StatementsNode statements, Location location) -> void
  #
  # @return [ProgramNode] a new instance of ProgramNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14272
  def initialize(locals, statements, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:14280
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14285
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14295
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14290
  def compact_child_nodes; end

  # def copy: (**params) -> ProgramNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14300
  sig { params(params: T.untyped).returns(Prism::ProgramNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14285
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { locals: Array[Symbol], statements: StatementsNode, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:14312
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14317
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14266
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # attr_reader statements: StatementsNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14269
  sig { returns(Prism::StatementsNode) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:14339
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:14349
    def type; end
  end
end

# Flags for range and flip-flop nodes.
#
# source://prism-0.23.0/lib/prism/node.rb:17800
module Prism::RangeFlags; end

# ... operator
#
# source://prism-0.23.0/lib/prism/node.rb:17802
Prism::RangeFlags::EXCLUDE_END = T.let(T.unsafe(nil), Integer)

# Represents the use of the `..` or `...` operators.
#
#     1..2
#     ^^^^
#
#     c if a =~ /left/ ... b =~ /right/
#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:14361
class Prism::RangeNode < ::Prism::Node
  # def initialize: (Integer flags, Node? left, Node? right, Location operator_loc, Location location) -> void
  #
  # @return [RangeNode] a new instance of RangeNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14389
  def initialize(flags, left, right, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:14399
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14404
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14417
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14409
  def compact_child_nodes; end

  # def copy: (**params) -> RangeNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14422
  sig { params(params: T.untyped).returns(Prism::RangeNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14404
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, left: Node?, right: Node?, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:14436
  def deconstruct_keys(keys); end

  # def exclude_end?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14441
  sig { returns(T::Boolean) }
  def exclude_end?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14451
  def inspect(inspector = T.unsafe(nil)); end

  # The left-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     1...
  #     ^
  #
  #     hello...goodbye
  #     ^^^^^
  #
  # source://prism-0.23.0/lib/prism/node.rb:14373
  sig { returns(T.nilable(Prism::Node)) }
  def left; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14446
  sig { returns(String) }
  def operator; end

  # The location of the `..` or `...` operator.
  #
  # source://prism-0.23.0/lib/prism/node.rb:14386
  sig { returns(Prism::Location) }
  def operator_loc; end

  # The right-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     ..5
  #       ^
  #
  #     1...foo
  #         ^^^
  # If neither right-hand or left-hand side was included, this will be a MissingNode.
  #
  # source://prism-0.23.0/lib/prism/node.rb:14383
  sig { returns(T.nilable(Prism::Node)) }
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:14485
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:14363
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:14495
    def type; end
  end
end

# Represents a rational number literal.
#
#     1.0r
#     ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:14504
class Prism::RationalNode < ::Prism::Node
  # def initialize: (Node numeric, Location location) -> void
  #
  # @return [RationalNode] a new instance of RationalNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14509
  def initialize(numeric, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:14516
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14521
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14531
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14526
  def compact_child_nodes; end

  # def copy: (**params) -> RationalNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14536
  sig { params(params: T.untyped).returns(Prism::RationalNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14521
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { numeric: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:14547
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14552
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader numeric: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:14506
  sig { returns(Prism::Node) }
  def numeric; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:14573
  def type; end

  # Returns the value of the node as a Ruby Rational.
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:83
  def value; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:14583
    def type; end
  end
end

# Represents the use of the `redo` keyword.
#
#     redo
#     ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:14592
class Prism::RedoNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [RedoNode] a new instance of RedoNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14594
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:14600
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14605
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14615
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14610
  def compact_child_nodes; end

  # def copy: (**params) -> RedoNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14620
  sig { params(params: T.untyped).returns(Prism::RedoNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14605
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:14630
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14635
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:14654
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:14664
    def type; end
  end
end

# Flags for regular expression and match last line nodes.
#
# source://prism-0.23.0/lib/prism/node.rb:17806
module Prism::RegularExpressionFlags; end

# n - forces the ASCII-8BIT encoding
#
# source://prism-0.23.0/lib/prism/node.rb:17823
Prism::RegularExpressionFlags::ASCII_8BIT = T.let(T.unsafe(nil), Integer)

# e - forces the EUC-JP encoding
#
# source://prism-0.23.0/lib/prism/node.rb:17820
Prism::RegularExpressionFlags::EUC_JP = T.let(T.unsafe(nil), Integer)

# x - ignores whitespace and allows comments in regular expressions
#
# source://prism-0.23.0/lib/prism/node.rb:17811
Prism::RegularExpressionFlags::EXTENDED = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to binary
#
# source://prism-0.23.0/lib/prism/node.rb:17835
Prism::RegularExpressionFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to US-ASCII
#
# source://prism-0.23.0/lib/prism/node.rb:17838
Prism::RegularExpressionFlags::FORCED_US_ASCII_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to UTF-8
#
# source://prism-0.23.0/lib/prism/node.rb:17832
Prism::RegularExpressionFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

# i - ignores the case of characters when matching
#
# source://prism-0.23.0/lib/prism/node.rb:17808
Prism::RegularExpressionFlags::IGNORE_CASE = T.let(T.unsafe(nil), Integer)

# m - allows $ to match the end of lines within strings
#
# source://prism-0.23.0/lib/prism/node.rb:17814
Prism::RegularExpressionFlags::MULTI_LINE = T.let(T.unsafe(nil), Integer)

# o - only interpolates values into the regular expression once
#
# source://prism-0.23.0/lib/prism/node.rb:17817
Prism::RegularExpressionFlags::ONCE = T.let(T.unsafe(nil), Integer)

# u - forces the UTF-8 encoding
#
# source://prism-0.23.0/lib/prism/node.rb:17829
Prism::RegularExpressionFlags::UTF_8 = T.let(T.unsafe(nil), Integer)

# s - forces the Windows-31J encoding
#
# source://prism-0.23.0/lib/prism/node.rb:17826
Prism::RegularExpressionFlags::WINDOWS_31J = T.let(T.unsafe(nil), Integer)

# Represents a regular expression literal with no interpolation.
#
#     /foo/i
#     ^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:14673
class Prism::RegularExpressionNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # def initialize: (Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped, Location location) -> void
  #
  # @return [RegularExpressionNode] a new instance of RegularExpressionNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14691
  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:14702
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14767
  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14707
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14807
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:14685
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14717
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14712
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14802
  sig { returns(String) }
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:14682
  sig { returns(Prism::Location) }
  def content_loc; end

  # def copy: (**params) -> RegularExpressionNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14722
  sig { params(params: T.untyped).returns(Prism::RegularExpressionNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14707
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:14737
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14762
  sig { returns(T::Boolean) }
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14747
  sig { returns(T::Boolean) }
  def extended?; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14787
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14792
  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14782
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14742
  sig { returns(T::Boolean) }
  def ignore_case?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14812
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14752
  sig { returns(T::Boolean) }
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14757
  sig { returns(T::Boolean) }
  def once?; end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14797
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:14679
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:14837
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14688
  sig { returns(String) }
  def unescaped; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14777
  sig { returns(T::Boolean) }
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14772
  sig { returns(T::Boolean) }
  def windows_31j?; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:14675
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:14847
    def type; end
  end
end

# source://prism-0.23.0/lib/prism/node_ext.rb:6
module Prism::RegularExpressionOptions
  # Returns a numeric value that represents the flags that were used to create
  # the regular expression.
  #
  # source://prism-0.23.0/lib/prism/node_ext.rb:9
  def options; end
end

# Represents a required keyword parameter to a method, block, or lambda definition.
#
#     def a(b: )
#           ^^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:14857
class Prism::RequiredKeywordParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol name, Location name_loc, Location location) -> void
  #
  # @return [RequiredKeywordParameterNode] a new instance of RequiredKeywordParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14869
  def initialize(flags, name, name_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:14878
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14883
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14893
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14888
  def compact_child_nodes; end

  # def copy: (**params) -> RequiredKeywordParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14898
  sig { params(params: T.untyped).returns(Prism::RequiredKeywordParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14883
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol, name_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:14911
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:14921
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:14863
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:14866
  sig { returns(Prism::Location) }
  def name_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14916
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:14944
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:14859
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:14954
    def type; end
  end
end

# Represents a required parameter to a method, block, or lambda definition.
#
#     def a(b)
#           ^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:14964
class Prism::RequiredParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol name, Location location) -> void
  #
  # @return [RequiredParameterNode] a new instance of RequiredParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:14973
  def initialize(flags, name, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:14981
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14986
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14996
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14991
  def compact_child_nodes; end

  # def copy: (**params) -> RequiredParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15001
  sig { params(params: T.untyped).returns(Prism::RequiredParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:14986
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:15013
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15023
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:14970
  sig { returns(Symbol) }
  def name; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15018
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:15045
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:14966
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:15055
    def type; end
  end
end

# Represents an expression modified with a rescue.
#
#     foo rescue nil
#     ^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:15064
class Prism::RescueModifierNode < ::Prism::Node
  # def initialize: (Node expression, Location keyword_loc, Node rescue_expression, Location location) -> void
  #
  # @return [RescueModifierNode] a new instance of RescueModifierNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15075
  def initialize(expression, keyword_loc, rescue_expression, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:15084
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15093
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15103
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15098
  def compact_child_nodes; end

  # def copy: (**params) -> RescueModifierNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15108
  sig { params(params: T.untyped).returns(Prism::RescueModifierNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15093
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { expression: Node, keyword_loc: Location, rescue_expression: Node, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:15121
  def deconstruct_keys(keys); end

  # attr_reader expression: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:15066
  sig { returns(Prism::Node) }
  def expression; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15131
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15126
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:15069
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader rescue_expression: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:15072
  sig { returns(Prism::Node) }
  def rescue_expression; end

  # source://prism-0.23.0/lib/prism/node.rb:15088
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:15155
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:15165
    def type; end
  end
end

# Represents a rescue statement.
#
#     begin
#     rescue Foo, *splat, Bar => ex
#       foo
#     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#     end
#
# `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `exception` field.
#
# source://prism-0.23.0/lib/prism/node.rb:15179
class Prism::RescueNode < ::Prism::Node
  # def initialize: (Location keyword_loc, Array[Node] exceptions, Location? operator_loc, Node? reference, StatementsNode? statements, RescueNode? consequent, Location location) -> void
  #
  # @return [RescueNode] a new instance of RescueNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15199
  def initialize(keyword_loc, exceptions, operator_loc, reference, statements, consequent, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:15211
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15216
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15231
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15221
  def compact_child_nodes; end

  # attr_reader consequent: RescueNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:15196
  sig { returns(T.nilable(Prism::RescueNode)) }
  def consequent; end

  # def copy: (**params) -> RescueNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15236
  sig { params(params: T.untyped).returns(Prism::RescueNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15216
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { keyword_loc: Location, exceptions: Array[Node], operator_loc: Location?, reference: Node?, statements: StatementsNode?, consequent: RescueNode?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:15252
  def deconstruct_keys(keys); end

  # attr_reader exceptions: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15184
  sig { returns(T::Array[Prism::Node]) }
  def exceptions; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15267
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15257
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:15181
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def operator: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:15262
  sig { returns(T.nilable(String)) }
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:15187
  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  # attr_reader reference: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:15190
  sig { returns(T.nilable(Prism::Node)) }
  def reference; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:15193
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:15307
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:15317
    def type; end
  end
end

# Represents a rest parameter to a method, block, or lambda definition.
#
#     def a(*b)
#           ^^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:15327
class Prism::RestParameterNode < ::Prism::Node
  # def initialize: (Integer flags, Symbol? name, Location? name_loc, Location operator_loc, Location location) -> void
  #
  # @return [RestParameterNode] a new instance of RestParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15342
  def initialize(flags, name, name_loc, operator_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:15352
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15357
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15367
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15362
  def compact_child_nodes; end

  # def copy: (**params) -> RestParameterNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15372
  sig { params(params: T.untyped).returns(Prism::RestParameterNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15357
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:15386
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15401
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol?
  #
  # source://prism-0.23.0/lib/prism/node.rb:15333
  sig { returns(T.nilable(Symbol)) }
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:15336
  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15396
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:15339
  sig { returns(Prism::Location) }
  def operator_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15391
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:15429
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:15329
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:15439
    def type; end
  end
end

# Represents the use of the `retry` keyword.
#
#     retry
#     ^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:15448
class Prism::RetryNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [RetryNode] a new instance of RetryNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15450
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:15456
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15461
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15471
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15466
  def compact_child_nodes; end

  # def copy: (**params) -> RetryNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15476
  sig { params(params: T.untyped).returns(Prism::RetryNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15461
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:15486
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15491
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:15510
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:15520
    def type; end
  end
end

# Represents the use of the `return` keyword.
#
#     return 1
#     ^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:15529
class Prism::ReturnNode < ::Prism::Node
  # def initialize: (Location keyword_loc, ArgumentsNode? arguments, Location location) -> void
  #
  # @return [ReturnNode] a new instance of ReturnNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15537
  def initialize(keyword_loc, arguments, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:15545
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:15534
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15550
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15562
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15555
  def compact_child_nodes; end

  # def copy: (**params) -> ReturnNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15567
  sig { params(params: T.untyped).returns(Prism::ReturnNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15550
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { keyword_loc: Location, arguments: ArgumentsNode?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:15579
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15589
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15584
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:15531
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:15615
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:15625
    def type; end
  end
end

# Represents the `self` keyword.
#
#     self
#     ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:15634
class Prism::SelfNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [SelfNode] a new instance of SelfNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15636
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:15642
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15647
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15657
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15652
  def compact_child_nodes; end

  # def copy: (**params) -> SelfNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15662
  sig { params(params: T.untyped).returns(Prism::SelfNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15647
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:15672
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15677
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:15696
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:15706
    def type; end
  end
end

# A module responsible for deserializing parse results.
#
# source://prism-0.23.0/lib/prism/serialize.rb:23
module Prism::Serialize
  class << self
    # Deserialize the AST represented by the given string into a parse result.
    #
    # source://prism-0.23.0/lib/prism/serialize.rb:37
    def load(input, serialized); end

    # Deserialize the tokens represented by the given string into a parse
    # result.
    #
    # source://prism-0.23.0/lib/prism/serialize.rb:49
    def load_tokens(source, serialized); end
  end
end

# source://prism-0.23.0/lib/prism/serialize.rb:53
class Prism::Serialize::Loader
  # @return [Loader] a new instance of Loader
  #
  # source://prism-0.23.0/lib/prism/serialize.rb:58
  def initialize(source, serialized); end

  # Returns the value of attribute constant_pool.
  #
  # source://prism-0.23.0/lib/prism/serialize.rb:55
  def constant_pool; end

  # Returns the value of attribute constant_pool_offset.
  #
  # source://prism-0.23.0/lib/prism/serialize.rb:55
  def constant_pool_offset; end

  # Returns the value of attribute encoding.
  #
  # source://prism-0.23.0/lib/prism/serialize.rb:54
  def encoding; end

  # Returns the value of attribute input.
  #
  # source://prism-0.23.0/lib/prism/serialize.rb:54
  def input; end

  # Returns the value of attribute io.
  #
  # source://prism-0.23.0/lib/prism/serialize.rb:54
  def io; end

  # source://prism-0.23.0/lib/prism/serialize.rb:96
  def load_comments; end

  # source://prism-0.23.0/lib/prism/serialize.rb:82
  def load_encoding; end

  # source://prism-0.23.0/lib/prism/serialize.rb:73
  def load_header; end

  # source://prism-0.23.0/lib/prism/serialize.rb:92
  def load_line_offsets; end

  # source://prism-0.23.0/lib/prism/serialize.rb:106
  def load_metadata; end

  # source://prism-0.23.0/lib/prism/serialize.rb:140
  def load_nodes; end

  # source://prism-0.23.0/lib/prism/serialize.rb:154
  def load_result; end

  # source://prism-0.23.0/lib/prism/serialize.rb:88
  def load_start_line; end

  # source://prism-0.23.0/lib/prism/serialize.rb:115
  def load_tokens; end

  # source://prism-0.23.0/lib/prism/serialize.rb:128
  def load_tokens_result; end

  # Returns the value of attribute serialized.
  #
  # source://prism-0.23.0/lib/prism/serialize.rb:54
  def serialized; end

  # Returns the value of attribute source.
  #
  # source://prism-0.23.0/lib/prism/serialize.rb:55
  def source; end

  # Returns the value of attribute start_line.
  #
  # source://prism-0.23.0/lib/prism/serialize.rb:56
  def start_line; end

  private

  # source://prism-0.23.0/lib/prism/serialize.rb:217
  def load_constant(index); end

  # source://prism-0.23.0/lib/prism/serialize.rb:193
  def load_embedded_string; end

  # source://prism-0.23.0/lib/prism/serialize.rb:247
  def load_error_level; end

  # source://prism-0.23.0/lib/prism/serialize.rb:209
  def load_location; end

  # source://prism-0.23.0/lib/prism/serialize.rb:274
  def load_node; end

  # source://prism-0.23.0/lib/prism/serialize.rb:242
  def load_optional_constant; end

  # source://prism-0.23.0/lib/prism/serialize.rb:213
  def load_optional_location; end

  # source://prism-0.23.0/lib/prism/serialize.rb:186
  def load_optional_node; end

  # source://prism-0.23.0/lib/prism/serialize.rb:238
  def load_required_constant; end

  # source://prism-0.23.0/lib/prism/serialize.rb:182
  def load_serialized_length; end

  # source://prism-0.23.0/lib/prism/serialize.rb:197
  def load_string; end

  # source://prism-0.23.0/lib/prism/serialize.rb:177
  def load_varsint; end

  # variable-length integer using https://en.wikipedia.org/wiki/LEB128
  # This is also what protobuf uses: https://protobuf.dev/programming-guides/encoding/#varints
  #
  # source://prism-0.23.0/lib/prism/serialize.rb:163
  def load_varuint; end

  # source://prism-0.23.0/lib/prism/serialize.rb:260
  def load_warning_level; end
end

# The major version of prism that we are expecting to find in the serialized
# strings.
#
# source://prism-0.23.0/lib/prism/serialize.rb:26
Prism::Serialize::MAJOR_VERSION = T.let(T.unsafe(nil), Integer)

# The minor version of prism that we are expecting to find in the serialized
# strings.
#
# source://prism-0.23.0/lib/prism/serialize.rb:30
Prism::Serialize::MINOR_VERSION = T.let(T.unsafe(nil), Integer)

# The patch version of prism that we are expecting to find in the serialized
# strings.
#
# source://prism-0.23.0/lib/prism/serialize.rb:34
Prism::Serialize::PATCH_VERSION = T.let(T.unsafe(nil), Integer)

# The token types that can be indexed by their enum values.
#
# source://prism-0.23.0/lib/prism/serialize.rb:1186
Prism::Serialize::TOKEN_TYPES = T.let(T.unsafe(nil), Array)

# Represents a singleton class declaration involving the `class` keyword.
#
#     class << self end
#     ^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:15715
class Prism::SingletonClassNode < ::Prism::Node
  # def initialize: (Array[Symbol] locals, Location class_keyword_loc, Location operator_loc, Node expression, Node? body, Location end_keyword_loc, Location location) -> void
  #
  # @return [SingletonClassNode] a new instance of SingletonClassNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15735
  def initialize(locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:15747
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:15729
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15752
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def class_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15791
  sig { returns(String) }
  def class_keyword; end

  # attr_reader class_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:15720
  sig { returns(Prism::Location) }
  def class_keyword_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15765
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15757
  def compact_child_nodes; end

  # def copy: (**params) -> SingletonClassNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15770
  sig { params(params: T.untyped).returns(Prism::SingletonClassNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15752
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { locals: Array[Symbol], class_keyword_loc: Location, operator_loc: Location, expression: Node, body: Node?, end_keyword_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:15786
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15801
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:15732
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # attr_reader expression: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:15726
  sig { returns(Prism::Node) }
  def expression; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15806
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15717
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15796
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:15723
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:15837
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:15847
    def type; end
  end
end

# This represents a source of Ruby code that has been parsed. It is used in
# conjunction with locations to allow them to resolve line numbers and source
# ranges.
#
# source://prism-0.23.0/lib/prism/parse_result.rb:7
class Prism::Source
  # Create a new source object with the given source code.
  #
  # @return [Source] a new instance of Source
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:18
  def initialize(source, start_line = T.unsafe(nil), offsets = T.unsafe(nil)); end

  # Return the column number in characters for the given byte offset.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:53
  def character_column(byte_offset); end

  # Return the character offset for the given byte offset.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:48
  def character_offset(byte_offset); end

  # Returns the column number in code units for the given encoding for the
  # given byte offset.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:70
  def code_units_column(byte_offset, encoding); end

  # Returns the offset from the start of the file for the given byte offset
  # counting in code units for the given encoding.
  #
  # This method is tested with UTF-8, UTF-16, and UTF-32. If there is the
  # concept of code units that differs from the number of characters in other
  # encodings, it is not captured here.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:63
  def code_units_offset(byte_offset, encoding); end

  # Return the column number for the given byte offset.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:43
  def column(byte_offset); end

  # Binary search through the offsets to find the line number for the given
  # byte offset.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:32
  def line(byte_offset); end

  sig { params(value: Integer).returns(Integer) }
  def line_offset(value); end

  # Return the byte offset of the start of the line corresponding to the given
  # byte offset.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:38
  def line_start(byte_offset); end

  # The list of newline byte offsets in the source code.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:15
  sig { returns(T::Array[Integer]) }
  def offsets; end

  # Perform a byteslice on the source code using the given byte offset and
  # byte length.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:26
  def slice(byte_offset, length); end

  # The source code that this source object represents.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:9
  sig { returns(String) }
  def source; end

  # The line number where this source starts.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:12
  def start_line; end

  private

  # Binary search through the offsets to find the line number for the given
  # byte offset.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:78
  def find_line(byte_offset); end
end

# Represents the use of the `__ENCODING__` keyword.
#
#     __ENCODING__
#     ^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:15856
class Prism::SourceEncodingNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [SourceEncodingNode] a new instance of SourceEncodingNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15858
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:15864
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15869
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15879
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15874
  def compact_child_nodes; end

  # def copy: (**params) -> SourceEncodingNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15884
  sig { params(params: T.untyped).returns(Prism::SourceEncodingNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15869
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:15894
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15899
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:15918
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:15928
    def type; end
  end
end

# Represents the use of the `__FILE__` keyword.
#
#     __FILE__
#     ^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:15937
class Prism::SourceFileNode < ::Prism::Node
  # def initialize: (String filepath, Location location) -> void
  #
  # @return [SourceFileNode] a new instance of SourceFileNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15942
  def initialize(filepath, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:15949
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15954
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15964
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15959
  def compact_child_nodes; end

  # def copy: (**params) -> SourceFileNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:15969
  sig { params(params: T.untyped).returns(Prism::SourceFileNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:15954
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { filepath: String, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:15980
  def deconstruct_keys(keys); end

  # attr_reader filepath: String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15939
  sig { returns(String) }
  def filepath; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:15985
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:16005
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:16015
    def type; end
  end
end

# Represents the use of the `__LINE__` keyword.
#
#     __LINE__
#     ^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:16024
class Prism::SourceLineNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [SourceLineNode] a new instance of SourceLineNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16026
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:16032
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16037
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16047
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16042
  def compact_child_nodes; end

  # def copy: (**params) -> SourceLineNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16052
  sig { params(params: T.untyped).returns(Prism::SourceLineNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16037
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:16062
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16067
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:16086
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:16096
    def type; end
  end
end

# Represents the use of the splat operator.
#
#     [*a]
#      ^^
#
# source://prism-0.23.0/lib/prism/node.rb:16105
class Prism::SplatNode < ::Prism::Node
  # def initialize: (Location operator_loc, Node? expression, Location location) -> void
  #
  # @return [SplatNode] a new instance of SplatNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16113
  def initialize(operator_loc, expression, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:16121
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16126
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16138
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16131
  def compact_child_nodes; end

  # def copy: (**params) -> SplatNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16143
  sig { params(params: T.untyped).returns(Prism::SplatNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16126
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { operator_loc: Location, expression: Node?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:16155
  def deconstruct_keys(keys); end

  # attr_reader expression: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16110
  sig { returns(T.nilable(Prism::Node)) }
  def expression; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16165
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16160
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:16107
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:16191
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:16201
    def type; end
  end
end

# Represents a set of statements contained within some scope.
#
#     foo; bar; baz
#     ^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:16210
class Prism::StatementsNode < ::Prism::Node
  # def initialize: (Array[Node] body, Location location) -> void
  #
  # @return [StatementsNode] a new instance of StatementsNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16215
  def initialize(body, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:16222
  def accept(visitor); end

  # attr_reader body: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16212
  sig { returns(T::Array[Prism::Node]) }
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16227
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16237
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16232
  def compact_child_nodes; end

  # def copy: (**params) -> StatementsNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16242
  sig { params(params: T.untyped).returns(Prism::StatementsNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16227
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { body: Array[Node], location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:16253
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16258
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:16278
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:16288
    def type; end
  end
end

# Flags for string nodes.
#
# source://prism-0.23.0/lib/prism/node.rb:17842
module Prism::StringFlags; end

# internal bytes forced the encoding to binary
#
# source://prism-0.23.0/lib/prism/node.rb:17847
Prism::StringFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to UTF-8
#
# source://prism-0.23.0/lib/prism/node.rb:17844
Prism::StringFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

# frozen by virtue of a `frozen_string_literal` comment
#
# source://prism-0.23.0/lib/prism/node.rb:17850
Prism::StringFlags::FROZEN = T.let(T.unsafe(nil), Integer)

# Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.
#
#     "foo"
#     ^^^^^
#
#     %w[foo]
#        ^^^
#
#     "foo #{bar} baz"
#      ^^^^      ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:16303
class Prism::StringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  # def initialize: (Integer flags, Location? opening_loc, Location content_loc, Location? closing_loc, String unescaped, Location location) -> void
  #
  # @return [StringNode] a new instance of StringNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16321
  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:16332
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16337
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16397
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16315
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16347
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16342
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16392
  sig { returns(String) }
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:16312
  sig { returns(Prism::Location) }
  def content_loc; end

  # def copy: (**params) -> StringNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16352
  sig { params(params: T.untyped).returns(Prism::StringNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16337
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location?, content_loc: Location, closing_loc: Location?, unescaped: String, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:16367
  def deconstruct_keys(keys); end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16377
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16372
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def frozen?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16382
  sig { returns(T::Boolean) }
  def frozen?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16402
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16387
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16309
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:16427
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16318
  sig { returns(String) }
  def unescaped; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:16305
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:16437
    def type; end
  end
end

# Represents the use of the `super` keyword with parentheses or arguments.
#
#     super()
#     ^^^^^^^
#
#     super foo, bar
#     ^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:16449
class Prism::SuperNode < ::Prism::Node
  # def initialize: (Location keyword_loc, Location? lparen_loc, ArgumentsNode? arguments, Location? rparen_loc, Node? block, Location location) -> void
  #
  # @return [SuperNode] a new instance of SuperNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16466
  def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, block, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:16477
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16457
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # attr_reader block: Node?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16463
  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16482
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16495
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16487
  def compact_child_nodes; end

  # def copy: (**params) -> SuperNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16500
  sig { params(params: T.untyped).returns(Prism::SuperNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16482
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, block: Node?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:16515
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16535
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16520
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:16451
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16525
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16454
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16530
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16460
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:16569
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:16579
    def type; end
  end
end

# Flags for symbol nodes.
#
# source://prism-0.23.0/lib/prism/node.rb:17854
module Prism::SymbolFlags; end

# internal bytes forced the encoding to binary
#
# source://prism-0.23.0/lib/prism/node.rb:17859
Prism::SymbolFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to US-ASCII
#
# source://prism-0.23.0/lib/prism/node.rb:17862
Prism::SymbolFlags::FORCED_US_ASCII_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to UTF-8
#
# source://prism-0.23.0/lib/prism/node.rb:17856
Prism::SymbolFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

# Represents a symbol literal or a symbol contained within a `%i` list.
#
#     :foo
#     ^^^^
#
#     %i[foo]
#        ^^^
#
# source://prism-0.23.0/lib/prism/node.rb:16591
class Prism::SymbolNode < ::Prism::Node
  # def initialize: (Integer flags, Location? opening_loc, Location? value_loc, Location? closing_loc, String unescaped, Location location) -> void
  #
  # @return [SymbolNode] a new instance of SymbolNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16609
  def initialize(flags, opening_loc, value_loc, closing_loc, unescaped, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:16620
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16625
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16685
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16603
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16635
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16630
  def compact_child_nodes; end

  # def copy: (**params) -> SymbolNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16640
  sig { params(params: T.untyped).returns(Prism::SymbolNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16625
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location?, value_loc: Location?, closing_loc: Location?, unescaped: String, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:16655
  def deconstruct_keys(keys); end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16665
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16670
  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16660
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16690
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16675
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16597
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:16715
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16606
  sig { returns(String) }
  def unescaped; end

  # def value: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16680
  sig { returns(T.nilable(String)) }
  def value; end

  # attr_reader value_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16600
  sig { returns(T.nilable(Prism::Location)) }
  def value_loc; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:16593
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:16725
    def type; end
  end
end

# This represents a token from the Ruby source.
#
# source://prism-0.23.0/lib/prism/parse_result.rb:454
class Prism::Token
  # Create a new token object with the given type, value, and location.
  #
  # @return [Token] a new instance of Token
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:465
  def initialize(type, value, location); end

  # Returns true if the given other token is equal to this token.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:492
  def ==(other); end

  # Implement the hash pattern matching interface for Token.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:472
  def deconstruct_keys(keys); end

  # A Location object representing the location of this token in the source.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:462
  sig { returns(Prism::Location) }
  def location; end

  # Implement the pretty print interface for Token.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:477
  def pretty_print(q); end

  # The type of token that this token is.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:456
  sig { returns(T.untyped) }
  def type; end

  # A byteslice of the source that this token represents.
  #
  # source://prism-0.23.0/lib/prism/parse_result.rb:459
  sig { returns(String) }
  def value; end
end

# This module is responsible for converting the prism syntax tree into other
# syntax trees.
#
# source://prism-0.23.0/lib/prism/translation.rb:6
module Prism::Translation; end

# This class is the entry-point for converting a prism syntax tree into the
# whitequark/parser gem's syntax tree. It inherits from the base parser for
# the parser gem, and overrides the parse* methods to parse with prism and
# then translate.
#
# source://prism-0.23.0/lib/prism/translation/parser.rb:11
class Prism::Translation::Parser < ::Parser::Base
  # The default encoding for Ruby files is UTF-8.
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:33
  def default_encoding; end

  # Parses a source buffer and returns the AST.
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:41
  def parse(source_buffer); end

  # Parses a source buffer and returns the AST and the source code comments.
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:54
  def parse_with_comments(source_buffer); end

  # Parses a source buffer and returns the AST, the source code comments,
  # and the tokens emitted by the lexer.
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:71
  def tokenize(source_buffer, recover = T.unsafe(nil)); end

  # Since prism resolves num params for us, we don't need to support this
  # kind of logic here.
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:97
  def try_declare_numparam(node); end

  # source://prism-0.23.0/lib/prism/translation/parser.rb:28
  def version; end

  # source://prism-0.23.0/lib/prism/translation/parser.rb:37
  def yyerror; end

  private

  # Build the parser gem AST from the prism AST.
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:146
  def build_ast(program, offset_cache); end

  # Build the parser gem comments from the prism comments.
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:151
  def build_comments(comments, offset_cache); end

  # Prism deals with offsets in bytes, while the parser gem deals with
  # offsets in characters. We need to handle this conversion in order to
  # build the parser gem AST.
  #
  # If the bytesize of the source is the same as the length, then we can
  # just use the offset directly. Otherwise, we build an array where the
  # index is the byte offset and the value is the character offset.
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:129
  def build_offset_cache(source); end

  # Build a range from a prism location.
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:163
  def build_range(location, offset_cache); end

  # Build the parser gem tokens from the prism tokens.
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:158
  def build_tokens(tokens, offset_cache); end

  # If there was a error generated during the parse, then raise an
  # appropriate syntax error. Otherwise return the result.
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:111
  def unwrap(result, offset_cache); end

  # This is a hook to allow consumers to disable some errors if they don't
  # want them to block creating the syntax tree.
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:105
  def valid_error?(error); end
end

# A visitor that knows how to convert a prism syntax tree into the
# whitequark/parser gem's syntax tree.
#
# source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:8
class Prism::Translation::Parser::Compiler < ::Prism::Compiler
  # Initialize a new compiler with the given parser, offset cache, and
  # options.
  #
  # @return [Compiler] a new instance of Compiler
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:39
  def initialize(parser, offset_cache, forwarding: T.unsafe(nil), in_destructure: T.unsafe(nil), in_pattern: T.unsafe(nil)); end

  # The Parser::Builders::Default instance that is being used to build the
  # AST.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:18
  def builder; end

  # The types of values that can be forwarded in the current scope.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:29
  def forwarding; end

  # Whether or not the current node is in a destructure.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:32
  def in_destructure; end

  # Whether or not the current node is in a pattern.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:35
  def in_pattern; end

  # The offset cache that is used to map between byte and character
  # offsets in the file.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:26
  def offset_cache; end

  # The Parser::Base instance that is being used to build the AST.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:14
  def parser; end

  # The Parser::Source::Buffer instance that is holding a reference to the
  # source code.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:22
  def source_buffer; end

  # alias $foo $bar
  # ^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:58
  def visit_alias_global_variable_node(node); end

  # alias foo bar
  # ^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:52
  def visit_alias_method_node(node); end

  # foo => bar | baz
  #        ^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:64
  def visit_alternation_pattern_node(node); end

  # a and b
  # ^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:70
  def visit_and_node(node); end

  # foo(bar)
  #     ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:101
  def visit_arguments_node(node); end

  # []
  # ^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:76
  def visit_array_node(node); end

  # foo => [bar]
  #        ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:82
  def visit_array_pattern_node(node); end

  # { a: 1 }
  #   ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:107
  def visit_assoc_node(node); end

  # def foo(**); bar(**); end
  #                  ^^
  #
  # { **foo }
  #   ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:141
  def visit_assoc_splat_node(node); end

  # $+
  # ^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:151
  def visit_back_reference_read_node(node); end

  # begin end
  # ^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:157
  def visit_begin_node(node); end

  # foo(&bar)
  #     ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:195
  def visit_block_argument_node(node); end

  # foo { |; bar| }
  #          ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:201
  def visit_block_local_variable_node(node); end

  # A block on a keyword or method call.
  #
  # @raise [CompilationError]
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:206
  def visit_block_node(node); end

  # def foo(&bar); end
  #         ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:212
  def visit_block_parameter_node(node); end

  # A block's parameters.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:217
  def visit_block_parameters_node(node); end

  # break
  # ^^^^^
  #
  # break foo
  # ^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:226
  def visit_break_node(node); end

  # foo.bar += baz
  # ^^^^^^^^^^^^^^^
  # foo.bar &&= baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:300
  def visit_call_and_write_node(node); end

  # foo
  # ^^^
  #
  # foo.bar
  # ^^^^^^^
  #
  # foo.bar() {}
  # ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:238
  def visit_call_node(node); end

  # foo.bar += baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:300
  def visit_call_operator_write_node(node); end

  # foo.bar += baz
  # ^^^^^^^^^^^^^^^
  # foo.bar ||= baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:300
  def visit_call_or_write_node(node); end

  # foo.bar, = 1
  # ^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:327
  def visit_call_target_node(node); end

  # foo => bar => baz
  #        ^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:339
  def visit_capture_pattern_node(node); end

  # case foo; in bar; end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:358
  def visit_case_match_node(node); end

  # case foo; when bar; end
  # ^^^^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:345
  def visit_case_node(node); end

  # class Foo; end
  # ^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:371
  def visit_class_node(node); end

  # @@foo += bar
  # ^^^^^^^^^^^^
  # @@foo &&= bar
  # ^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:403
  def visit_class_variable_and_write_node(node); end

  # @@foo += bar
  # ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:403
  def visit_class_variable_operator_write_node(node); end

  # @@foo += bar
  # ^^^^^^^^^^^^
  # @@foo ||= bar
  # ^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:403
  def visit_class_variable_or_write_node(node); end

  # @@foo
  # ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:384
  def visit_class_variable_read_node(node); end

  # @@foo, = bar
  # ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:421
  def visit_class_variable_target_node(node); end

  # @@foo = 1
  # ^^^^^^^^^
  #
  # @@foo, @@bar = 1
  # ^^^^^  ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:393
  def visit_class_variable_write_node(node); end

  # Foo += bar
  # ^^^^^^^^^^^
  # Foo &&= bar
  # ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:442
  def visit_constant_and_write_node(node); end

  # Foo += bar
  # ^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:442
  def visit_constant_operator_write_node(node); end

  # Foo += bar
  # ^^^^^^^^^^^
  # Foo ||= bar
  # ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:442
  def visit_constant_or_write_node(node); end

  # Foo::Bar += baz
  # ^^^^^^^^^^^^^^^
  # Foo::Bar &&= baz
  # ^^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:496
  def visit_constant_path_and_write_node(node); end

  # Foo::Bar
  # ^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:466
  def visit_constant_path_node(node); end

  # Foo::Bar += baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:496
  def visit_constant_path_operator_write_node(node); end

  # Foo::Bar += baz
  # ^^^^^^^^^^^^^^^
  # Foo::Bar ||= baz
  # ^^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:496
  def visit_constant_path_or_write_node(node); end

  # Foo::Bar, = baz
  # ^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:514
  def visit_constant_path_target_node(node); end

  # Foo::Bar = 1
  # ^^^^^^^^^^^^
  #
  # Foo::Foo, Bar::Bar = 1
  # ^^^^^^^^  ^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:486
  def visit_constant_path_write_node(node); end

  # Foo
  # ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:427
  def visit_constant_read_node(node); end

  # Foo, = bar
  # ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:460
  def visit_constant_target_node(node); end

  # Foo = 1
  # ^^^^^^^
  #
  # Foo, Bar = 1
  # ^^^  ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:436
  def visit_constant_write_node(node); end

  # def foo; end
  # ^^^^^^^^^^^^
  #
  # def self.foo; end
  # ^^^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:523
  def visit_def_node(node); end

  # defined? a
  # ^^^^^^^^^^
  #
  # defined?(a)
  # ^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:570
  def visit_defined_node(node); end

  # if foo then bar else baz end
  #                 ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:582
  def visit_else_node(node); end

  # "foo #{bar}"
  #      ^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:588
  def visit_embedded_statements_node(node); end

  # "foo #@bar"
  #      ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:598
  def visit_embedded_variable_node(node); end

  # begin; foo; ensure; bar; end
  #             ^^^^^^^^^^^^
  #
  # @raise [CompilationError]
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:604
  def visit_ensure_node(node); end

  # false
  # ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:610
  def visit_false_node(node); end

  # foo => [*, bar, *]
  #        ^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:616
  def visit_find_pattern_node(node); end

  # 0..5
  # ^^^^
  # if foo .. bar; end
  #    ^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1302
  def visit_flip_flop_node(node); end

  # 1.0
  # ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:628
  def visit_float_node(node); end

  # for foo in bar do end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:634
  def visit_for_node(node); end

  # def foo(...); bar(...); end
  #                   ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:652
  def visit_forwarding_arguments_node(node); end

  # def foo(...); end
  #         ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:658
  def visit_forwarding_parameter_node(node); end

  # super
  # ^^^^^
  #
  # super {}
  # ^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:667
  def visit_forwarding_super_node(node); end

  # $foo += bar
  # ^^^^^^^^^^^
  # $foo &&= bar
  # ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:698
  def visit_global_variable_and_write_node(node); end

  # $foo += bar
  # ^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:698
  def visit_global_variable_operator_write_node(node); end

  # $foo += bar
  # ^^^^^^^^^^^
  # $foo ||= bar
  # ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:698
  def visit_global_variable_or_write_node(node); end

  # $foo
  # ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:679
  def visit_global_variable_read_node(node); end

  # $foo, = bar
  # ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:716
  def visit_global_variable_target_node(node); end

  # $foo = 1
  # ^^^^^^^^
  #
  # $foo, $bar = 1
  # ^^^^  ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:688
  def visit_global_variable_write_node(node); end

  # {}
  # ^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:722
  def visit_hash_node(node); end

  # foo => {}
  #        ^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:732
  def visit_hash_pattern_node(node); end

  # if foo then bar end
  # ^^^^^^^^^^^^^^^^^^^
  #
  # bar if foo
  # ^^^^^^^^^^
  #
  # foo ? bar : baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:750
  def visit_if_node(node); end

  # 1i
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:791
  def visit_imaginary_node(node); end

  # { foo: }
  #   ^^^^
  #
  # @raise [CompilationError]
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:797
  def visit_implicit_node(node); end

  # foo { |bar,| }
  #           ^
  #
  # @raise [CompilationError]
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:803
  def visit_implicit_rest_node(node); end

  # case foo; in bar; end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:809
  def visit_in_node(node); end

  # foo[bar] += baz
  # ^^^^^^^^^^^^^^^
  # foo[bar] &&= baz
  # ^^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:835
  def visit_index_and_write_node(node); end

  # foo[bar] += baz
  # ^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:835
  def visit_index_operator_write_node(node); end

  # foo[bar] += baz
  # ^^^^^^^^^^^^^^^
  # foo[bar] ||= baz
  # ^^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:835
  def visit_index_or_write_node(node); end

  # foo[bar], = 1
  # ^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:861
  def visit_index_target_node(node); end

  # ^^^^^^^^^^^
  # ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:891
  def visit_instance_variable_and_write_node(node); end

  # ^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:891
  def visit_instance_variable_operator_write_node(node); end

  # ^^^^^^^^^^^
  # ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:891
  def visit_instance_variable_or_write_node(node); end

  # ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:872
  def visit_instance_variable_read_node(node); end

  # @foo, = bar
  # ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:909
  def visit_instance_variable_target_node(node); end

  # ^^^^^^^^
  #
  # @foo, @bar = 1
  # ^^^^  ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:881
  def visit_instance_variable_write_node(node); end

  # 1
  # ^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:915
  def visit_integer_node(node); end

  # /foo #{bar}/
  # ^^^^^^^^^^^^
  # if /foo #{bar}/ then end
  #    ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:921
  def visit_interpolated_match_last_line_node(node); end

  # /foo #{bar}/
  # ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:921
  def visit_interpolated_regular_expression_node(node); end

  # "foo #{bar}"
  # ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:936
  def visit_interpolated_string_node(node); end

  # :"foo #{bar}"
  # ^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:951
  def visit_interpolated_symbol_node(node); end

  # `foo #{bar}`
  # ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:961
  def visit_interpolated_x_string_node(node); end

  # foo(bar: baz)
  #     ^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:976
  def visit_keyword_hash_node(node); end

  # def foo(**bar); end
  #         ^^^^^
  #
  # def foo(**); end
  #         ^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:985
  def visit_keyword_rest_parameter_node(node); end

  # -> {}
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:993
  def visit_lambda_node(node); end

  # foo += bar
  # ^^^^^^^^^^
  # foo &&= bar
  # ^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1037
  def visit_local_variable_and_write_node(node); end

  # foo += bar
  # ^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1037
  def visit_local_variable_operator_write_node(node); end

  # foo += bar
  # ^^^^^^^^^^
  # foo ||= bar
  # ^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1037
  def visit_local_variable_or_write_node(node); end

  # foo
  # ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1018
  def visit_local_variable_read_node(node); end

  # foo, = bar
  # ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1055
  def visit_local_variable_target_node(node); end

  # foo = 1
  # ^^^^^^^
  #
  # foo, bar = 1
  # ^^^  ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1027
  def visit_local_variable_write_node(node); end

  # /foo/
  # ^^^^^
  # if /foo/ then end
  #    ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1336
  def visit_match_last_line_node(node); end

  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1066
  def visit_match_predicate_node(node); end

  # foo => bar
  # ^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1085
  def visit_match_required_node(node); end

  # /(?<foo>foo)/ =~ bar
  # ^^^^^^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1095
  def visit_match_write_node(node); end

  # A node that is missing from the syntax tree. This is only used in the
  # case of a syntax error. The parser gem doesn't have such a concept, so
  # we invent our own here.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1106
  def visit_missing_node(node); end

  # module Foo; end
  # ^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1112
  def visit_module_node(node); end

  # foo, bar = baz
  # ^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1123
  def visit_multi_target_node(node); end

  # foo, bar = baz
  # ^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1137
  def visit_multi_write_node(node); end

  # next
  # ^^^^
  #
  # next foo
  # ^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1158
  def visit_next_node(node); end

  # nil
  # ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1170
  def visit_nil_node(node); end

  # def foo(**nil); end
  #         ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1176
  def visit_no_keywords_parameter_node(node); end

  # -> { _1 + _2 }
  # ^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1186
  def visit_numbered_parameters_node(node); end

  # $1
  # ^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1192
  def visit_numbered_reference_read_node(node); end

  # def foo(bar: baz); end
  #         ^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1198
  def visit_optional_keyword_parameter_node(node); end

  # def foo(bar = 1); end
  #         ^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1204
  def visit_optional_parameter_node(node); end

  # a or b
  # ^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1210
  def visit_or_node(node); end

  # def foo(bar, *baz); end
  #         ^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1216
  def visit_parameters_node(node); end

  # ()
  # ^^
  #
  # (1)
  # ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1255
  def visit_parentheses_node(node); end

  # foo => ^(bar)
  #        ^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1265
  def visit_pinned_expression_node(node); end

  # foo = 1 and bar => ^foo
  #                    ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1271
  def visit_pinned_variable_node(node); end

  # END {}
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1276
  def visit_post_execution_node(node); end

  # BEGIN {}
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1286
  def visit_pre_execution_node(node); end

  # The top-level program node.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1296
  def visit_program_node(node); end

  # 0..5
  # ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1302
  def visit_range_node(node); end

  # 1r
  # ^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1324
  def visit_rational_node(node); end

  # redo
  # ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1330
  def visit_redo_node(node); end

  # /foo/
  # ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1336
  def visit_regular_expression_node(node); end

  # def foo(bar:); end
  #         ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1351
  def visit_required_keyword_parameter_node(node); end

  # def foo(bar); end
  #         ^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1357
  def visit_required_parameter_node(node); end

  # foo rescue bar
  # ^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1363
  def visit_rescue_modifier_node(node); end

  # begin; rescue; end
  #        ^^^^^^^
  #
  # @raise [CompilationError]
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1381
  def visit_rescue_node(node); end

  # def foo(*bar); end
  #         ^^^^
  #
  # def foo(*); end
  #         ^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1390
  def visit_rest_parameter_node(node); end

  # retry
  # ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1396
  def visit_retry_node(node); end

  # return
  # ^^^^^^
  #
  # return 1
  # ^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1405
  def visit_return_node(node); end

  # self
  # ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1417
  def visit_self_node(node); end

  # class << self; end
  # ^^^^^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1423
  def visit_singleton_class_node(node); end

  # __ENCODING__
  # ^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1435
  def visit_source_encoding_node(node); end

  # __FILE__
  # ^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1441
  def visit_source_file_node(node); end

  # __LINE__
  # ^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1447
  def visit_source_line_node(node); end

  # foo(*bar)
  #     ^^^^
  #
  # def foo((bar, *baz)); end
  #               ^^^^
  #
  # def foo(*); bar(*); end
  #                 ^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1459
  def visit_splat_node(node); end

  # A list of statements.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1472
  def visit_statements_node(node); end

  # "foo"
  # ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1478
  def visit_string_node(node); end

  # super(foo)
  # ^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1495
  def visit_super_node(node); end

  # :foo
  # ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1518
  def visit_symbol_node(node); end

  # true
  # ^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1536
  def visit_true_node(node); end

  # undef foo
  # ^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1542
  def visit_undef_node(node); end

  # unless foo; bar end
  # ^^^^^^^^^^^^^^^^^^^
  #
  # bar unless foo
  # ^^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1551
  def visit_unless_node(node); end

  # until foo; bar end
  # ^^^^^^^^^^^^^^^^^
  #
  # bar until foo
  # ^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1581
  def visit_until_node(node); end

  # case foo; when bar; end
  #           ^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1603
  def visit_when_node(node); end

  # while foo; bar end
  # ^^^^^^^^^^^^^^^^^^
  #
  # bar while foo
  # ^^^^^^^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1617
  def visit_while_node(node); end

  # `foo`
  # ^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1639
  def visit_x_string_node(node); end

  # yield
  # ^^^^^
  #
  # yield 1
  # ^^^^^^^
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1657
  def visit_yield_node(node); end

  private

  # Initialize a new compiler with the given option overrides, used to
  # visit a subtree with the given options.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1671
  def copy_compiler(forwarding: T.unsafe(nil), in_destructure: T.unsafe(nil), in_pattern: T.unsafe(nil)); end

  # When *, **, &, or ... are used as an argument in a method call, we
  # check if they were allowed by the current context. To determine that
  # we build this lookup table.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1678
  def find_forwarding(node); end

  # Blocks can have a special set of parameters that automatically expand
  # when given arrays if they have a single required parameter and no
  # other parameters.
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1693
  def procarg0?(parameters); end

  # Constructs a new source range from the given start and end offsets.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1710
  def srange(location); end

  # Constructs a new source range by finding the given tokens between the
  # given start offset and end offset. If the needle is not found, it
  # returns nil.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1722
  def srange_find(start_offset, end_offset, tokens); end

  # Constructs a new source range from the given start and end offsets.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1715
  def srange_offsets(start_offset, end_offset); end

  # Transform a location into a token that the parser gem expects.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1731
  def token(location); end

  # Visit a block node on a call.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1736
  def visit_block(call, block); end

  # Visit a heredoc that can be either a string or an xstring.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1769
  def visit_heredoc(node); end

  # Visit a numeric node and account for the optional sign.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1815
  def visit_numeric(node, value); end

  # Within the given block, track that we're within a pattern.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1827
  def within_pattern; end
end

# Raised when the tree is malformed or there is a bug in the compiler.
#
# source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:10
class Prism::Translation::Parser::Compiler::CompilationError < ::StandardError; end

# Locations in the parser gem AST are generated using this class. We
# store a reference to its constant to make it slightly faster to look
# up.
#
# source://prism-0.23.0/lib/prism/translation/parser/compiler.rb:1707
Prism::Translation::Parser::Compiler::Range = Parser::Source::Range

# The parser gem has a list of diagnostics with a hard-coded set of error
# messages. We create our own diagnostic class in order to set our own
# error messages.
#
# source://prism-0.23.0/lib/prism/translation/parser.rb:15
class Prism::Translation::Parser::Diagnostic < ::Parser::Diagnostic
  # Initialize a new diagnostic with the given message and location.
  #
  # @return [Diagnostic] a new instance of Diagnostic
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:20
  def initialize(message, location); end

  # The message generated by prism.
  #
  # source://prism-0.23.0/lib/prism/translation/parser.rb:17
  def message; end
end

# Accepts a list of prism tokens and converts them into the expected
# format for the parser gem.
#
# source://prism-0.23.0/lib/prism/translation/parser/lexer.rb:8
class Prism::Translation::Parser::Lexer
  # Initialize the lexer with the given source buffer, prism tokens, and
  # offset cache.
  #
  # @return [Lexer] a new instance of Lexer
  #
  # source://prism-0.23.0/lib/prism/translation/parser/lexer.rb:193
  def initialize(source_buffer, lexed, offset_cache); end

  # An array of prism tokens that we lexed.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/lexer.rb:186
  def lexed; end

  # A hash that maps offsets in bytes to offsets in characters.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/lexer.rb:189
  def offset_cache; end

  # The Parser::Source::Buffer that the tokens were lexed from.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/lexer.rb:183
  def source_buffer; end

  # Convert the prism tokens into the expected format for the parser gem.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/lexer.rb:203
  def to_a; end

  private

  # Parse a complex from the string representation.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/lexer.rb:310
  def parse_complex(value); end

  # Parse a rational from the string representation.
  #
  # source://prism-0.23.0/lib/prism/translation/parser/lexer.rb:323
  def parse_rational(value); end
end

# source://prism-0.23.0/lib/prism/translation/parser/lexer.rb:199
Prism::Translation::Parser::Lexer::Range = Parser::Source::Range

# The direct translating of types between the two lexers.
#
# source://prism-0.23.0/lib/prism/translation/parser/lexer.rb:10
Prism::Translation::Parser::Lexer::TYPES = T.let(T.unsafe(nil), Hash)

# Note: This integration is not finished, and therefore still has many
# inconsistencies with Ripper. If you'd like to help out, pull requests would
# be greatly appreciated!
#
# This class is meant to provide a compatibility layer between prism and
# Ripper. It functions by parsing the entire tree first and then walking it
# and executing each of the Ripper callbacks as it goes.
#
# This class is going to necessarily be slower than the native Ripper API. It
# is meant as a stopgap until developers migrate to using prism. It is also
# meant as a test harness for the prism parser.
#
# To use this class, you treat `Prism::Translation::Ripper` effectively as you would
# treat the `Ripper` class.
#
# source://prism-0.23.0/lib/prism/translation/ripper.rb:21
class Prism::Translation::Ripper < ::Prism::Compiler
  # Create a new Translation::Ripper object with the given source.
  #
  # @return [Ripper] a new instance of Ripper
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:75
  def initialize(source); end

  # The current column number of the parser.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:72
  def column; end

  # True if the parser encountered an error during parsing.
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:87
  def error?; end

  # The current line number of the parser.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:69
  def lineno; end

  # Parse the source and return the result.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:92
  def parse; end

  # The source that is being parsed.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:66
  def source; end

  # Visit an AndNode.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:226
  def visit_and_node(node); end

  # Visit an ArrayNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:113
  def visit_array_node(node); end

  # Visit a BeginNode node.
  # This is not at all bulletproof against different structures of begin/rescue/else/ensure/end.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:277
  def visit_begin_node(node); end

  # Visit a BlockNode.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:191
  def visit_block_node(node); end

  # Visit a BlockParametersNode.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:200
  def visit_block_parameters_node(node); end

  # Visit a BreakNode.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:218
  def visit_break_node(node); end

  # Visit a CallNode node.
  # Ripper distinguishes between many different method-call
  # nodes -- unary and binary operators, "command" calls with
  # no parentheses, and call/fcall/vcall.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:123
  def visit_call_node(node); end

  # Visit an EmbeddedStatementsNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:349
  def visit_embedded_statements_node(node); end

  # Visit a FalseNode.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:242
  def visit_false_node(node); end

  # Visit a FloatNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:248
  def visit_float_node(node); end

  # Visit a ImaginaryNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:253
  def visit_imaginary_node(node); end

  # Visit an IntegerNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:258
  def visit_integer_node(node); end

  # Visit an InterpolatedStringNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:328
  def visit_interpolated_string_node(node); end

  # Visit a LocalVariableAndWriteNode.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:168
  def visit_local_variable_and_write_node(node); end

  # Visit nodes for +=, *=, -=, etc., called LocalVariableOperatorWriteNodes.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:178
  def visit_local_variable_operator_write_node(node); end

  # Visit a LocalVariableOrWriteNode.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:173
  def visit_local_variable_or_write_node(node); end

  # Visit a LocalVariableReadNode.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:183
  def visit_local_variable_read_node(node); end

  # Visit a LocalVariableWriteNode.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:161
  def visit_local_variable_write_node(node); end

  # Visit an OrNode.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:231
  def visit_or_node(node); end

  # Visit a ParametersNode.
  # This will require expanding as we support more kinds of parameters.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:206
  def visit_parameters_node(node); end

  # Visit a ParenthesesNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:263
  def visit_parentheses_node(node); end

  # Visit a ProgramNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:289
  def visit_program_node(node); end

  # Visit a RangeNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:296
  def visit_range_node(node); end

  # Visit a RationalNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:309
  def visit_rational_node(node); end

  # Visit a RequiredParameterNode.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:212
  def visit_required_parameter_node(node); end

  # Visit a RescueNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:284
  def visit_rescue_node(node); end

  # Visit a StatementsNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:367
  def visit_statements_node(node); end

  # Visit a StringNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:314
  def visit_string_node(node); end

  # Visit a SymbolNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:354
  def visit_symbol_node(node); end

  # Visit a TrueNode.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:236
  def visit_true_node(node); end

  # Visit an XStringNode node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:321
  def visit_x_string_node(node); end

  private

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def _dispatch0; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def _dispatch1(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def _dispatch2(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def _dispatch3(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:565
  def _dispatch4(_, _, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:566
  def _dispatch5(_, _, _, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:567
  def _dispatch7(_, _, _, _, _, _, _); end

  # This method is responsible for updating lineno and column information
  # to reflect the current node.
  #
  # This method could be drastically improved with some caching on the start
  # of every line, but for now it's good enough.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:544
  def bounds(location); end

  # If we need to do something unusual, we can directly update the line number
  # and column to reflect the current node.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:551
  def bounds_values(lineno, column); end

  # For CRuby et al, "no block" in an on_block_var is false
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:527
  def no_block_value; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_BEGIN(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_CHAR(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_END(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on___end__(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_alias(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_alias_error(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_aref(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_aref_field(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_arg_ambiguous(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_arg_paren(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_args_add(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_args_add_block(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_args_add_star(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_args_forward; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_args_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_array(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:565
  def on_aryptn(_, _, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_assign(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_assign_error(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_assoc_new(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_assoc_splat(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_assoclist_from_args(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_backref(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_backtick(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_bare_assoc_hash(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_begin(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_binary(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_block_var(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_blockarg(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:565
  def on_bodystmt(_, _, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_brace_block(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_break(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_call(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_case(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_class(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_class_name_error(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_comma(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_command(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:565
  def on_command_call(_, _, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_comment(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_const(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_const_path_field(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_const_path_ref(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_const_ref(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_cvar(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_def(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_defined(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:566
  def on_defs(_, _, _, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_do_block(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_dot2(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_dot3(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_dyna_symbol(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_else(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_elsif(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_embdoc(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_embdoc_beg(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_embdoc_end(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_embexpr_beg(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_embexpr_end(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_embvar(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_ensure(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_excessed_comma; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_fcall(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_field(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_float(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:565
  def on_fndptn(_, _, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_for(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_gvar(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_hash(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_heredoc_beg(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_heredoc_dedent(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_heredoc_end(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_hshptn(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_ident(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_if(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_if_mod(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_ifop(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_ignored_nl(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_ignored_sp(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_imaginary(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_in(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_int(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_ivar(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_kw(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_kwrest_param(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_label(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_label_end(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_lambda(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_lbrace(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_lbracket(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_lparen(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_magic_comment(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_massign(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_method_add_arg(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_method_add_block(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_mlhs_add(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_mlhs_add_post(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_mlhs_add_star(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_mlhs_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_mlhs_paren(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_module(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_mrhs_add(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_mrhs_add_star(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_mrhs_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_mrhs_new_from_args(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_next(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_nl(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_nokw_param(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_op(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_opassign(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_operator_ambiguous(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_param_error(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:567
  def on_params(_, _, _, _, _, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_paren(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_parse_error(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_period(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_program(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_qsymbols_add(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_qsymbols_beg(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_qsymbols_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_qwords_add(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_qwords_beg(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_qwords_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_rational(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_rbrace(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_rbracket(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_redo; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_regexp_add(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_regexp_beg(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_regexp_end(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_regexp_literal(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_regexp_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:565
  def on_rescue(_, _, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_rescue_mod(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_rest_param(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_retry; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_return(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_return0; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_rparen(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_sclass(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_semicolon(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_sp(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_stmts_add(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_stmts_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_string_add(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_string_concat(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_string_content; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_string_dvar(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_string_embexpr(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_string_literal(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_super(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_symbeg(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_symbol(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_symbol_literal(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_symbols_add(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_symbols_beg(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_symbols_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_tlambda(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_tlambeg(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_top_const_field(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_top_const_ref(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_tstring_beg(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_tstring_content(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_tstring_end(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_unary(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_undef(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_unless(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_unless_mod(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_until(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_until_mod(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_var_alias(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_var_field(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_var_ref(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_vcall(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_void_stmt; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:564
  def on_when(_, _, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_while(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_while_mod(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_word_add(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_word_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_words_add(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_words_beg(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_words_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_words_sep(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:563
  def on_xstring_add(_, _); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_xstring_literal(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_xstring_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:562
  def on_yield(_); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_yield0; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:561
  def on_zsuper; end

  # Lazily initialize the parse result.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:557
  def result; end

  # In Prism this is a CallNode with :[]= as the operator.
  # In Ripper it's an :aref_field.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:483
  def visit_aref_field_node(node); end

  # In Prism this is a CallNode with :[] as the operator.
  # In Ripper it's an :aref.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:475
  def visit_aref_node(node); end

  # Visit an operation-and-assign node, such as +=.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:463
  def visit_binary_op_assign(node, operator: T.unsafe(nil)); end

  # Visit a binary operator node like an AndNode or OrNode
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:533
  def visit_binary_operator(node); end

  # Visit a list of elements, like the elements of an array or arguments.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:455
  def visit_elements(elements); end

  # Generate Ripper events for a CallNode with no opening_loc
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:391
  def visit_no_paren_call(node); end

  # Visit a node that represents a number. We need to explicitly handle the
  # unary - operator.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:492
  def visit_number(node); end

  # For most Rubies and JRuby after 9.4.6.0 this is a no-op.
  #
  # source://prism-0.23.0/lib/prism/translation/ripper.rb:515
  def visit_unary_operator(value); end

  class << self
    # This is a convenience method that runs the SexpBuilderPP subclass parser.
    #
    # source://prism-0.23.0/lib/prism/translation/ripper.rb:384
    def sexp(source); end

    # This is a convenience method that runs the SexpBuilder subclass parser.
    #
    # source://prism-0.23.0/lib/prism/translation/ripper.rb:379
    def sexp_raw(source); end
  end
end

# This class mirrors the ::Ripper::SexpBuilder subclass of ::Ripper that
# returns the arrays of [type, *children].
#
# source://prism-0.23.0/lib/prism/translation/ripper.rb:24
class Prism::Translation::Ripper::SexpBuilder < ::Prism::Translation::Ripper
  private

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_BEGIN(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_CHAR(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_END(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on___end__(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_alias(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_alias_error(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_aref(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_aref_field(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_arg_ambiguous(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_arg_paren(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_args_add(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_args_add_block(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_args_add_star(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_args_forward(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_args_new(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_array(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_aryptn(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_assign(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_assign_error(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_assoc_new(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_assoc_splat(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_assoclist_from_args(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_backref(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_backtick(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_bare_assoc_hash(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_begin(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_binary(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_block_var(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_blockarg(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_bodystmt(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_brace_block(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_break(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_call(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_case(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_class(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_class_name_error(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_comma(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_command(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_command_call(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_comment(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_const(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_const_path_field(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_const_path_ref(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_const_ref(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_cvar(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_def(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_defined(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_defs(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_do_block(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_dot2(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_dot3(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_dyna_symbol(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_else(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_elsif(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_embdoc(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_embdoc_beg(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_embdoc_end(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_embexpr_beg(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_embexpr_end(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_embvar(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_ensure(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_excessed_comma(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_fcall(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_field(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_float(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_fndptn(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_for(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_gvar(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_hash(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_heredoc_beg(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_heredoc_dedent(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_heredoc_end(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_hshptn(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_ident(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_if(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_if_mod(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_ifop(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_ignored_nl(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_ignored_sp(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_imaginary(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_in(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_int(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_ivar(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_kw(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_kwrest_param(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_label(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_label_end(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_lambda(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_lbrace(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_lbracket(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_lparen(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_magic_comment(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_massign(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_method_add_arg(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_method_add_block(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_mlhs_add(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_mlhs_add_post(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_mlhs_add_star(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_mlhs_new(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_mlhs_paren(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_module(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_mrhs_add(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_mrhs_add_star(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_mrhs_new(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_mrhs_new_from_args(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_next(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_nl(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_nokw_param(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_op(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_opassign(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_operator_ambiguous(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_param_error(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_params(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_paren(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_parse_error(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_period(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_program(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_qsymbols_add(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_qsymbols_beg(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_qsymbols_new(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_qwords_add(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_qwords_beg(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_qwords_new(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_rational(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_rbrace(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_rbracket(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_redo(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_regexp_add(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_regexp_beg(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_regexp_end(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_regexp_literal(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_regexp_new(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_rescue(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_rescue_mod(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_rest_param(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_retry(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_return(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_return0(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_rparen(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_sclass(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_semicolon(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_sp(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_stmts_add(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_stmts_new(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_string_add(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_string_concat(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_string_content(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_string_dvar(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_string_embexpr(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_string_literal(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_super(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_symbeg(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_symbol(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_symbol_literal(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_symbols_add(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_symbols_beg(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_symbols_new(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_tlambda(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_tlambeg(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_top_const_field(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_top_const_ref(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_tstring_beg(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_tstring_content(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_tstring_end(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_unary(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_undef(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_unless(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_unless_mod(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_until(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_until_mod(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_var_alias(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_var_field(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_var_ref(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_vcall(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_void_stmt(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_when(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_while(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_while_mod(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_word_add(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_word_new(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_words_add(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_words_beg(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_words_new(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:34
  def on_words_sep(value); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_xstring_add(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_xstring_literal(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_xstring_new(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_yield(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_yield0(*args); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:28
  def on_zsuper(*args); end
end

# This class mirrors the ::Ripper::SexpBuilderPP subclass of ::Ripper that
# returns the same values as ::Ripper::SexpBuilder except with a couple of
# niceties that flatten linked lists into arrays.
#
# source://prism-0.23.0/lib/prism/translation/ripper.rb:43
class Prism::Translation::Ripper::SexpBuilderPP < ::Prism::Translation::Ripper::SexpBuilder
  private

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:46
  def _dispatch_event_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def _dispatch_event_push(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def on_args_add(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:46
  def on_args_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def on_mlhs_add(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:46
  def on_mlhs_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def on_mrhs_add(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:46
  def on_mrhs_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def on_qsymbols_add(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:46
  def on_qsymbols_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def on_qwords_add(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:46
  def on_qwords_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def on_regexp_add(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:46
  def on_regexp_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def on_stmts_add(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:46
  def on_stmts_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def on_string_add(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def on_symbols_add(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:46
  def on_symbols_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def on_word_add(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:46
  def on_word_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def on_words_add(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:46
  def on_words_new; end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:50
  def on_xstring_add(list, item); end

  # source://prism-0.23.0/lib/prism/translation/ripper.rb:46
  def on_xstring_new; end
end

# Represents the use of the literal `true` keyword.
#
#     true
#     ^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:16734
class Prism::TrueNode < ::Prism::Node
  # def initialize: (Location location) -> void
  #
  # @return [TrueNode] a new instance of TrueNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16736
  def initialize(location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:16742
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16747
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16757
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16752
  def compact_child_nodes; end

  # def copy: (**params) -> TrueNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16762
  sig { params(params: T.untyped).returns(Prism::TrueNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16747
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:16772
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16777
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:16796
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:16806
    def type; end
  end
end

# Represents the use of the `undef` keyword.
#
#     undef :foo, :bar, :baz
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:16815
class Prism::UndefNode < ::Prism::Node
  # def initialize: (Array[Node] names, Location keyword_loc, Location location) -> void
  #
  # @return [UndefNode] a new instance of UndefNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16823
  def initialize(names, keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:16831
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16836
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16846
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16841
  def compact_child_nodes; end

  # def copy: (**params) -> UndefNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16851
  sig { params(params: T.untyped).returns(Prism::UndefNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16836
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { names: Array[Node], keyword_loc: Location, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:16863
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16873
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16868
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:16820
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader names: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16817
  sig { returns(T::Array[Prism::Node]) }
  def names; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:16894
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:16904
    def type; end
  end
end

# Represents the use of the `unless` keyword, either in the block form or the modifier form.
#
#     bar unless foo
#     ^^^^^^^^^^^^^^
#
#     unless foo then bar end
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:16916
class Prism::UnlessNode < ::Prism::Node
  # def initialize: (Location keyword_loc, Node predicate, Location? then_keyword_loc, StatementsNode? statements, ElseNode? consequent, Location? end_keyword_loc, Location location) -> void
  #
  # @return [UnlessNode] a new instance of UnlessNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16936
  def initialize(keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:16948
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16957
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16971
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16962
  def compact_child_nodes; end

  # attr_reader consequent: ElseNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16930
  sig { returns(T.nilable(Prism::ElseNode)) }
  def consequent; end

  # def copy: (**params) -> UnlessNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:16976
  sig { params(params: T.untyped).returns(Prism::UnlessNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:16957
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { keyword_loc: Location, predicate: Node, then_keyword_loc: Location?, statements: StatementsNode?, consequent: ElseNode?, end_keyword_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:16992
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17007
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16933
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17012
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:16997
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:16918
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:16921
  sig { returns(Prism::Node) }
  def predicate; end

  # source://prism-0.23.0/lib/prism/node.rb:16952
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16927
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # def then_keyword: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17002
  sig { returns(T.nilable(String)) }
  def then_keyword; end

  # attr_reader then_keyword_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:16924
  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:17048
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:17058
    def type; end
  end
end

# Represents the use of the `until` keyword, either in the block form or the modifier form.
#
#     bar until foo
#     ^^^^^^^^^^^^^
#
#     until foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:17070
class Prism::UntilNode < ::Prism::Node
  # def initialize: (Integer flags, Location keyword_loc, Location? closing_loc, Node predicate, StatementsNode? statements, Location location) -> void
  #
  # @return [UntilNode] a new instance of UntilNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:17088
  def initialize(flags, keyword_loc, closing_loc, predicate, statements, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:17099
  def accept(visitor); end

  # def begin_modifier?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17146
  sig { returns(T::Boolean) }
  def begin_modifier?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17108
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17156
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17079
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17121
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17113
  def compact_child_nodes; end

  # def copy: (**params) -> UntilNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:17126
  sig { params(params: T.untyped).returns(Prism::UntilNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17108
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, keyword_loc: Location, closing_loc: Location?, predicate: Node, statements: StatementsNode?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:17141
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17161
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17151
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:17076
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:17082
  sig { returns(Prism::Node) }
  def predicate; end

  # source://prism-0.23.0/lib/prism/node.rb:17103
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17085
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:17192
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:17072
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:17202
    def type; end
  end
end

# The version constant is set by reading the result of calling pm_version.
Prism::VERSION = T.let(T.unsafe(nil), String)

# A visitor is a class that provides a default implementation for every accept
# method defined on the nodes. This means it can walk a tree without the
# caller needing to define any special handling. This allows you to handle a
# subset of the tree, while still walking the whole tree.
#
# For example, to find all of the method calls that call the `foo` method, you
# could write:
#
#     class FooCalls < Prism::Visitor
#       def visit_call_node(node)
#         if node.name == "foo"
#           # Do something with the node
#         end
#
#         # Call super so that the visitor continues walking the tree
#         super
#       end
#     end
#
# source://prism-0.23.0/lib/prism/visitor.rb:50
class Prism::Visitor < ::Prism::BasicVisitor
  # Visit a AliasGlobalVariableNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_alias_global_variable_node(node); end

  # Visit a AliasMethodNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_alias_method_node(node); end

  # Visit a AlternationPatternNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_alternation_pattern_node(node); end

  # Visit a AndNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_and_node(node); end

  # Visit a ArgumentsNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_arguments_node(node); end

  # Visit a ArrayNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_array_node(node); end

  # Visit a ArrayPatternNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_array_pattern_node(node); end

  # Visit a AssocNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_assoc_node(node); end

  # Visit a AssocSplatNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_assoc_splat_node(node); end

  # Visit a BackReferenceReadNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_back_reference_read_node(node); end

  # Visit a BeginNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_begin_node(node); end

  # Visit a BlockArgumentNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_block_argument_node(node); end

  # Visit a BlockLocalVariableNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_block_local_variable_node(node); end

  # Visit a BlockNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_block_node(node); end

  # Visit a BlockParameterNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_block_parameter_node(node); end

  # Visit a BlockParametersNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_block_parameters_node(node); end

  # Visit a BreakNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_break_node(node); end

  # Visit a CallAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_call_and_write_node(node); end

  # Visit a CallNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_call_node(node); end

  # Visit a CallOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_call_operator_write_node(node); end

  # Visit a CallOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_call_or_write_node(node); end

  # Visit a CallTargetNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_call_target_node(node); end

  # Visit a CapturePatternNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_capture_pattern_node(node); end

  # Visit a CaseMatchNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_case_match_node(node); end

  # Visit a CaseNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_case_node(node); end

  # Visit a ClassNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_class_node(node); end

  # Visit a ClassVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_class_variable_and_write_node(node); end

  # Visit a ClassVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_class_variable_operator_write_node(node); end

  # Visit a ClassVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_class_variable_or_write_node(node); end

  # Visit a ClassVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_class_variable_read_node(node); end

  # Visit a ClassVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_class_variable_target_node(node); end

  # Visit a ClassVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_class_variable_write_node(node); end

  # Visit a ConstantAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_constant_and_write_node(node); end

  # Visit a ConstantOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_constant_operator_write_node(node); end

  # Visit a ConstantOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_constant_or_write_node(node); end

  # Visit a ConstantPathAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_constant_path_and_write_node(node); end

  # Visit a ConstantPathNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_constant_path_node(node); end

  # Visit a ConstantPathOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_constant_path_operator_write_node(node); end

  # Visit a ConstantPathOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_constant_path_or_write_node(node); end

  # Visit a ConstantPathTargetNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_constant_path_target_node(node); end

  # Visit a ConstantPathWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_constant_path_write_node(node); end

  # Visit a ConstantReadNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_constant_read_node(node); end

  # Visit a ConstantTargetNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_constant_target_node(node); end

  # Visit a ConstantWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_constant_write_node(node); end

  # Visit a DefNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_def_node(node); end

  # Visit a DefinedNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_defined_node(node); end

  # Visit a ElseNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_else_node(node); end

  # Visit a EmbeddedStatementsNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_embedded_statements_node(node); end

  # Visit a EmbeddedVariableNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_embedded_variable_node(node); end

  # Visit a EnsureNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_ensure_node(node); end

  # Visit a FalseNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_false_node(node); end

  # Visit a FindPatternNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_find_pattern_node(node); end

  # Visit a FlipFlopNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_flip_flop_node(node); end

  # Visit a FloatNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_float_node(node); end

  # Visit a ForNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_for_node(node); end

  # Visit a ForwardingArgumentsNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_forwarding_arguments_node(node); end

  # Visit a ForwardingParameterNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_forwarding_parameter_node(node); end

  # Visit a ForwardingSuperNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_forwarding_super_node(node); end

  # Visit a GlobalVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_global_variable_and_write_node(node); end

  # Visit a GlobalVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_global_variable_operator_write_node(node); end

  # Visit a GlobalVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_global_variable_or_write_node(node); end

  # Visit a GlobalVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_global_variable_read_node(node); end

  # Visit a GlobalVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_global_variable_target_node(node); end

  # Visit a GlobalVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_global_variable_write_node(node); end

  # Visit a HashNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_hash_node(node); end

  # Visit a HashPatternNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_hash_pattern_node(node); end

  # Visit a IfNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_if_node(node); end

  # Visit a ImaginaryNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_imaginary_node(node); end

  # Visit a ImplicitNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_implicit_node(node); end

  # Visit a ImplicitRestNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_implicit_rest_node(node); end

  # Visit a InNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_in_node(node); end

  # Visit a IndexAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_index_and_write_node(node); end

  # Visit a IndexOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_index_operator_write_node(node); end

  # Visit a IndexOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_index_or_write_node(node); end

  # Visit a IndexTargetNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_index_target_node(node); end

  # Visit a InstanceVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_instance_variable_and_write_node(node); end

  # Visit a InstanceVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_instance_variable_operator_write_node(node); end

  # Visit a InstanceVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_instance_variable_or_write_node(node); end

  # Visit a InstanceVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_instance_variable_read_node(node); end

  # Visit a InstanceVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_instance_variable_target_node(node); end

  # Visit a InstanceVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_instance_variable_write_node(node); end

  # Visit a IntegerNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_integer_node(node); end

  # Visit a InterpolatedMatchLastLineNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_interpolated_match_last_line_node(node); end

  # Visit a InterpolatedRegularExpressionNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_interpolated_regular_expression_node(node); end

  # Visit a InterpolatedStringNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_interpolated_string_node(node); end

  # Visit a InterpolatedSymbolNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_interpolated_symbol_node(node); end

  # Visit a InterpolatedXStringNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_interpolated_x_string_node(node); end

  # Visit a KeywordHashNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_keyword_hash_node(node); end

  # Visit a KeywordRestParameterNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_keyword_rest_parameter_node(node); end

  # Visit a LambdaNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_lambda_node(node); end

  # Visit a LocalVariableAndWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_local_variable_and_write_node(node); end

  # Visit a LocalVariableOperatorWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_local_variable_operator_write_node(node); end

  # Visit a LocalVariableOrWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_local_variable_or_write_node(node); end

  # Visit a LocalVariableReadNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_local_variable_read_node(node); end

  # Visit a LocalVariableTargetNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_local_variable_target_node(node); end

  # Visit a LocalVariableWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_local_variable_write_node(node); end

  # Visit a MatchLastLineNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_match_last_line_node(node); end

  # Visit a MatchPredicateNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_match_predicate_node(node); end

  # Visit a MatchRequiredNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_match_required_node(node); end

  # Visit a MatchWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_match_write_node(node); end

  # Visit a MissingNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_missing_node(node); end

  # Visit a ModuleNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_module_node(node); end

  # Visit a MultiTargetNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_multi_target_node(node); end

  # Visit a MultiWriteNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_multi_write_node(node); end

  # Visit a NextNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_next_node(node); end

  # Visit a NilNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_nil_node(node); end

  # Visit a NoKeywordsParameterNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_no_keywords_parameter_node(node); end

  # Visit a NumberedParametersNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_numbered_parameters_node(node); end

  # Visit a NumberedReferenceReadNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_numbered_reference_read_node(node); end

  # Visit a OptionalKeywordParameterNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_optional_keyword_parameter_node(node); end

  # Visit a OptionalParameterNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_optional_parameter_node(node); end

  # Visit a OrNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_or_node(node); end

  # Visit a ParametersNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_parameters_node(node); end

  # Visit a ParenthesesNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_parentheses_node(node); end

  # Visit a PinnedExpressionNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_pinned_expression_node(node); end

  # Visit a PinnedVariableNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_pinned_variable_node(node); end

  # Visit a PostExecutionNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_post_execution_node(node); end

  # Visit a PreExecutionNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_pre_execution_node(node); end

  # Visit a ProgramNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_program_node(node); end

  # Visit a RangeNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_range_node(node); end

  # Visit a RationalNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_rational_node(node); end

  # Visit a RedoNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_redo_node(node); end

  # Visit a RegularExpressionNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_regular_expression_node(node); end

  # Visit a RequiredKeywordParameterNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_required_keyword_parameter_node(node); end

  # Visit a RequiredParameterNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_required_parameter_node(node); end

  # Visit a RescueModifierNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_rescue_modifier_node(node); end

  # Visit a RescueNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_rescue_node(node); end

  # Visit a RestParameterNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_rest_parameter_node(node); end

  # Visit a RetryNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_retry_node(node); end

  # Visit a ReturnNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_return_node(node); end

  # Visit a SelfNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_self_node(node); end

  # Visit a SingletonClassNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_singleton_class_node(node); end

  # Visit a SourceEncodingNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_source_encoding_node(node); end

  # Visit a SourceFileNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_source_file_node(node); end

  # Visit a SourceLineNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_source_line_node(node); end

  # Visit a SplatNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_splat_node(node); end

  # Visit a StatementsNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_statements_node(node); end

  # Visit a StringNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_string_node(node); end

  # Visit a SuperNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_super_node(node); end

  # Visit a SymbolNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_symbol_node(node); end

  # Visit a TrueNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_true_node(node); end

  # Visit a UndefNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_undef_node(node); end

  # Visit a UnlessNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_unless_node(node); end

  # Visit a UntilNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_until_node(node); end

  # Visit a WhenNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_when_node(node); end

  # Visit a WhileNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_while_node(node); end

  # Visit a XStringNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_x_string_node(node); end

  # Visit a YieldNode node
  #
  # source://prism-0.23.0/lib/prism/visitor.rb:26
  def visit_yield_node(node); end
end

# Represents the use of the `when` keyword within a case statement.
#
#     case true
#     when true
#     ^^^^^^^^^
#     end
#
# source://prism-0.23.0/lib/prism/node.rb:17213
class Prism::WhenNode < ::Prism::Node
  # def initialize: (Location keyword_loc, Array[Node] conditions, StatementsNode? statements, Location location) -> void
  #
  # @return [WhenNode] a new instance of WhenNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:17224
  def initialize(keyword_loc, conditions, statements, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:17233
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17238
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17251
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17243
  def compact_child_nodes; end

  # attr_reader conditions: Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17218
  sig { returns(T::Array[Prism::Node]) }
  def conditions; end

  # def copy: (**params) -> WhenNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:17256
  sig { params(params: T.untyped).returns(Prism::WhenNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17238
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { keyword_loc: Location, conditions: Array[Node], statements: StatementsNode?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:17269
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17279
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17274
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:17215
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17221
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:17306
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:17316
    def type; end
  end
end

# Represents the use of the `while` keyword, either in the block form or the modifier form.
#
#     bar while foo
#     ^^^^^^^^^^^^^
#
#     while foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:17328
class Prism::WhileNode < ::Prism::Node
  # def initialize: (Integer flags, Location keyword_loc, Location? closing_loc, Node predicate, StatementsNode? statements, Location location) -> void
  #
  # @return [WhileNode] a new instance of WhileNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:17346
  def initialize(flags, keyword_loc, closing_loc, predicate, statements, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:17357
  def accept(visitor); end

  # def begin_modifier?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17404
  sig { returns(T::Boolean) }
  def begin_modifier?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17366
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17414
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17337
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17379
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17371
  def compact_child_nodes; end

  # def copy: (**params) -> WhileNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:17384
  sig { params(params: T.untyped).returns(Prism::WhileNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17366
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, keyword_loc: Location, closing_loc: Location?, predicate: Node, statements: StatementsNode?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:17399
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17419
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17409
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:17334
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://prism-0.23.0/lib/prism/node.rb:17340
  sig { returns(Prism::Node) }
  def predicate; end

  # source://prism-0.23.0/lib/prism/node.rb:17361
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17343
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:17450
  def type; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:17330
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:17460
    def type; end
  end
end

# Represents an xstring literal with no interpolation.
#
#     `foo`
#     ^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:17469
class Prism::XStringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  # def initialize: (Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped, Location location) -> void
  #
  # @return [XStringNode] a new instance of XStringNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:17487
  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:17498
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17503
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17558
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:17481
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17513
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17508
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17553
  sig { returns(String) }
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:17478
  sig { returns(Prism::Location) }
  def content_loc; end

  # def copy: (**params) -> XStringNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:17518
  sig { params(params: T.untyped).returns(Prism::XStringNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17503
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { flags: Integer, opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:17533
  def deconstruct_keys(keys); end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17543
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17538
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17563
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17548
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:17475
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:17588
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17484
  sig { returns(String) }
  def unescaped; end

  private

  # private attr_reader flags: Integer
  #
  # source://prism-0.23.0/lib/prism/node.rb:17471
  sig { returns(Integer) }
  def flags; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:17598
    def type; end
  end
end

# Represents the use of the `yield` keyword.
#
#     yield 1
#     ^^^^^^^
#
# source://prism-0.23.0/lib/prism/node.rb:17607
class Prism::YieldNode < ::Prism::Node
  # def initialize: (Location keyword_loc, Location? lparen_loc, ArgumentsNode? arguments, Location? rparen_loc, Location location) -> void
  #
  # @return [YieldNode] a new instance of YieldNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:17621
  def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, location); end

  # def accept: (Visitor visitor) -> void
  #
  # source://prism-0.23.0/lib/prism/node.rb:17631
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17615
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17636
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17648
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17641
  def compact_child_nodes; end

  # def copy: (**params) -> YieldNode
  #
  # source://prism-0.23.0/lib/prism/node.rb:17653
  sig { params(params: T.untyped).returns(Prism::YieldNode) }
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism-0.23.0/lib/prism/node.rb:17636
  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, location: Location }
  #
  # source://prism-0.23.0/lib/prism/node.rb:17667
  def deconstruct_keys(keys); end

  # def inspect(NodeInspector inspector) -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17687
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism-0.23.0/lib/prism/node.rb:17672
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism-0.23.0/lib/prism/node.rb:17609
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17677
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17612
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17682
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism-0.23.0/lib/prism/node.rb:17618
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism-0.23.0/lib/prism/node.rb:17715
  def type; end

  class << self
    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # def self.type: () -> Symbol
    #
    # source://prism-0.23.0/lib/prism/node.rb:17725
    def type; end
  end
end

# source://rubocop-1.34.1/lib/rubocop/target_ruby.rb:7
RuboCop::TargetRuby::KNOWN_RUBIES = T.let(T.unsafe(nil), Array)
